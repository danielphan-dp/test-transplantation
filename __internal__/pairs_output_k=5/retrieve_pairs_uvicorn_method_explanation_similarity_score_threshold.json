{
  "pairs": [
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_run_invalid_app_config_combination",
        "module": "test_main",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_main.py",
        "line_number": 75,
        "end_line_number": 83,
        "source_code": "def test_run_invalid_app_config_combination(caplog: pytest.LogCaptureFixture) -> None:\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, reload=True)\n    assert exit_exception.value.code == 1\n    assert caplog.records[-1].name == \"uvicorn.error\"\n    assert caplog.records[-1].levelno == WARNING\n    assert caplog.records[-1].message == (\n        \"You must pass the application as an import string to enable \" \"'reload' or 'workers'.\"\n    )",
        "docstring": null,
        "decorators": [],
        "arguments": [
          "caplog"
        ],
        "imports": [
          "inspect",
          "socket",
          "logging.WARNING",
          "httpx",
          "pytest",
          "tests.utils.run_server",
          "uvicorn.Server",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Scope",
          "uvicorn.config.Config",
          "uvicorn.main.run"
        ],
        "fixtures": [],
        "assertions": [
          "assert exit_exception.value.code == 1",
          "assert caplog.records[-1].name == 'uvicorn.error'",
          "assert caplog.records[-1].levelno == WARNING",
          "assert caplog.records[-1].message == \"You must pass the application as an import string to enable 'reload' or 'workers'.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "run",
            "body": "def run(sockets):\n    pass",
            "method_explanation": "**Main Purpose of the Method**:\nThe `run` method is designed to start a server using the provided sockets, which can be either UNIX domain sockets, file descriptors, or standard host/port pairs. It handles the initialization of the server based on the configuration and manages the logging of the server's startup status.\n\n**How It Works**:\nThe method first checks the configuration for existing sockets or file descriptors. If a file descriptor is provided, it creates a socket from it. If a UNIX domain socket path is specified, it creates a UNIX socket and sets its permissions. If neither is available, it defaults to creating a standard TCP socket using the specified host and port. After successfully creating the server, it logs the startup message unless sockets are provided (indicating multiple workers). Finally, it sets a flag to indicate that the server has started."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a dynamically obtained port number from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument, which captures the output and error streams generated by the command execution. This allows the method to return the results of the server's output, including any welcome messages or errors encountered during startup."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a dynamically obtained port number from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument, which likely captures the output and error streams of the command execution. This allows the method to return the output generated by the server when it runs in REPL mode, enabling further assertions or logging in tests."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a dynamically obtained port number from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument, which likely captures standard output and error streams during the execution of the command. This allows the method to return the output generated by the server when it runs in REPL mode, enabling further assertions or logging in tests."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a port number obtained from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument to capture the output and error streams generated during the execution of the command. This allows the method to return the results of the server's output, which can be used for logging or testing purposes."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a port number obtained from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument, which likely captures standard output and error streams during the execution of the command. The method returns the result of this execution, which includes any output generated by the server. The accompanying test function verifies that the REPL starts correctly in interactive mode and checks for specific log messages when the REPL cannot start due to non-interactive conditions."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_run_startup_failure",
        "module": "test_main",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_main.py",
        "line_number": 86,
        "end_line_number": 95,
        "source_code": "def test_run_startup_failure(caplog: pytest.LogCaptureFixture) -> None:\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"lifespan\"\n        message = await receive()\n        if message[\"type\"] == \"lifespan.startup\":\n            raise RuntimeError(\"Startup failed\")\n\n    with pytest.raises(SystemExit) as exit_exception:\n        run(app, lifespan=\"on\")\n    assert exit_exception.value.code == 3",
        "docstring": null,
        "decorators": [],
        "arguments": [
          "caplog"
        ],
        "imports": [
          "inspect",
          "socket",
          "logging.WARNING",
          "httpx",
          "pytest",
          "tests.utils.run_server",
          "uvicorn.Server",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Scope",
          "uvicorn.config.Config",
          "uvicorn.main.run"
        ],
        "fixtures": [],
        "assertions": [
          "assert exit_exception.value.code == 3",
          "assert scope['type'] == 'lifespan'"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "run",
            "body": "def run(sockets):\n    pass",
            "method_explanation": "**Main Purpose of the Method**:\nThe `run` method is designed to start a server using the provided sockets, which can be either UNIX domain sockets, file descriptors, or standard host/port pairs. It handles the initialization of the server and manages the logging of its startup status.\n\n**How It Works**:\nThe method accepts a list of sockets as an argument. It first checks the configuration to determine how to create the server:\n- If a file descriptor (`fd`) is provided, it creates a socket from that descriptor.\n- If a UNIX domain socket (`uds`) is specified, it creates a server using that socket.\n- If neither is provided, it defaults to creating a server using a host and port.\n\nAfter successfully creating the server, it logs a message indicating that the server has started, unless sockets are provided (indicating multiple workers are running). The method also sets a flag (`self.started`) to indicate that the server has been successfully started."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a dynamically obtained port number from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument, which captures the output and error streams generated by the command execution. This allows the method to return the results of the server's output, including any welcome messages or errors encountered during startup."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a port number obtained from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument to capture the output and error streams generated during the execution of the command. This allows the method to return the results of the server's output, which can be used for logging or testing purposes."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a dynamically obtained port number from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument, which likely captures the output and error streams of the command execution. This allows the method to return the output generated by the server when it runs in REPL mode, enabling further assertions or logging in tests."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to start a server application with an interactive Read-Eval-Print Loop (REPL) mode, allowing users to interact with the server in a command-line interface.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to enable REPL mode, and a dynamically obtained port number from the `get_port()` function. It then calls the `capture` function with this command and the `capsys` argument, which likely captures standard output and error streams during the execution of the command. This allows the method to return the output generated by the server when it runs in REPL mode, enabling further assertions or logging in tests."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "server.run",
              "body": "def run():\n    command = ['fake.server.app', '--repl', f'-p={get_port()}']\n    return capture(command, capsys=capsys)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `server.run` method is designed to execute a server application with specific command-line arguments, particularly enabling a Read-Eval-Print Loop (REPL) mode for interactive use.\n\n**How It Works**:\nThe method constructs a command list that includes the server application name (`fake.server.app`), the `--repl` flag to indicate REPL mode, and a dynamically obtained port number from the `get_port()` function. It then calls the `capture` function, passing the command and a `capsys` argument to capture standard output and error streams during execution. This allows the method to run the server in a controlled environment and retrieve any output or errors generated during the process."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_get_subprocess",
        "module": "test_subprocess",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
        "line_number": 19,
        "end_line_number": 28,
        "source_code": "def test_get_subprocess() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    process = get_subprocess(config, server_run, [fdsock])\n    assert isinstance(process, SpawnProcess)\n\n    fdsock.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "__future__.annotations",
          "socket",
          "unittest.mock.patch",
          "uvicorn._subprocess.SpawnProcess",
          "uvicorn._subprocess.get_subprocess",
          "uvicorn._subprocess.subprocess_started",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Scope",
          "uvicorn.config.Config"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(process, SpawnProcess)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "fdsock.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to safely close a socket or connection by marking it as closed, ensuring that no further operations can be performed on it.\n\n**How It Works**:\nThe method first asserts that the socket is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, effectively marking the socket as closed. This prevents any subsequent operations on the socket, helping to manage resources and avoid potential errors from attempting to use a closed connection."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 534,
          "end_line_number": 608,
          "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling process."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_subprocess_started",
        "module": "test_subprocess",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_subprocess.py",
        "line_number": 31,
        "end_line_number": 43,
        "source_code": "def test_subprocess_started() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    with patch(\"tests.test_subprocess.server_run\") as mock_run:\n        with patch.object(config, \"configure_logging\") as mock_config_logging:\n            subprocess_started(config, server_run, [fdsock], None)\n            mock_run.assert_called_once()\n            mock_config_logging.assert_called_once()\n\n    fdsock.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "__future__.annotations",
          "socket",
          "unittest.mock.patch",
          "uvicorn._subprocess.SpawnProcess",
          "uvicorn._subprocess.get_subprocess",
          "uvicorn._subprocess.subprocess_started",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Scope",
          "uvicorn.config.Config"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "fdsock.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to safely close a socket connection by marking it as closed, ensuring that no further operations can be performed on it.\n\n**How It Works**:\nThe method first asserts that the socket is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent operations on the socket, helping to manage resources effectively and avoid potential errors from attempting to use a closed socket."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 534,
          "end_line_number": 608,
          "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling process."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_socket_bind",
        "module": "test_config",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_config.py",
        "line_number": 262,
        "end_line_number": 267,
        "source_code": "def test_socket_bind() -> None:\n    config = Config(app=asgi_app)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    sock.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "__future__.annotations",
          "configparser",
          "io",
          "json",
          "logging",
          "os",
          "socket",
          "sys",
          "typing",
          "pathlib.Path",
          "typing.Any",
          "typing.Literal",
          "unittest.mock.MagicMock",
          "pytest",
          "yaml",
          "pytest_mock.MockerFixture",
          "tests.utils.as_cwd",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Environ",
          "uvicorn._types.Scope",
          "uvicorn._types.StartResponse",
          "uvicorn.config.Config",
          "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
          "uvicorn.middleware.wsgi.WSGIMiddleware",
          "uvicorn.protocols.http.h11_impl.H11Protocol"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(sock, socket.socket)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "sock.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_bind_unix_socket_works_with_reload_or_workers",
        "module": "test_config",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_config.py",
        "line_number": 491,
        "end_line_number": 500,
        "source_code": "def test_bind_unix_socket_works_with_reload_or_workers(\n    tmp_path: Path, reload: bool, workers: int, short_socket_name: str\n):  # pragma: py-win32\n    config = Config(app=asgi_app, uds=short_socket_name, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == short_socket_name\n    sock.close()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
          "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
        ],
        "arguments": [
          "tmp_path",
          "reload",
          "workers",
          "short_socket_name"
        ],
        "imports": [
          "__future__.annotations",
          "configparser",
          "io",
          "json",
          "logging",
          "os",
          "socket",
          "sys",
          "typing",
          "pathlib.Path",
          "typing.Any",
          "typing.Literal",
          "unittest.mock.MagicMock",
          "pytest",
          "yaml",
          "pytest_mock.MockerFixture",
          "tests.utils.as_cwd",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Environ",
          "uvicorn._types.Scope",
          "uvicorn._types.StartResponse",
          "uvicorn.config.Config",
          "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
          "uvicorn.middleware.wsgi.WSGIMiddleware",
          "uvicorn.protocols.http.h11_impl.H11Protocol"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(sock, socket.socket)",
          "assert sock.family == socket.AF_UNIX",
          "assert sock.getsockname() == short_socket_name"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "sock.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_bind_unix_socket_works_with_reload_or_workers",
        "module": "test_config",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_config.py",
        "line_number": 491,
        "end_line_number": 500,
        "source_code": "def test_bind_unix_socket_works_with_reload_or_workers(\n    tmp_path: Path, reload: bool, workers: int, short_socket_name: str\n):  # pragma: py-win32\n    config = Config(app=asgi_app, uds=short_socket_name, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == short_socket_name\n    sock.close()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
          "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
        ],
        "arguments": [
          "tmp_path",
          "reload",
          "workers",
          "short_socket_name"
        ],
        "imports": [
          "__future__.annotations",
          "configparser",
          "io",
          "json",
          "logging",
          "os",
          "socket",
          "sys",
          "typing",
          "pathlib.Path",
          "typing.Any",
          "typing.Literal",
          "unittest.mock.MagicMock",
          "pytest",
          "yaml",
          "pytest_mock.MockerFixture",
          "tests.utils.as_cwd",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Environ",
          "uvicorn._types.Scope",
          "uvicorn._types.StartResponse",
          "uvicorn.config.Config",
          "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
          "uvicorn.middleware.wsgi.WSGIMiddleware",
          "uvicorn.protocols.http.h11_impl.H11Protocol"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(sock, socket.socket)",
          "assert sock.family == socket.AF_UNIX",
          "assert sock.getsockname() == short_socket_name"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "sock.getsockname",
            "body": "def getsockname(self):\n    return self.sockname",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `getsockname` method retrieves the local socket address (name) associated with the socket object. This address typically includes the IP address and port number for network sockets or the file path for Unix domain sockets.\n\n**How It Works**:  \nThe method simply returns the value of the `sockname` attribute from the socket instance. This attribute is set when the socket is created and bound to a specific address using the `bind` method. In the context of the provided code, it is used to log the socket's address when the server is running, allowing developers to know where the server is listening for incoming connections."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method then retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number, which is returned by the method."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_server_run_with_repl",
          "module": "test_cli",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_cli.py",
          "line_number": 351,
          "end_line_number": 371,
          "source_code": "def test_server_run_with_repl(caplog, capsys):\n    record = (\n        \"sanic.error\",\n        40,\n        \"Can't start REPL in non-interactive mode. \"\n        \"You can only run with --repl in a TTY.\",\n    )\n\n    def run():\n        command = [\"fake.server.app\", \"--repl\", f\"-p={get_port()}\"]\n        return capture(command, capsys=capsys)\n\n    with patch(\"sanic.cli.app.is_atty\", return_value=True):\n        result = run()\n\n    assert record not in caplog.record_tuples\n    assert \"Welcome to the Sanic interactive console\" in result.err\n    assert \">>> \" in result.out\n\n    run()\n    assert record in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog",
            "capsys"
          ],
          "imports": [
            "json",
            "os",
            "sys",
            "pathlib.Path",
            "typing.List",
            "typing.Optional",
            "typing.Tuple",
            "unittest.mock.patch",
            "pytest",
            "sanic_routing.__version__",
            "sanic.__version__",
            "sanic.__main__.main",
            "sanic.cli.inspector_client.InspectorClient",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert record not in caplog.record_tuples",
            "assert 'Welcome to the Sanic interactive console' in result.err",
            "assert '>>> ' in result.out",
            "assert record in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method then retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `[1]`) is the dynamically assigned port number, which is returned by the method."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number.\n4. Finally, the method returns this port number, allowing the caller to know which port has been allocated for use."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number.\n4. Finally, the method returns this port number, allowing the caller to know which port has been allocated for use."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number.\n4. Finally, the method returns this port number, allowing the caller to know which port has been allocated for use."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_bind_fd_works_with_reload_or_workers",
        "module": "test_config",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_config.py",
        "line_number": 512,
        "end_line_number": 522,
        "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
          "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
        ],
        "arguments": [
          "reload",
          "workers"
        ],
        "imports": [
          "__future__.annotations",
          "configparser",
          "io",
          "json",
          "logging",
          "os",
          "socket",
          "sys",
          "typing",
          "pathlib.Path",
          "typing.Any",
          "typing.Literal",
          "unittest.mock.MagicMock",
          "pytest",
          "yaml",
          "pytest_mock.MockerFixture",
          "tests.utils.as_cwd",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Environ",
          "uvicorn._types.Scope",
          "uvicorn._types.StartResponse",
          "uvicorn.config.Config",
          "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
          "uvicorn.middleware.wsgi.WSGIMiddleware",
          "uvicorn.protocols.http.h11_impl.H11Protocol"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(sock, socket.socket)",
          "assert sock.family == socket.AF_UNIX",
          "assert sock.getsockname() == ''"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "sock.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_bind_fd_works_with_reload_or_workers",
        "module": "test_config",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_config.py",
        "line_number": 512,
        "end_line_number": 522,
        "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
          "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
        ],
        "arguments": [
          "reload",
          "workers"
        ],
        "imports": [
          "__future__.annotations",
          "configparser",
          "io",
          "json",
          "logging",
          "os",
          "socket",
          "sys",
          "typing",
          "pathlib.Path",
          "typing.Any",
          "typing.Literal",
          "unittest.mock.MagicMock",
          "pytest",
          "yaml",
          "pytest_mock.MockerFixture",
          "tests.utils.as_cwd",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Environ",
          "uvicorn._types.Scope",
          "uvicorn._types.StartResponse",
          "uvicorn.config.Config",
          "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
          "uvicorn.middleware.wsgi.WSGIMiddleware",
          "uvicorn.protocols.http.h11_impl.H11Protocol"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(sock, socket.socket)",
          "assert sock.family == socket.AF_UNIX",
          "assert sock.getsockname() == ''"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "fdsock.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to safely close a socket connection by marking it as closed, ensuring that no further operations can be performed on it.\n\n**How It Works**:\nThe method first asserts that the socket is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent operations on the socket, helping to manage resources effectively and avoid potential errors from attempting to use a closed socket."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 534,
          "end_line_number": 608,
          "source_code": "def test_https_connect(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a graceful shutdown of the connection handling process."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_bind_fd_works_with_reload_or_workers",
        "module": "test_config",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_config.py",
        "line_number": 512,
        "end_line_number": 522,
        "source_code": "def test_bind_fd_works_with_reload_or_workers(reload: bool, workers: int):  # pragma: py-win32\n    fdsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=asgi_app, fd=fd, reload=reload, workers=workers)\n    config.load()\n    sock = config.bind_socket()\n    assert isinstance(sock, socket.socket)\n    assert sock.family == socket.AF_UNIX\n    assert sock.getsockname() == \"\"\n    sock.close()\n    fdsock.close()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reload, workers', [(True, 1), (False, 2)], ids=['--reload=True --workers=1', '--reload=False --workers=2'])",
          "pytest.mark.skipif(sys.platform == 'win32', reason='require unix-like system')"
        ],
        "arguments": [
          "reload",
          "workers"
        ],
        "imports": [
          "__future__.annotations",
          "configparser",
          "io",
          "json",
          "logging",
          "os",
          "socket",
          "sys",
          "typing",
          "pathlib.Path",
          "typing.Any",
          "typing.Literal",
          "unittest.mock.MagicMock",
          "pytest",
          "yaml",
          "pytest_mock.MockerFixture",
          "tests.utils.as_cwd",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Environ",
          "uvicorn._types.Scope",
          "uvicorn._types.StartResponse",
          "uvicorn.config.Config",
          "uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware",
          "uvicorn.middleware.wsgi.WSGIMiddleware",
          "uvicorn.protocols.http.h11_impl.H11Protocol"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(sock, socket.socket)",
          "assert sock.family == socket.AF_UNIX",
          "assert sock.getsockname() == ''"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "sock.getsockname",
            "body": "def getsockname(self):\n    return self.sockname",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `getsockname` method retrieves the local socket address (name) associated with the socket object. This address typically includes the IP address and port number for network sockets or the file path for Unix domain sockets.\n\n**How It Works**:  \nThe method simply returns the value of the `sockname` attribute from the socket instance. This attribute is set when the socket is created and bound to a specific address using methods like `bind()`. In the context of the provided code, `getsockname` is used to obtain the socket's address for logging or further processing, particularly when the socket is created from a file descriptor or bound to a specific address."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_server_run_with_repl",
          "module": "test_cli",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_cli.py",
          "line_number": 351,
          "end_line_number": 371,
          "source_code": "def test_server_run_with_repl(caplog, capsys):\n    record = (\n        \"sanic.error\",\n        40,\n        \"Can't start REPL in non-interactive mode. \"\n        \"You can only run with --repl in a TTY.\",\n    )\n\n    def run():\n        command = [\"fake.server.app\", \"--repl\", f\"-p={get_port()}\"]\n        return capture(command, capsys=capsys)\n\n    with patch(\"sanic.cli.app.is_atty\", return_value=True):\n        result = run()\n\n    assert record not in caplog.record_tuples\n    assert \"Welcome to the Sanic interactive console\" in result.err\n    assert \">>> \" in result.out\n\n    run()\n    assert record in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog",
            "capsys"
          ],
          "imports": [
            "json",
            "os",
            "sys",
            "pathlib.Path",
            "typing.List",
            "typing.Optional",
            "typing.Tuple",
            "unittest.mock.patch",
            "pytest",
            "sanic_routing.__version__",
            "sanic.__version__",
            "sanic.__main__.main",
            "sanic.cli.inspector_client.InspectorClient",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert record not in caplog.record_tuples",
            "assert 'Welcome to the Sanic interactive console' in result.err",
            "assert '>>> ' in result.out",
            "assert record in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method then retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `[1]`) is the dynamically assigned port number, which is returned by the method."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered_async",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 166,
          "end_line_number": 264,
          "source_code": "def test_listeners_triggered_async(app, caplog):\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    async def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    async def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    async def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    async def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    app.state.verbosity = 0\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method then retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number, which is returned by the method."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number.\n4. Finally, the method returns this port number, allowing the caller to know which port has been allocated for use."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number.\n4. Finally, the method returns this port number, allowing the caller to know which port has been allocated for use."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_listeners_triggered",
          "module": "test_asgi",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_asgi.py",
          "line_number": 65,
          "end_line_number": 163,
          "source_code": "def test_listeners_triggered(caplog):\n    app = Sanic(\"app\")\n    before_server_start = False\n    after_server_start = False\n    before_server_stop = False\n    after_server_stop = False\n\n    @app.listener(\"before_server_start\")\n    def do_before_server_start(*args, **kwargs):\n        nonlocal before_server_start\n        before_server_start = True\n\n    @app.listener(\"after_server_start\")\n    def do_after_server_start(*args, **kwargs):\n        nonlocal after_server_start\n        after_server_start = True\n\n    @app.listener(\"before_server_stop\")\n    def do_before_server_stop(*args, **kwargs):\n        nonlocal before_server_stop\n        before_server_stop = True\n\n    @app.listener(\"after_server_stop\")\n    def do_after_server_stop(*args, **kwargs):\n        nonlocal after_server_stop\n        after_server_stop = True\n\n    @app.route(\"/\")\n    def handler(request):\n        return text(\"...\")\n\n    class CustomServer(uvicorn.Server):\n        def install_signal_handlers(self):\n            pass\n\n    config = uvicorn.Config(\n        app=app, loop=\"asyncio\", limit_max_requests=0, port=get_port()\n    )\n    server = CustomServer(config=config)\n\n    start_message = (\n        'You have set a listener for \"before_server_start\" in ASGI mode. '\n        \"It will be executed as early as possible, but not before the ASGI \"\n        \"server is started.\"\n    )\n    stop_message = (\n        'You have set a listener for \"after_server_stop\" in ASGI mode. '\n        \"It will be executed as late as possible, but not after the ASGI \"\n        \"server is stopped.\"\n    )\n\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    assert before_server_start\n    assert after_server_start\n    assert before_server_stop\n    assert after_server_stop\n\n    app.state.mode = Mode.DEBUG\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) not in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) not in caplog.record_tuples\n\n    app.state.verbosity = 2\n    with caplog.at_level(logging.DEBUG):\n        server.run()\n\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        start_message,\n    ) in caplog.record_tuples\n    assert (\n        \"sanic.root\",\n        logging.DEBUG,\n        stop_message,\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "caplog"
          ],
          "imports": [
            "asyncio",
            "logging",
            "collections.deque",
            "collections.namedtuple",
            "unittest.mock.call",
            "pytest",
            "uvicorn",
            "httpx.Headers",
            "pytest.MonkeyPatch",
            "sanic.Sanic",
            "sanic.application.state.Mode",
            "sanic.asgi.Lifespan",
            "sanic.asgi.MockTransport",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.Forbidden",
            "sanic.exceptions.ServiceUnavailable",
            "sanic.request.Request",
            "sanic.response.json",
            "sanic.response.text",
            "sanic.server.websockets.connection.WebSocketConnection",
            "sanic.signals.RESERVED_NAMESPACES",
            "conftest.get_port",
            "unittest.mock.AsyncMock",
            "tests.asyncmock.AsyncMock"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert before_server_start",
            "assert after_server_start",
            "assert before_server_stop",
            "assert after_server_stop",
            "assert ('sanic.root', logging.DEBUG, start_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) not in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, start_message) in caplog.record_tuples",
            "assert ('sanic.root', logging.DEBUG, stop_message) in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "get_port",
              "body": "def get_port():\n    sock = socket.socket()\n    sock.bind(('', 0))\n    return sock.getsockname()[1]",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `get_port` method is designed to create a new socket, bind it to an available port on the local machine, and return that port number. This is useful for dynamically obtaining a free port for server applications.\n\n**How It Works**:  \n1. A new socket object is created using `socket.socket()`, which defaults to using the Internet address family (IPv4).\n2. The socket is bound to an empty string as the host and `0` as the port, which instructs the operating system to select an available port automatically.\n3. The method retrieves the socket's name using `sock.getsockname()`, which returns a tuple containing the host and port. The second element of this tuple (index `1`) is the dynamically assigned port number.\n4. Finally, the method returns this port number, allowing the caller to know which port has been allocated for use."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_on",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 10,
        "end_line_number": 40,
        "source_code": "def test_lifespan_on():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert message['type'] == 'lifespan.startup'",
          "assert message['type'] == 'lifespan.shutdown'",
          "assert not startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert shutdown_complete"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_on",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 10,
        "end_line_number": 40,
        "source_code": "def test_lifespan_on():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert message['type'] == 'lifespan.startup'",
          "assert message['type'] == 'lifespan.shutdown'",
          "assert not startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert shutdown_complete"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "lifespan.startup",
            "body": "def startup(self):\n    calls.append('startup')",
            "method_explanation": "**Main Purpose of the Method**:\nThe `startup` method is designed to handle the startup phase of an application within the lifespan management context. It logs the startup process, manages asynchronous tasks, and signals when the application is ready or if it has failed to start.\n\n**How It Works**:\n1. The method begins by logging an informational message indicating that the application is waiting for startup.\n2. It retrieves the current event loop and creates a task for the main lifespan process.\n3. A startup event is created and placed in a receive queue, which is used to communicate between different parts of the application.\n4. The method then waits for the `startup_event` to be set, indicating that the startup process is complete.\n5. After waiting, it checks for any errors that occurred during startup. If any issues are detected, it logs an error message and sets a flag to indicate that the application should exit. If the startup is successful, it logs a completion message."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_create_server_main_convenience",
          "module": "test_app",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_app.py",
          "line_number": 114,
          "end_line_number": 127,
          "source_code": "def test_create_server_main_convenience(app: Sanic, caplog, port):\n    app.main_process_start(lambda *_: ...)\n    loop = asyncio.get_event_loop()\n    with caplog.at_level(logging.INFO):\n        asyncio_srv_coro = app.create_server(\n            return_asyncio_server=True, port=port\n        )\n        loop.run_until_complete(asyncio_srv_coro)\n    assert (\n        \"sanic.root\",\n        30,\n        \"Listener events for the main process are not available with \"\n        \"create_server()\",\n    ) in caplog.record_tuples",
          "docstring": null,
          "decorators": [
            "pytest.mark.asyncio"
          ],
          "arguments": [
            "app",
            "caplog",
            "port"
          ],
          "imports": [
            "asyncio",
            "logging",
            "re",
            "collections.Counter",
            "inspect.isawaitable",
            "os.environ",
            "unittest.mock.Mock",
            "unittest.mock.patch",
            "pytest",
            "sanic",
            "sanic.Sanic",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.config.Config",
            "sanic.exceptions.SanicException",
            "sanic.helpers.Default",
            "sanic.log.LOGGING_CONFIG_DEFAULTS",
            "sanic.response.text",
            "sanic.router.Route",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert ('sanic.root', 30, 'Listener events for the main process are not available with create_server()') in caplog.record_tuples"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.main_process_start",
              "body": "@app.listener('main_process_start')\ndef main_process_start(app, loop):\n    logger.info('main_process_start')",
              "method_explanation": "**Main Purpose of the Method**:\nThe `main_process_start` method is a listener that is triggered when the main process of a Sanic application starts. It allows developers to execute specific code or log messages at the beginning of the main process lifecycle.\n\n**How It Works**:\nThe method is decorated with `@app.listener('main_process_start')`, which registers it as a listener for the `main_process_start` event. When the main process starts, this listener is invoked, and it logs the message \"main_process_start\" using the configured logger. This is useful for initializing resources or logging the startup sequence of the application. The method receives two parameters: `app`, which is the Sanic application instance, and `loop`, which is the event loop being used."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_off",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 43,
        "end_line_number": 56,
        "source_code": "def test_lifespan_off():\n    async def app(scope, receive, send):\n        pass  # pragma: no cover\n\n    async def test():\n        config = Config(app=app, lifespan=\"off\")\n        lifespan = LifespanOff(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It asserts that the object is not already closed before changing its state.\n\n**How It Works**:\nThe method first checks if the `closed` attribute is `False` using an assertion. If the assertion passes, it sets the `closed` attribute to `True`, indicating that the object is now closed. This prevents any subsequent operations that may rely on the object being open, helping to manage resource cleanup and state transitions effectively."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_files",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 1396,
          "end_line_number": 1402,
          "source_code": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "client"
          ],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.status_code == 200",
            "assert rv.data.strip() == b'<h1>Hello World!</h1>'",
            "assert flask.url_for('static', filename='index.html') == '/static/index.html'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform additional operations beyond this append action."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_auto",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 59,
        "end_line_number": 89,
        "source_code": "def test_lifespan_auto():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert message['type'] == 'lifespan.startup'",
          "assert message['type'] == 'lifespan.shutdown'",
          "assert not startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert shutdown_complete"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It helps manage the lifecycle of the object, preventing actions that should not occur after closure.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, indicating that the object is now closed. This mechanism is typically used in asynchronous programming to safely manage resources and prevent errors related to operations on closed objects."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to track method invocations in a testing or debugging context."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_auto",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 59,
        "end_line_number": 89,
        "source_code": "def test_lifespan_auto():\n    startup_complete = False\n    shutdown_complete = False\n\n    async def app(scope, receive, send):\n        nonlocal startup_complete, shutdown_complete\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        startup_complete = True\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        shutdown_complete = True\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        assert not startup_complete\n        assert not shutdown_complete\n        await lifespan.startup()\n        assert startup_complete\n        assert not shutdown_complete\n        await lifespan.shutdown()\n        assert startup_complete\n        assert shutdown_complete\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert message['type'] == 'lifespan.startup'",
          "assert message['type'] == 'lifespan.shutdown'",
          "assert not startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert not shutdown_complete",
          "assert startup_complete",
          "assert shutdown_complete"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "lifespan.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of an application, ensuring that all necessary cleanup tasks are performed before the application exits. It logs the shutdown process and manages the state of the application during this phase.\n\n**How It Works**:  \nWhen invoked, the method first checks if any errors occurred during the application's operation. If errors are present, it exits early without proceeding with the shutdown. If no errors are detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a receive queue, signaling that the shutdown process has started. The method waits for a shutdown event to be set, which indicates that the shutdown process is complete. Finally, it checks if the shutdown was successful or if any errors occurred during this phase, logging the appropriate messages and setting the `should_exit` flag if necessary."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_terminate",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 41,
          "end_line_number": 48,
          "source_code": "def test_terminate(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.terminate()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.terminate",
              "body": "def terminate(proc):\n    if flags:\n        proc.send_signal(CTRL_BREAK_EVENT)\n    else:\n        proc.terminate()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `terminate` method is designed to stop a process gracefully or forcefully, depending on the state of the process and the flags set. It ensures that the process is properly terminated and updates its state accordingly.\n\n**How It Works**:  \nThe method first checks if the process's current state is not `TERMINATED`. If the process is still active, it logs a debug message indicating that the process is being terminated. It then sets the process state to `TERMINATED` and attempts to send a `SIGINT` signal to the process using `os.kill`. If the process is not found or an error occurs during this operation, it handles exceptions gracefully without crashing. This method is typically used in scenarios where a process needs to be stopped, such as during application shutdown or when managing worker processes."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_auto_with_error",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 92,
        "end_line_number": 107,
        "source_code": "def test_lifespan_auto_with_error():\n    async def app(scope, receive, send):\n        assert scope[\"type\"] == \"http\"\n\n    async def test():\n        config = Config(app=app, lifespan=\"auto\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert scope['type'] == 'http'",
          "assert lifespan.error_occured",
          "assert not lifespan.should_exit"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, effectively closing the object. This mechanism helps prevent any operations on the object after it has been closed, which can be crucial for resource management and avoiding errors in asynchronous programming contexts."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_route_with_host_matching",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 1461,
          "end_line_number": 1479,
          "source_code": "def test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.status_code == 200",
            "assert rv == 'http://example.com/static/index.html'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions beyond this simple operation."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_on_with_error",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 110,
        "end_line_number": 126,
        "source_code": "def test_lifespan_on_with_error():\n    async def app(scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert lifespan.error_occured",
          "assert lifespan.should_exit"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It asserts that the object is not already closed before changing its state.\n\n**How It Works**:\nWhen the `close` method is called, it first checks if the `closed` attribute is `False` using an assertion. If the assertion passes, it sets the `closed` attribute to `True`, indicating that the object is now closed. This prevents any subsequent operations that may rely on the object being open, thereby helping to manage resource cleanup and state integrity."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that it is part of a mechanism to track when the method is invoked, possibly indicating that a resource (like a database connection or file) has been closed.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple logging or tracking mechanism to indicate that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation focused on signaling the closure of a resource."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_send_from_directory",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 92,
          "end_line_number": 99,
          "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.data.strip() == b'Hello Subdomain'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred, especially in contexts where resource management is critical, such as database connections or file handlers."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_files",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 1396,
          "end_line_number": 1402,
          "source_code": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "client"
          ],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.status_code == 200",
            "assert rv.data.strip() == b'<h1>Hello World!</h1>'",
            "assert flask.url_for('static', filename='index.html') == '/static/index.html'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform additional operations beyond this append action."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_on_with_error",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 110,
        "end_line_number": 126,
        "source_code": "def test_lifespan_on_with_error():\n    async def app(scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.error_occured\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert lifespan.error_occured",
          "assert lifespan.should_exit"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "lifespan.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the graceful shutdown of an application. It ensures that the application can clean up resources and complete any ongoing tasks before exiting.\n\n**How It Works**:  \nWhen invoked, the method first checks if any errors have occurred during the application's operation. If there are no errors, it logs a message indicating that the shutdown process is starting. It then creates a shutdown event message and places it in a receive queue for processing. The method waits for a shutdown event to be set, which indicates that the shutdown process has been completed. If the shutdown fails or if there were errors during the application's lifecycle, it logs an error message and sets a flag to indicate that the application should exit. If the shutdown completes successfully, it logs a confirmation message."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_with_failed_startup",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 131,
        "end_line_number": 157,
        "source_code": "def test_lifespan_with_failed_startup(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.failed\", \"message\": \"the lifespan event failed\"})\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.startup_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application startup failed. Exiting.\" in error_messages.pop(0)",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('mode', ('auto', 'on'))",
          "pytest.mark.parametrize('raise_exception', (True, False))"
        ],
        "arguments": [
          "mode",
          "raise_exception",
          "caplog"
        ],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert 'the lifespan event failed' in error_messages.pop(0)",
          "assert 'Application startup failed. Exiting.' in error_messages.pop(0)",
          "assert message['type'] == 'lifespan.startup'",
          "assert lifespan.startup_failed",
          "assert lifespan.error_occured is raise_exception",
          "assert lifespan.should_exit"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_with_failed_startup",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 131,
        "end_line_number": 157,
        "source_code": "def test_lifespan_with_failed_startup(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.failed\", \"message\": \"the lifespan event failed\"})\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.startup_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application startup failed. Exiting.\" in error_messages.pop(0)",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('mode', ('auto', 'on'))",
          "pytest.mark.parametrize('raise_exception', (True, False))"
        ],
        "arguments": [
          "mode",
          "raise_exception",
          "caplog"
        ],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert 'the lifespan event failed' in error_messages.pop(0)",
          "assert 'Application startup failed. Exiting.' in error_messages.pop(0)",
          "assert message['type'] == 'lifespan.startup'",
          "assert lifespan.startup_failed",
          "assert lifespan.error_occured is raise_exception",
          "assert lifespan.should_exit"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "lifespan.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of an application, ensuring that all necessary cleanup tasks are performed before the application exits. It logs the shutdown process and manages the state of the application during this phase.\n\n**How It Works**:  \nWhen invoked, the method first checks if any errors occurred during the application's operation. If errors are present, it exits early without proceeding with the shutdown. If no errors are detected, it logs a message indicating that the application is waiting for shutdown. It then creates a shutdown event message and places it in a queue for processing. The method waits for a signal that the shutdown process is complete. After the shutdown event is processed, it checks for any shutdown failures and logs an appropriate message, updating the application's exit state accordingly."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_bad_request_response",
          "module": "test_bad_request",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_bad_request.py",
          "line_number": 6,
          "end_line_number": 26,
          "source_code": "def test_bad_request_response(app: Sanic):\n    lines = []\n\n    app.get(\"/\")(lambda x: ...)\n\n    @app.listener(\"after_server_start\")\n    async def _request(sanic, loop):\n        nonlocal lines\n        connect = asyncio.open_connection(\"127.0.0.1\", 42101)\n        reader, writer = await connect\n        writer.write(b\"not http\\r\\n\\r\\n\")\n        while True:\n            line = await reader.readline()\n            if not line:\n                break\n            lines.append(line)\n        app.stop()\n\n    app.run(host=\"127.0.0.1\", port=42101, debug=False, single_process=True)\n    assert lines[0] == b\"HTTP/1.1 400 Bad Request\\r\\n\"\n    assert b\"Bad Request\" in lines[-2]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "sanic.Sanic"
          ],
          "fixtures": [],
          "assertions": [
            "assert lines[0] == b'HTTP/1.1 400 Bad Request\\r\\n'",
            "assert b'Bad Request' in lines[-2]"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.stop",
              "body": "def stop(app):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `app.stop` method is designed to gracefully stop a running application, ensuring that any ongoing tasks or processes are properly terminated.\n\n**How It Works**:\nThe method calls `app.stop()`, which likely triggers the application's shutdown sequence. This may involve executing shutdown tasks, canceling ongoing requests, and cleaning up resources. The relevant code snippets suggest that the application manages tasks and processes, allowing for controlled termination and ensuring that the application state is updated accordingly. This method is essential for maintaining application stability and resource management during shutdown."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_scope_asgi3app",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 160,
        "end_line_number": 180,
        "source_code": "def test_lifespan_scope_asgi3app():\n    async def asgi3app(scope, receive, send):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"3.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n    async def test():\n        config = Config(app=asgi3app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        assert not lifespan.error_occured\n        assert not lifespan.should_exit\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert scope == {'type': 'lifespan', 'asgi': {'version': '3.0', 'spec_version': '2.0'}, 'state': {}}",
          "assert not lifespan.startup_failed",
          "assert not lifespan.error_occured",
          "assert not lifespan.should_exit"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_scope_asgi2app",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 183,
        "end_line_number": 205,
        "source_code": "def test_lifespan_scope_asgi2app():\n    def asgi2app(scope):\n        assert scope == {\n            \"type\": \"lifespan\",\n            \"asgi\": {\"version\": \"2.0\", \"spec_version\": \"2.0\"},\n            \"state\": {},\n        }\n\n        async def asgi(receive, send):\n            pass\n\n        return asgi\n\n    async def test():\n        config = Config(app=asgi2app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert scope == {'type': 'lifespan', 'asgi': {'version': '2.0', 'spec_version': '2.0'}, 'state': {}}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:  \nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents accidental operations on an already closed object, helping to maintain the integrity of the object's state throughout its lifecycle."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_with_failed_shutdown",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 210,
        "end_line_number": 241,
        "source_code": "def test_lifespan_with_failed_shutdown(mode, raise_exception, caplog):\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.failed\", \"message\": \"the lifespan event failed\"})\n\n        if raise_exception:\n            # App should be able to re-raise an exception if startup failed.\n            raise RuntimeError()\n\n    async def test():\n        config = Config(app=app, lifespan=mode)\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert not lifespan.startup_failed\n        await lifespan.shutdown()\n        assert lifespan.shutdown_failed\n        assert lifespan.error_occured is raise_exception\n        assert lifespan.should_exit\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    error_messages = [\n        record.message for record in caplog.records if record.name == \"uvicorn.error\" and record.levelname == \"ERROR\"\n    ]\n    assert \"the lifespan event failed\" in error_messages.pop(0)\n    assert \"Application shutdown failed. Exiting.\" in error_messages.pop(0)\n    loop.close()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('mode', ('auto', 'on'))",
          "pytest.mark.parametrize('raise_exception', (True, False))"
        ],
        "arguments": [
          "mode",
          "raise_exception",
          "caplog"
        ],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert 'the lifespan event failed' in error_messages.pop(0)",
          "assert 'Application shutdown failed. Exiting.' in error_messages.pop(0)",
          "assert message['type'] == 'lifespan.startup'",
          "assert message['type'] == 'lifespan.shutdown'",
          "assert not lifespan.startup_failed",
          "assert lifespan.shutdown_failed",
          "assert lifespan.error_occured is raise_exception",
          "assert lifespan.should_exit"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:  \nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`. This mechanism prevents the object from being closed multiple times, which could lead to inconsistent states or errors in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, focusing solely on this tracking functionality."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_lifespan_state",
        "module": "test_lifespan",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_lifespan.py",
        "line_number": 244,
        "end_line_number": 264,
        "source_code": "def test_lifespan_state():\n    async def app(scope, receive, send):\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.startup\"\n        await send({\"type\": \"lifespan.startup.complete\"})\n        scope[\"state\"][\"foo\"] = 123\n        message = await receive()\n        assert message[\"type\"] == \"lifespan.shutdown\"\n        await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def test():\n        config = Config(app=app, lifespan=\"on\")\n        lifespan = LifespanOn(config)\n\n        await lifespan.startup()\n        assert lifespan.state == {\"foo\": 123}\n        await lifespan.shutdown()\n\n    loop = asyncio.new_event_loop()\n    loop.run_until_complete(test())\n    loop.close()",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "asyncio",
          "pytest",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn"
        ],
        "fixtures": [],
        "assertions": [
          "assert message['type'] == 'lifespan.startup'",
          "assert message['type'] == 'lifespan.shutdown'",
          "assert lifespan.state == {'foo': 123}"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "loop.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to mark an object as closed, ensuring that no further operations can be performed on it. It sets the `closed` attribute to `True`, indicating that the object is no longer active.\n\n**How It Works**:\nThe method first asserts that the object is not already closed by checking the `self.closed` attribute. If the assertion passes, it sets `self.closed` to `True`, effectively preventing any further actions that would require the object to be open. This is a common pattern in resource management to ensure that resources are properly released and not used after they have been closed."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:\nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This can be used for tracking whether the method has been executed, which is useful in testing or debugging scenarios. The method does not return any value or perform any additional operations, making it a straightforward way to signal that a closure action has taken place."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, indicating that the method has been invoked.\n\n**How It Works**:  \nWhen the `close` method is called, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This serves as a simple mechanism to track that the `close` method was executed. The method does not return any value or perform any additional actions, making it a straightforward way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed or released. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify its execution in tests or other parts of the code. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to signal that a closing operation has occurred."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_send_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 34,
          "end_line_number": 43,
          "source_code": "def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.direct_passthrough",
            "assert rv.mimetype == 'text/html'",
            "assert rv.data == f.read()"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions beyond this simple logging mechanism."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_env_variables",
        "module": "test_cli",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
        "line_number": 155,
        "end_line_number": 161,
        "source_code": "def test_env_variables(http_protocol: str):\n    with load_env_var(\"UVICORN_HTTP\", http_protocol):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == http_protocol",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('http_protocol', ['h11', 'httptools'])"
        ],
        "arguments": [
          "http_protocol"
        ],
        "imports": [
          "contextlib",
          "importlib",
          "os",
          "platform",
          "sys",
          "pathlib.Path",
          "textwrap.dedent",
          "typing.Iterator",
          "unittest.mock",
          "pytest",
          "click.testing.CliRunner",
          "uvicorn",
          "uvicorn.config.Config",
          "uvicorn.main.main",
          "uvicorn.server.Server",
          "uvicorn.supervisors.ChangeReload",
          "uvicorn.supervisors.Multiprocess"
        ],
        "fixtures": [],
        "assertions": [
          "assert kwargs['http'] == http_protocol"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "load_env_var",
            "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `load_env_var` method is a context manager that temporarily sets an environment variable to a specified value for the duration of a block of code. After the block is executed, it restores the original environment variables.\n\n**How It Works**:  \n1. It first creates a copy of the current environment variables using `os.environ`.\n2. It sets the specified environment variable (`key`) to the provided `value`.\n3. The `yield` statement allows the code block within the `with` statement to execute.\n4. After the block completes, it clears the current environment variables and restores them from the saved copy, ensuring that any changes made during the block do not persist. \n\nThis method is useful for testing or temporarily altering the environment without affecting the global state."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root2",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 270,
          "end_line_number": 287,
          "source_code": "def test_call_with_vh_root2(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/foo')\n        baz = DummyContext(None, 'baz')\n        bar = DummyContext(baz, 'bar')\n        foo = DummyContext(bar, 'foo')\n        root = DummyContext(foo, 'root')\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/bar/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], foo)\n        self.assertEqual(result['virtual_root_path'], (text_('foo'),))",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This allows for the dynamic construction of an environment configuration based on the provided parameters.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the contents of `kw`, effectively merging the keyword arguments into `environ`. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up environment variables or configurations in a flexible manner."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root3",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 289,
          "end_line_number": 306,
          "source_code": "def test_call_with_vh_root3(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/')\n        baz = DummyContext()\n        bar = DummyContext(baz)\n        foo = DummyContext(bar)\n        root = DummyContext(foo)\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/foo/bar/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This allows for the dynamic construction of an environment configuration based on the provided parameters.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the contents of `kw`, effectively merging the keyword arguments into `environ`. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up environment variables or configurations in a flexible manner, allowing users to specify only the necessary parameters."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_pathinfo_KeyError",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 148,
          "end_line_number": 159,
          "source_code": "def test_call_with_pathinfo_KeyError(self):\n        policy = self._makeOne(None)\n        environ = self._getEnviron()\n        request = DummyRequest(environ, toraise=KeyError)\n        result = policy(request)\n        self.assertEqual(result['context'], None)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(result['traversed'], ())\n        self.assertEqual(result['root'], policy.root)\n        self.assertEqual(result['virtual_root'], policy.root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary that represents the environment, allowing additional keyword arguments to be included in this environment.\n\n**How It Works**:\nThe method takes any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments, effectively merging them into the `environ` dictionary. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up or modifying the environment context in which an application operates."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_pathinfo_KeyError",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 148,
          "end_line_number": 159,
          "source_code": "def test_call_with_pathinfo_KeyError(self):\n        policy = self._makeOne(None)\n        environ = self._getEnviron()\n        request = DummyRequest(environ, toraise=KeyError)\n        result = policy(request)\n        self.assertEqual(result['context'], None)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(result['traversed'], ())\n        self.assertEqual(result['root'], policy.root)\n        self.assertEqual(result['virtual_root'], policy.root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary that represents the environment, allowing additional keyword arguments to be included in this environment.\n\n**How It Works**:\nThe method takes any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments, effectively merging them into the `environ` dictionary. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up or modifying the environment context in which an application operates."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_withconn_getitem_withpath_withsubpath",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 219,
          "end_line_number": 232,
          "source_code": "def test_call_withconn_getitem_withpath_withsubpath(self):\n        foo = DummyContext()\n        root = DummyContext(foo)\n        policy = self._makeOne(root)\n        environ = self._getEnviron()\n        request = DummyRequest(environ, path_info=text_('/foo/bar/baz/buz'))\n        result = policy(request)\n        self.assertEqual(result['context'], foo)\n        self.assertEqual(result['view_name'], 'bar')\n        self.assertEqual(result['subpath'], ('baz', 'buz'))\n        self.assertEqual(result['traversed'], (text_('foo'),))\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary that represents the environment, allowing additional keyword arguments to be included in this environment.\n\n**How It Works**:\nThe method takes any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments, effectively merging them into the `environ` dictionary. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up a context or configuration that requires dynamic values passed at runtime."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_ignore_environment_variable_when_set_on_cli",
        "module": "test_cli",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
        "line_number": 164,
        "end_line_number": 170,
        "source_code": "def test_ignore_environment_variable_when_set_on_cli():\n    with load_env_var(\"UVICORN_HTTP\", \"h11\"):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            runner.invoke(cli, [\"tests.test_cli:App\", \"--http=httptools\"])\n            _, kwargs = mock_run.call_args\n            assert kwargs[\"http\"] == \"httptools\"",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "contextlib",
          "importlib",
          "os",
          "platform",
          "sys",
          "pathlib.Path",
          "textwrap.dedent",
          "typing.Iterator",
          "unittest.mock",
          "pytest",
          "click.testing.CliRunner",
          "uvicorn",
          "uvicorn.config.Config",
          "uvicorn.main.main",
          "uvicorn.server.Server",
          "uvicorn.supervisors.ChangeReload",
          "uvicorn.supervisors.Multiprocess"
        ],
        "fixtures": [],
        "assertions": [
          "assert kwargs['http'] == 'httptools'"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "load_env_var",
            "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `load_env_var` method is a context manager that temporarily sets an environment variable to a specified value for the duration of a block of code. After the block is executed, it restores the original environment variables.\n\n**How It Works**:  \n1. It first creates a copy of the current environment variables using `os.environ`.\n2. It sets the specified environment variable (`key`) to the provided `value`.\n3. The `yield` statement allows the code block within the `with` statement to execute.\n4. After the block completes, it clears the current environment variables and restores them from the saved copy, ensuring that the temporary change does not affect subsequent code. \n\nThis method is useful for testing or scenarios where you need to modify environment variables without permanently altering the system's environment."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root2",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 270,
          "end_line_number": 287,
          "source_code": "def test_call_with_vh_root2(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/foo')\n        baz = DummyContext(None, 'baz')\n        bar = DummyContext(baz, 'bar')\n        foo = DummyContext(bar, 'foo')\n        root = DummyContext(foo, 'root')\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/bar/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], foo)\n        self.assertEqual(result['virtual_root_path'], (text_('foo'),))",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This allows for the dynamic construction of an environment configuration based on the provided parameters.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the contents of `kw`, effectively merging the keyword arguments into `environ`. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up environment variables or configurations in a flexible manner."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root3",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 289,
          "end_line_number": 306,
          "source_code": "def test_call_with_vh_root3(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/')\n        baz = DummyContext()\n        bar = DummyContext(baz)\n        foo = DummyContext(bar)\n        root = DummyContext(foo)\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/foo/bar/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This allows for the dynamic construction of an environment configuration based on the provided parameters.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the contents of `kw`, effectively merging the keyword arguments into `environ`. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up environment variables or configurations in a flexible manner, allowing users to specify only the necessary parameters."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_pathinfo_KeyError",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 148,
          "end_line_number": 159,
          "source_code": "def test_call_with_pathinfo_KeyError(self):\n        policy = self._makeOne(None)\n        environ = self._getEnviron()\n        request = DummyRequest(environ, toraise=KeyError)\n        result = policy(request)\n        self.assertEqual(result['context'], None)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(result['traversed'], ())\n        self.assertEqual(result['root'], policy.root)\n        self.assertEqual(result['virtual_root'], policy.root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary that represents the environment, allowing additional keyword arguments to be included in this environment.\n\n**How It Works**:\nThe method takes any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments, effectively merging them into the `environ` dictionary. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up or modifying the environment context in which an application operates."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_pathinfo_KeyError",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 148,
          "end_line_number": 159,
          "source_code": "def test_call_with_pathinfo_KeyError(self):\n        policy = self._makeOne(None)\n        environ = self._getEnviron()\n        request = DummyRequest(environ, toraise=KeyError)\n        result = policy(request)\n        self.assertEqual(result['context'], None)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(result['traversed'], ())\n        self.assertEqual(result['root'], policy.root)\n        self.assertEqual(result['virtual_root'], policy.root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary that represents the environment, allowing additional keyword arguments to be included in this environment.\n\n**How It Works**:\nThe method takes any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments, effectively merging them into the `environ` dictionary. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up or modifying the environment context in which an application operates."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 249,
          "end_line_number": 268,
          "source_code": "def test_call_with_vh_root(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/foo/bar')\n        baz = DummyContext(None, 'baz')\n        bar = DummyContext(baz, 'bar')\n        foo = DummyContext(bar, 'foo')\n        root = DummyContext(foo, 'root')\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], bar)\n        self.assertEqual(\n            result['virtual_root_path'], (text_('foo'), text_('bar'))\n        )",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This is useful for setting up an environment configuration in a flexible manner.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments using the `update` method, which adds the key-value pairs from `kw` to `environ`. Finally, it returns the updated `environ` dictionary. This allows for dynamic construction of environment settings based on the input parameters."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_set_app_via_environment_variable",
        "module": "test_cli",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/test_cli.py",
        "line_number": 195,
        "end_line_number": 203,
        "source_code": "def test_set_app_via_environment_variable():\n    app_path = \"tests.test_cli:App\"\n    with load_env_var(\"UVICORN_APP\", app_path):\n        runner = CliRunner(env=os.environ)\n        with mock.patch.object(main, \"run\") as mock_run:\n            result = runner.invoke(cli)\n            args, _ = mock_run.call_args\n            assert result.exit_code == 0\n            assert args == (app_path,)",
        "docstring": null,
        "decorators": [],
        "arguments": [],
        "imports": [
          "contextlib",
          "importlib",
          "os",
          "platform",
          "sys",
          "pathlib.Path",
          "textwrap.dedent",
          "typing.Iterator",
          "unittest.mock",
          "pytest",
          "click.testing.CliRunner",
          "uvicorn",
          "uvicorn.config.Config",
          "uvicorn.main.main",
          "uvicorn.server.Server",
          "uvicorn.supervisors.ChangeReload",
          "uvicorn.supervisors.Multiprocess"
        ],
        "fixtures": [],
        "assertions": [
          "assert result.exit_code == 0",
          "assert args == (app_path,)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "load_env_var",
            "body": "@contextlib.contextmanager\ndef load_env_var(key: str, value: str) -> Iterator[None]:\n    old_environ = dict(os.environ)\n    os.environ[key] = value\n    yield\n    os.environ.clear()\n    os.environ.update(old_environ)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `load_env_var` method is a context manager that temporarily sets an environment variable to a specified value for the duration of a block of code. After the block is executed, it restores the original environment variables.\n\n**How It Works**:  \n1. It first creates a copy of the current environment variables using `os.environ`.\n2. It sets the specified environment variable (`key`) to the provided `value`.\n3. The `yield` statement allows the code block within the `with` statement to execute.\n4. After the block completes, it clears the current environment variables and restores them from the saved copy, ensuring that the environment remains unchanged outside the context. \n\nThis method is useful for testing or temporarily modifying environment settings without affecting the global state."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root2",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 270,
          "end_line_number": 287,
          "source_code": "def test_call_with_vh_root2(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/foo')\n        baz = DummyContext(None, 'baz')\n        bar = DummyContext(baz, 'bar')\n        foo = DummyContext(bar, 'foo')\n        root = DummyContext(foo, 'root')\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/bar/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], foo)\n        self.assertEqual(result['virtual_root_path'], (text_('foo'),))",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This allows for the dynamic construction of an environment configuration based on the provided parameters.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the contents of `kw`, effectively merging the keyword arguments into `environ`. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up environment variables or configurations in a flexible manner."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root3",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 289,
          "end_line_number": 306,
          "source_code": "def test_call_with_vh_root3(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/')\n        baz = DummyContext()\n        bar = DummyContext(baz)\n        foo = DummyContext(bar)\n        root = DummyContext(foo)\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/foo/bar/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This allows for the dynamic construction of an environment configuration based on the provided parameters.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the contents of `kw`, effectively merging the keyword arguments into `environ`. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up environment variables or configurations in a flexible manner, allowing users to specify only the necessary parameters."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_pathinfo_KeyError",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 148,
          "end_line_number": 159,
          "source_code": "def test_call_with_pathinfo_KeyError(self):\n        policy = self._makeOne(None)\n        environ = self._getEnviron()\n        request = DummyRequest(environ, toraise=KeyError)\n        result = policy(request)\n        self.assertEqual(result['context'], None)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(result['traversed'], ())\n        self.assertEqual(result['root'], policy.root)\n        self.assertEqual(result['virtual_root'], policy.root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary that represents the environment, allowing additional keyword arguments to be included in this environment.\n\n**How It Works**:\nThe method takes any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments, effectively merging them into the `environ` dictionary. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up or modifying the environment context in which an application operates."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_pathinfo_KeyError",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 148,
          "end_line_number": 159,
          "source_code": "def test_call_with_pathinfo_KeyError(self):\n        policy = self._makeOne(None)\n        environ = self._getEnviron()\n        request = DummyRequest(environ, toraise=KeyError)\n        result = policy(request)\n        self.assertEqual(result['context'], None)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(result['traversed'], ())\n        self.assertEqual(result['root'], policy.root)\n        self.assertEqual(result['virtual_root'], policy.root)\n        self.assertEqual(result['virtual_root_path'], ())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary that represents the environment, allowing additional keyword arguments to be included in this environment.\n\n**How It Works**:\nThe method takes any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments, effectively merging them into the `environ` dictionary. Finally, it returns the updated `environ` dictionary. This method can be useful for setting up or modifying the environment context in which an application operates."
            }
          ]
        },
        {
          "repo_name": "pyramid",
          "name": "test_call_with_vh_root",
          "module": "test_traversal",
          "class_name": "ResourceTreeTraverserTests",
          "file_path": "__internal__/data/pyramid/tests/test_traversal.py",
          "line_number": 249,
          "end_line_number": 268,
          "source_code": "def test_call_with_vh_root(self):\n        environ = self._getEnviron(HTTP_X_VHM_ROOT='/foo/bar')\n        baz = DummyContext(None, 'baz')\n        bar = DummyContext(baz, 'bar')\n        foo = DummyContext(bar, 'foo')\n        root = DummyContext(foo, 'root')\n        policy = self._makeOne(root)\n        request = DummyRequest(environ, path_info=text_('/baz'))\n        result = policy(request)\n        self.assertEqual(result['context'], baz)\n        self.assertEqual(result['view_name'], '')\n        self.assertEqual(result['subpath'], ())\n        self.assertEqual(\n            result['traversed'], (text_('foo'), text_('bar'), text_('baz'))\n        )\n        self.assertEqual(result['root'], root)\n        self.assertEqual(result['virtual_root'], bar)\n        self.assertEqual(\n            result['virtual_root_path'], (text_('foo'), text_('bar'))\n        )",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self"
          ],
          "imports": [
            "unittest",
            "urllib.parse.quote",
            "pyramid.testing.cleanUp",
            "pyramid.util.text_",
            "pyramid.registry.Registry",
            "pyramid.traversal.traversal_path",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.traversal_path_info",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.ResourceTreeTraverser",
            "zope.interface.verify.verifyClass",
            "pyramid.interfaces.ITraverser",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.ITraverser",
            "pyramid.exceptions.URLDecodeError",
            "pyramid.traversal.find_interface",
            "zope.interface.Interface",
            "zope.interface.directlyProvides",
            "pyramid.traversal.find_root",
            "pyramid.traversal.find_resource",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.traversal.ResourceTreeTraverser",
            "pyramid.traversal.resource_path",
            "pyramid.traversal.resource_path_tuple",
            "pyramid.traversal.quote_path_segment",
            "pyramid.traversal.ResourceURL",
            "zope.interface.verify.verifyObject",
            "pyramid.interfaces.IResourceURL",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.virtual_root",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.interfaces.VH_ROOT_KEY",
            "pyramid.traversal.traverse",
            "pyramid.threadlocal.get_current_registry",
            "zope.interface.Interface",
            "pyramid.interfaces.ITraverser",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.interfaces.IRequestFactory",
            "pyramid.request.Request",
            "pyramid.threadlocal.get_current_registry",
            "pyramid.traversal.DefaultRootFactory",
            "pyramid.traversal._join_path_tuple"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "self._getEnviron",
              "body": "def _getEnviron(self, **kw):\n    environ = {}\n    environ.update(kw)\n    return environ",
              "method_explanation": "**Main Purpose of the Method**:\nThe `_getEnviron` method is designed to create and return a dictionary (`environ`) that combines any keyword arguments passed to it. This is useful for setting up an environment configuration in a flexible manner.\n\n**How It Works**:\nThe method accepts any number of keyword arguments (`**kw`) and initializes an empty dictionary called `environ`. It then updates this dictionary with the provided keyword arguments using the `update` method, which adds the key-value pairs from `kw` to `environ`. Finally, it returns the updated `environ` dictionary. This allows for dynamic construction of environment settings based on the input parameters."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reloader_should_initialize",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 77,
        "end_line_number": 87,
        "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
        "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the codebase.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_python_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 90,
        "end_line_number": 100,
        "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert changes == [file]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_python_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 90,
        "end_line_number": 100,
        "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert changes == [file]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_python_file_in_subdir_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 103,
        "end_line_number": 112,
        "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_python_file_in_subdir_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 103,
        "end_line_number": 112,
        "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_python_file_in_subdir_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 103,
        "end_line_number": 112,
        "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or shut down.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string 'shutdown' to a list called `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for any necessary cleanup operations, such as closing sockets or stopping background tasks, to be performed. In the context of the provided code snippets, it is part of a larger reloader class that manages application restarts and shutdowns based on specific conditions."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_del_with_closed_loop",
          "module": "test_connector",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_connector.py",
          "line_number": 254,
          "end_line_number": 275,
          "source_code": "def test_del_with_closed_loop(\n    loop: asyncio.AbstractEventLoop, key: ConnectionKey\n) -> None:\n    async def make_conn() -> aiohttp.BaseConnector:\n        return aiohttp.BaseConnector()\n\n    conn = loop.run_until_complete(make_conn())\n    transp = create_mocked_conn(loop)\n    conn._conns[key] = deque([(transp, 123)])\n\n    conns_impl = conn._conns\n    exc_handler = mock.Mock()\n    loop.set_exception_handler(exc_handler)\n    loop.close()\n\n    with pytest.warns(ResourceWarning):\n        del conn\n        gc.collect()\n\n    assert not conns_impl\n    assert not transp.close.called\n    assert exc_handler.called",
          "docstring": null,
          "decorators": [
            "pytest.mark.skipif(sys.implementation.name != 'cpython', reason='CPython GC is required for the test')"
          ],
          "arguments": [
            "loop",
            "key"
          ],
          "imports": [
            "asyncio",
            "gc",
            "hashlib",
            "platform",
            "socket",
            "ssl",
            "sys",
            "uuid",
            "collections.defaultdict",
            "collections.deque",
            "concurrent.futures",
            "contextlib.closing",
            "contextlib.suppress",
            "typing.Awaitable",
            "typing.Callable",
            "typing.DefaultDict",
            "typing.Deque",
            "typing.Iterator",
            "typing.List",
            "typing.Literal",
            "typing.NoReturn",
            "typing.Optional",
            "typing.Sequence",
            "typing.Tuple",
            "unittest.mock",
            "pytest",
            "aiohappyeyeballs.AddrInfoType",
            "pytest_mock.MockerFixture",
            "yarl.URL",
            "aiohttp",
            "aiohttp.ClientRequest",
            "aiohttp.ClientSession",
            "aiohttp.ClientTimeout",
            "aiohttp.connector",
            "aiohttp.web",
            "aiohttp.abc.ResolveResult",
            "aiohttp.client_proto.ResponseHandler",
            "aiohttp.client_reqrep.ConnectionKey",
            "aiohttp.connector._SSL_CONTEXT_UNVERIFIED",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.connector.Connection",
            "aiohttp.connector.TCPConnector",
            "aiohttp.connector._DNSCacheTable",
            "aiohttp.pytest_plugin.AiohttpClient",
            "aiohttp.pytest_plugin.AiohttpServer",
            "aiohttp.test_utils.make_mocked_coro",
            "aiohttp.test_utils.unused_port",
            "aiohttp.tracing.Trace"
          ],
          "fixtures": [],
          "assertions": [
            "assert not conns_impl",
            "assert not transp.close.called",
            "assert exc_handler.called"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "loop.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly shut down an event loop or a related resource, ensuring that any ongoing operations are properly terminated and resources are released.\n\n**How It Works**:\nThe method currently has an empty implementation (`pass`), indicating that it does not perform any actions when called. However, in the context of an event loop, a typical implementation would involve stopping the loop, canceling any pending tasks, and releasing associated resources. In the provided code snippets, similar `close` methods are seen that handle cleanup tasks, such as notifying callbacks, releasing protocols, and canceling resolvers, which are essential for preventing resource leaks and ensuring a graceful shutdown of asynchronous operations."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_stop",
              "body": "@app.reload_process_stop\ndef reload_process_stop(_):\n    results.append('reload_process_stop')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_stop` method is a listener decorator in the Sanic framework that allows developers to define a callback function that will be executed when the reload process of the application stops. This is useful for performing cleanup actions or logging when the application is reloaded.\n\n**How It Works**:  \nWhen the `@app.reload_process_stop` decorator is applied to a function, it registers that function as a listener for the \"reload_process_stop\" event. The function can then perform any desired actions, such as logging a message or executing specific code. The method is part of a broader event-driven architecture in Sanic, where various events can trigger specific listener functions, enhancing the application's responsiveness to state changes."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_send_from_directory",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 92,
          "end_line_number": 99,
          "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.data.strip() == b'Hello Subdomain'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred, especially in contexts where resource management is critical, such as database connections or file handlers."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_all_listeners_as_convenience",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 99,
          "end_line_number": 107,
          "source_code": "def test_all_listeners_as_convenience(app):\n    output = []\n    for listener_name in AVAILABLE_LISTENERS:\n        listener = create_listener(listener_name, output)\n        method = getattr(app, listener_name)\n        method(listener)\n    start_stop_app(app)\n    for listener_name in AVAILABLE_LISTENERS:\n        assert app.name + listener_name == output.pop()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert app.name + listener_name == output.pop()"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "start_stop_app",
              "body": "def start_stop_app(random_name_app, **run_kwargs):\n\n    @random_name_app.after_server_start\n    async def shutdown(app):\n        await asyncio.sleep(1.1)\n        app.stop()\n    try:\n        random_name_app.run(HOST, get_port(), single_process=True, **run_kwargs)\n    except KeyboardInterrupt:\n        pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `start_stop_app` method is designed to start a Sanic web application and ensure it can be gracefully shut down after a specified delay. It sets up an asynchronous shutdown procedure that stops the application after the server has started.\n\n**How It Works**:\n1. The method takes a `random_name_app` (an instance of a Sanic application) and additional keyword arguments (`run_kwargs`) for configuration.\n2. It defines an asynchronous `shutdown` function that waits for 1.1 seconds before calling `app.stop()`, which initiates the shutdown process of the application.\n3. The `shutdown` function is registered to be called after the server starts using the `after_server_start` listener.\n4. The application is then run using `random_name_app.run()`, which starts the server and listens for incoming requests. The `single_process=True` argument indicates that the server should run in a single process.\n5. If a `KeyboardInterrupt` (like pressing Ctrl+C) occurs, the method catches it and allows for a clean exit without raising an error. \n\nThis method is useful for testing or running applications where controlled startup and shutdown behavior is required."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 115,
        "end_line_number": 129,
        "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, sub_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 115,
        "end_line_number": 129,
        "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, sub_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_pattern_matched_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 132,
        "end_line_number": 141,
        "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
        ],
        "arguments": [
          "self",
          "result",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_pattern_matched_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 132,
        "end_line_number": 141,
        "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
        ],
        "arguments": [
          "self",
          "result",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that have changed, or `None` if no changes were detected. \n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates the files that have changed according to the reloader's logic. If no changes are detected, it returns `None`."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_dot_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 171,
        "end_line_number": 180,
        "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_dot_file_is_changed",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 171,
        "end_line_number": 180,
        "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function with the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_directories_have_same_prefix",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 183,
        "end_line_number": 200,
        "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_directories_have_same_prefix",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 183,
        "end_line_number": 200,
        "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_directories_have_same_prefix",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 183,
        "end_line_number": 200,
        "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their timestamps.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_directories_have_same_prefix",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 183,
        "end_line_number": 200,
        "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is typically responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of operations performed by the reloader. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple marker to indicate that a shutdown has occurred. In the context of the tests, it helps verify that the shutdown sequence is executed as expected."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_only_subdirectory_is_watched",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 210,
        "end_line_number": 225,
        "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_only_subdirectory_is_watched",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 210,
        "end_line_number": 225,
        "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their timestamps.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_only_subdirectory_is_watched",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 210,
        "end_line_number": 225,
        "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their timestamps.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader detects these changes correctly.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function with the provided files, simulating a quick modification to those files.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether any changes were detected after the files were modified. If changes are detected, it returns a list of modified paths; otherwise, it returns `None`."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function with the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle. It then touches each file to simulate a change.\n4. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no files triggered a reload, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether any changes were detected after the files were touched. If changes are detected, it returns a list of modified paths; otherwise, it returns `None`."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_watchfiles_no_changes",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 283,
        "end_line_number": 308,
        "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
        ],
        "arguments": [
          "self"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(reloader, WatchFilesReload)",
          "assert reloader.should_restart() is None"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_watchfiles_no_changes",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 283,
        "end_line_number": 308,
        "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
        ],
        "arguments": [
          "self"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(reloader, WatchFilesReload)",
          "assert reloader.should_restart() is None"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application during development. It appends a \"shutdown\" call to a list, indicating that the shutdown process has been initiated.\n\n**How It Works**:  \nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to track the sequence of lifecycle events (like startup, restart, and shutdown) that have occurred during the reloader's operation. The method does not perform any additional actions, such as closing sockets or terminating processes, but serves as a simple logging mechanism to indicate that a shutdown has been requested. This can be useful for testing and debugging purposes, as seen in the provided test cases where the order of calls is asserted."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_send_from_directory",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 92,
          "end_line_number": 99,
          "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.data.strip() == b'Hello Subdomain'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred, especially in contexts where resource management is critical, such as database connections or file handlers."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically by signaling that a resource (like a database connection or a file) should be closed. In this specific implementation, it appends the value `42` to a list named `called`, which may be used for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes the line `called.append(42)`, which adds the integer `42` to the `called` list. This indicates that the method has been called, allowing developers to verify that the cleanup process was triggered. The method does not return any value or perform any additional actions, making it a simple yet effective way to track method invocations in a testing or debugging context."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_templates_and_static",
          "module": "test_blueprints",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_blueprints.py",
          "line_number": 176,
          "end_line_number": 220,
          "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "test_apps"
          ],
          "imports": [
            "pytest",
            "jinja2.TemplateNotFound",
            "werkzeug.http.parse_cache_control_header",
            "flask",
            "blueprintapp.app",
            "blueprintapp.app",
            "werkzeug.routing.Rule"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.data == b'Hello from the Frontend'",
            "assert rv.data == b'Hello from the Admin'",
            "assert rv.data == b'Hello from the Admin'",
            "assert rv.data.strip() == b'Admin File'",
            "assert rv.data.strip() == b'/* nested file */'",
            "assert cc.max_age == expected_max_age",
            "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
            "assert e.value.name == 'missing.html'",
            "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that it is part of a mechanism to track when the method is invoked, possibly indicating that a resource (like a database connection or file) has been closed.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple logging or tracking mechanism to confirm that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation focused solely on recording its invocation."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that it is part of a mechanism to track when the method is invoked, possibly indicating that a resource (like a database connection or file) has been closed.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple logging or tracking mechanism to indicate that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation focused on signaling the closure of a resource."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_detect_new_reload_dirs",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 311,
        "end_line_number": 332,
        "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon",
          "caplog",
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)",
          "assert caplog.records[-2].levelno == logging.INFO",
          "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_detect_new_reload_dirs",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 311,
        "end_line_number": 332,
        "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon",
          "caplog",
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)",
          "assert caplog.records[-2].levelno == logging.INFO",
          "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_detect_new_reload_dirs",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 311,
        "end_line_number": 332,
        "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon",
          "caplog",
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)",
          "assert caplog.records[-2].levelno == logging.INFO",
          "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_detect_new_reload_dirs",
        "module": "test_reload",
        "class_name": "TestBaseReload",
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 311,
        "end_line_number": 332,
        "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon",
          "caplog",
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)",
          "assert caplog.records[-2].levelno == logging.INFO",
          "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing the lifecycle of an application, particularly in a development environment where code changes may require the application to restart or stop.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`, which is used to track the sequence of operations performed by the reloader. This method is typically invoked when the application needs to gracefully terminate, allowing for any necessary cleanup operations, such as closing sockets or stopping background tasks, to be executed. In the context of the provided tests, it ensures that the shutdown process is correctly logged and that the application state is updated accordingly."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_shutdown_close_idle_keepalive",
          "module": "test_run_app",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_run_app.py",
          "line_number": 1223,
          "end_line_number": 1255,
          "source_code": "def test_shutdown_close_idle_keepalive(\n        self, unused_port_socket: socket.socket\n    ) -> None:\n        sock = unused_port_socket\n        port = sock.getsockname()[1]\n        t = None\n\n        async def test() -> None:\n            await asyncio.sleep(1)\n            async with ClientSession() as sess:\n                async with sess.get(f\"http://127.0.0.1:{port}/stop\"):\n                    pass\n\n                # Hold on to keep-alive connection.\n                await asyncio.sleep(5)\n\n        async def run_test(app: web.Application) -> AsyncIterator[None]:\n            nonlocal t\n            t = asyncio.create_task(test())\n            yield\n            t.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await t\n\n        app = web.Application()\n        app.cleanup_ctx.append(run_test)\n        app.router.add_get(\"/stop\", self.stop)\n\n        web.run_app(app, sock=sock, shutdown_timeout=10)\n        # If connection closed, then test() will be cancelled in cleanup_ctx.\n        # If not, then shutdown_timeout will allow it to sleep until complete.\n        assert t is not None\n        assert t.cancelled()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "unused_port_socket"
          ],
          "imports": [
            "asyncio",
            "contextlib",
            "logging",
            "os",
            "platform",
            "signal",
            "socket",
            "ssl",
            "subprocess",
            "sys",
            "time",
            "typing.Any",
            "typing.AsyncIterator",
            "typing.Awaitable",
            "typing.Callable",
            "typing.Coroutine",
            "typing.Dict",
            "typing.Iterator",
            "typing.List",
            "typing.NoReturn",
            "typing.Optional",
            "typing.Set",
            "typing.Tuple",
            "unittest.mock",
            "uuid.uuid4",
            "pytest",
            "pytest_mock.MockerFixture",
            "aiohttp.ClientConnectorError",
            "aiohttp.ClientSession",
            "aiohttp.ClientTimeout",
            "aiohttp.WSCloseCode",
            "aiohttp.web",
            "aiohttp.log.access_logger",
            "aiohttp.test_utils.make_mocked_coro",
            "aiohttp.web_protocol.RequestHandler",
            "aiohttp.web_runner.BaseRunner",
            "contextvars.ContextVar"
          ],
          "fixtures": [],
          "assertions": [
            "assert t is not None",
            "assert t.cancelled()"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "web.run_app",
              "body": "def run_app(self, sock: socket.socket, timeout: int, task: Callable[[], Coroutine[None, None, None]], extra_test: Optional[Callable[[ClientSession], Awaitable[None]]]=None) -> Tuple['asyncio.Task[None]', int]:\n    num_connections = -1\n    t = test_task = None\n    port = sock.getsockname()[1]\n\n    class DictRecordClear(Dict[RequestHandler[web.Request], asyncio.Transport]):\n\n        def clear(self) -> None:\n            nonlocal num_connections\n            num_connections = len(self)\n            super().clear()\n\n    class ServerWithRecordClear(web.Server[web.Request]):\n\n        def __init__(self, *args: Any, **kwargs: Any):\n            super().__init__(*args, **kwargs)\n            self._connections = DictRecordClear()\n\n    async def test() -> None:\n        await asyncio.sleep(0.5)\n        async with ClientSession() as sess:\n            for _ in range(5):\n                try:\n                    with pytest.raises(asyncio.TimeoutError):\n                        async with sess.get(f'http://127.0.0.1:{port}/', timeout=ClientTimeout(total=0.1)):\n                            pass\n                except ClientConnectorError:\n                    await asyncio.sleep(0.5)\n                else:\n                    break\n            async with sess.get(f'http://127.0.0.1:{port}/stop'):\n                pass\n            if extra_test:\n                await extra_test(sess)\n\n    async def run_test(app: web.Application) -> AsyncIterator[None]:\n        nonlocal test_task\n        test_task = asyncio.create_task(test())\n        yield\n        await test_task\n\n    async def handler(request: web.Request) -> web.Response:\n        nonlocal t\n        t = asyncio.create_task(task())\n        await t\n        return web.Response(text='FOO')\n    app = web.Application()\n    app.cleanup_ctx.append(run_test)\n    app.router.add_get('/', handler)\n    app.router.add_get('/stop', self.stop)\n    with mock.patch('aiohttp.web_runner.Server', ServerWithRecordClear):\n        web.run_app(app, sock=sock, shutdown_timeout=timeout)\n    assert test_task is not None\n    assert test_task.exception() is None\n    assert t is not None\n    return (t, num_connections)",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_app` method is designed to start an asynchronous web application using a specified socket for communication. It sets up the application, handles incoming requests, and manages the lifecycle of the server, including connection tracking and shutdown procedures.\n\n**How It Works**:\n1. **Socket and Timeout**: The method takes a socket for binding and a timeout for graceful shutdown.\n2. **Connection Tracking**: It defines a custom dictionary (`DictRecordClear`) to track active connections, allowing it to count how many connections are still open when the server is shutting down.\n3. **Server Initialization**: A subclass of `web.Server` is created to use the custom connection tracking.\n4. **Request Handling**: The method defines an asynchronous request handler that executes a provided task and returns a response.\n5. **Testing**: It includes a testing coroutine that checks the server's responsiveness and handles potential timeouts.\n6. **Application Setup**: The method creates a `web.Application`, adds routes, and starts the server using the provided socket.\n7. **Assertions**: After running the application, it asserts that the test task completed successfully and returns the task and the number of connections that were active before shutdown.\n\nThis method is particularly useful for testing web applications in an asynchronous context, ensuring that they can handle requests and shutdown gracefully while monitoring connection states."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_base_reloader_run",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 383,
        "end_line_number": 411,
        "source_code": "def test_base_reloader_run(tmp_path):\n    calls = []\n    step = 0\n\n    class CustomReload(BaseReload):\n        def startup(self):\n            calls.append(\"startup\")\n\n        def restart(self):\n            calls.append(\"restart\")\n\n        def shutdown(self):\n            calls.append(\"shutdown\")\n\n        def should_restart(self):\n            nonlocal step\n            step += 1\n            if step == 1:\n                return None\n            elif step == 2:\n                return [tmp_path / \"foobar.py\"]\n            else:\n                raise StopIteration()\n\n    config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n    reloader = CustomReload(config, target=run, sockets=[])\n    reloader.run()\n\n    assert calls == [\"startup\", \"restart\", \"shutdown\"]",
        "docstring": null,
        "decorators": [],
        "arguments": [
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert calls == ['startup', 'restart', 'shutdown']"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.run",
            "body": "def run(sockets):\n    pass",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `reloader.run` method is designed to manage the execution of a server with the capability to reload its configuration or restart based on file changes, particularly in a Unix-like environment.\n\n**How It Works**:  \nThe method takes a list of socket objects as an argument, which are used for binding the server. It is typically invoked when the server is set to reload its configuration or when multiple worker processes are required. The method itself is currently a placeholder (`pass`), indicating that its implementation is yet to be defined. In the context of the surrounding code, it is likely intended to handle the logic for monitoring file changes and restarting the server as needed, ensuring that the application can adapt to changes without manual intervention."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reloader_should_initialize",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 77,
        "end_line_number": 87,
        "source_code": "def test_reloader_should_initialize(self) -> None:\n        \"\"\"\n        A basic sanity check.\n\n        Simply run the reloader against a no-op server, and signal for it to\n        quit immediately.\n        \"\"\"\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n            reloader.shutdown()",
        "docstring": "A basic sanity check.\n\nSimply run the reloader against a no-op server, and signal for it to\nquit immediately.",
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_python_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 90,
        "end_line_number": 100,
        "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert changes == [file]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_python_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 90,
        "end_line_number": 100,
        "source_code": "def test_reload_when_python_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            changes = self._reload_tester(touch_soon, reloader, file)\n            assert changes == [file]\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert changes == [file]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_python_file_in_subdir_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 103,
        "end_line_number": 112,
        "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_python_file_in_subdir_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 103,
        "end_line_number": 112,
        "source_code": "def test_should_reload_when_python_file_in_subdir_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"sub\" / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader, specifically checking if changes to specified files trigger a reload. It interacts with the reloader to restart it and simulates file changes to verify that the reloader detects these changes correctly.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the `reloader` is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function with the provided files, simulating a quick modification.\n3. If the reloader is not of that type, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether any changes were detected by the reloader after the simulated modifications. If changes are detected, it returns a list of modified paths; otherwise, it returns `None`."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 115,
        "end_line_number": 129,
        "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, sub_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_python_file_in_excluded_subdir_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 115,
        "end_line_number": 129,
        "source_code": "def test_should_not_reload_when_python_file_in_excluded_subdir_is_changed(self, touch_soon) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n        sub_file = sub_dir / \"sub.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, sub_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload, WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, sub_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_pattern_matched_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 132,
        "end_line_number": 141,
        "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
        ],
        "arguments": [
          "self",
          "result",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_reload_when_pattern_matched_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 132,
        "end_line_number": 141,
        "source_code": "def test_reload_when_pattern_matched_file_is_changed(self, result: bool, touch_soon) -> None:\n        file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"*.js\"])\n            reloader = self._setup_reloader(config)\n\n            assert bool(self._reload_tester(touch_soon, reloader, file)) == result\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class, result', [(StatReload, False), (WatchFilesReload, True)])"
        ],
        "arguments": [
          "self",
          "result",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert bool(self._reload_tester(touch_soon, reloader, file)) == result"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the codebase.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_exclude_pattern_match_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 150,
        "end_line_number": 168,
        "source_code": "def test_should_not_reload_when_exclude_pattern_match_file_is_changed(self, touch_soon) -> None:\n        python_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        css_file = self.reload_path / \"app\" / \"css\" / \"main.css\"\n        js_file = self.reload_path / \"app\" / \"js\" / \"main.js\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\"*\"],\n                reload_excludes=[\"*.js\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, python_file)\n            assert self._reload_tester(touch_soon, reloader, css_file)\n            assert not self._reload_tester(touch_soon, reloader, js_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, python_file)",
          "assert self._reload_tester(touch_soon, reloader, css_file)",
          "assert not self._reload_tester(touch_soon, reloader, js_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader detects these changes correctly.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate any detected changes in the files.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_dot_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 171,
        "end_line_number": 180,
        "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_dot_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 171,
        "end_line_number": 180,
        "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is typically responsible for restarting an application when code changes are detected. This method records a shutdown event and is part of the lifecycle management of the reloader.\n\n**How It Works**:  \nWhen the `shutdown` method is called, it appends the string `'shutdown'` to a list named `calls`. This list is used to track the sequence of lifecycle events (like startup, restart, and shutdown) that have occurred during the reloader's operation. The method does not perform any additional actions, such as closing sockets or terminating processes, but it serves as a simple logging mechanism to indicate that a shutdown has been initiated."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_send_from_directory",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 92,
          "end_line_number": 99,
          "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.data.strip() == b'Hello Subdomain'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred, especially in contexts where resource management is critical, such as database connections or file handlers."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_templates_and_static",
          "module": "test_blueprints",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_blueprints.py",
          "line_number": 176,
          "end_line_number": 220,
          "source_code": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "test_apps"
          ],
          "imports": [
            "pytest",
            "jinja2.TemplateNotFound",
            "werkzeug.http.parse_cache_control_header",
            "flask",
            "blueprintapp.app",
            "blueprintapp.app",
            "werkzeug.routing.Rule"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.data == b'Hello from the Frontend'",
            "assert rv.data == b'Hello from the Admin'",
            "assert rv.data == b'Hello from the Admin'",
            "assert rv.data.strip() == b'Admin File'",
            "assert rv.data.strip() == b'/* nested file */'",
            "assert cc.max_age == expected_max_age",
            "assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'",
            "assert e.value.name == 'missing.html'",
            "assert flask.render_template('nested/nested.txt') == \"I'm nested\""
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that it is part of a mechanism to track when the method is invoked, possibly indicating that a resource (like a database connection or file) has been closed.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple logging or tracking mechanism to confirm that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation focused solely on recording its invocation."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_url_path",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 1405,
          "end_line_number": 1413,
          "source_code": "def test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.status_code == 200",
            "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that the method is likely part of a resource management system where tracking the closure of resources is important.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple indicator that the method has been called, which can be useful for debugging or tracking the state of resource management within the application. The method does not return any value or perform any additional operations beyond this append action."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_folder_with_pathlib_path",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 1441,
          "end_line_number": 1447,
          "source_code": "def test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.status_code == 200"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple notification mechanism to signal that the `close` method has been executed. The method does not return any value or perform any additional operations, making it a straightforward implementation primarily for tracking method calls."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_dot_file_is_changed",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 171,
        "end_line_number": 180,
        "source_code": "def test_should_not_reload_when_dot_file_is_changed(self, touch_soon) -> None:\n        file = self.reload_path / \".dotted\"\n\n        with as_cwd(self.reload_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True)\n            reloader = self._setup_reloader(config)\n\n            assert not self._reload_tester(touch_soon, reloader, file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert not self._reload_tester(touch_soon, reloader, file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for a short duration (0.1 seconds) to allow for any file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_directories_have_same_prefix",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 183,
        "end_line_number": 200,
        "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_directories_have_same_prefix",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 183,
        "end_line_number": 200,
        "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_reload_when_directories_have_same_prefix",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 183,
        "end_line_number": 200,
        "source_code": "def test_should_reload_when_directories_have_same_prefix(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_file = app_dir / \"src\" / \"main.py\"\n        app_first_dir = self.reload_path / \"app_first\"\n        app_first_file = app_first_dir / \"src\" / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_dirs=[str(app_dir), str(app_first_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, app_file)\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, WatchFilesReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_only_subdirectory_is_watched",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 210,
        "end_line_number": 225,
        "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the codebase.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_only_subdirectory_is_watched",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 210,
        "end_line_number": 225,
        "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no files were changed, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_not_reload_when_only_subdirectory_is_watched",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 210,
        "end_line_number": 225,
        "source_code": "def test_should_not_reload_when_only_subdirectory_is_watched(self, touch_soon) -> None:\n        app_dir = self.reload_path / \"app\"\n        app_dir_file = self.reload_path / \"app\" / \"src\" / \"main.py\"\n        root_file = self.reload_path / \"main.py\"\n\n        config = Config(\n            app=\"tests.test_config:asgi_app\",\n            reload=True,\n            reload_dirs=[str(app_dir)],\n        )\n        reloader = self._setup_reloader(config)\n\n        assert self._reload_tester(touch_soon, reloader, app_dir_file)\n        assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / \"~ignored\")\n\n        reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [StatReload, WatchGodReload, pytest.param(WatchFilesReload, marks=skip_if_m1)])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, root_file, app_dir / '~ignored')"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to update their modification times.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates whether the reloader detected any changes after the files were touched. If no changes are detected, it returns `None`."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:\nThe `shutdown` method is designed to handle the shutdown process of a reloader, which is responsible for managing application restarts and shutdowns during development. It appends a \"shutdown\" call to a list to track the shutdown event.\n\n**How It Works**:\nWhen the `shutdown` method is invoked, it appends the string 'shutdown' to a list named `calls`. This list is used to record the sequence of events that occur during the reloader's lifecycle, allowing developers to verify that the shutdown process was executed as expected. The method is typically called when the application is terminating, ensuring that any necessary cleanup or state tracking can be performed."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_shutown",
          "module": "test_manager",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_manager.py",
          "line_number": 52,
          "end_line_number": 60,
          "source_code": "def test_shutown(os_mock: Mock):\n    process = Mock()\n    process.pid = 1234\n    process.is_alive.return_value = True\n    context = Mock()\n    context.Process.return_value = process\n    manager = WorkerManager(1, fake_serve, {}, context, (Mock(), Mock()), {})\n    manager.shutdown()\n    os_mock.kill.assert_called_once_with(1234, SIGINT)",
          "docstring": null,
          "decorators": [
            "patch('sanic.worker.process.os')"
          ],
          "arguments": [
            "os_mock"
          ],
          "imports": [
            "logging.ERROR",
            "logging.INFO",
            "signal.SIGINT",
            "unittest.mock.Mock",
            "unittest.mock.call",
            "unittest.mock.patch",
            "pytest",
            "sanic.compat.OS_IS_WINDOWS",
            "sanic.exceptions.ServerKilled",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.manager.WorkerManager",
            "sanic.worker.process.Worker",
            "signal.SIGKILL"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "manager.shutdown",
              "body": "@app.after_server_start\ndef shutdown(*_):\n    app.stop()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `manager.shutdown` method is designed to gracefully shut down a server process in a Sanic application. It ensures that any necessary cleanup tasks are performed before the server stops, allowing for a controlled shutdown of background tasks and resources.\n\n**How It Works**:  \nThe method is decorated with `@app.after_server_start`, which means it is triggered after the server has started. Inside the method, `app.stop()` is called, which initiates the shutdown process. This involves firing the `before_server_stop` and `after_server_stop` events, allowing registered listeners to execute any cleanup or shutdown tasks. The method ensures that all worker processes are terminated properly, and any resources are released, preventing potential data loss or corruption during the shutdown sequence."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_send_from_directory",
          "module": "test_helpers",
          "class_name": "TestSendfile",
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 92,
          "end_line_number": 99,
          "source_code": "def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.data.strip() == b'Hello Subdomain'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or testing purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred, especially in contexts where resource management is critical, such as database connections or file handlers."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_url_path",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 1405,
          "end_line_number": 1413,
          "source_code": "def test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
          "docstring": null,
          "decorators": [],
          "arguments": [],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.status_code == 200",
            "assert flask.url_for('static', filename='index.html') == '/foo/index.html'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a value (42) to a list named `called`. This suggests that the method is likely part of a resource management system where tracking the closure of resources is important.\n\n**How It Works**:  \nWhen the `close` method is invoked, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple indicator that the method has been called, which can be useful for debugging or tracking the state of resource management within the application. The method does not return any value or perform any additional operations beyond this append action."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_files",
          "module": "test_basic",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_basic.py",
          "line_number": 1396,
          "end_line_number": 1402,
          "source_code": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "client"
          ],
          "imports": [
            "gc",
            "re",
            "typing",
            "uuid",
            "warnings",
            "weakref",
            "contextlib.nullcontext",
            "datetime.datetime",
            "datetime.timezone",
            "platform.python_implementation",
            "pytest",
            "werkzeug.serving",
            "markupsafe.Markup",
            "werkzeug.exceptions.BadRequest",
            "werkzeug.exceptions.Forbidden",
            "werkzeug.exceptions.NotFound",
            "werkzeug.http.parse_date",
            "werkzeug.routing.BuildError",
            "werkzeug.routing.RequestRedirect",
            "flask",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "werkzeug.routing.Rule",
            "werkzeug.routing.Submount",
            "flask.debughelpers.DebugFilesKeyError",
            "dataclasses.make_dataclass",
            "pathlib.Path"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.status_code == 200",
            "assert rv.data.strip() == b'<h1>Hello World!</h1>'",
            "assert flask.url_for('static', filename='index.html') == '/static/index.html'"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform additional operations beyond this append action."
            }
          ]
        },
        {
          "repo_name": "flask",
          "name": "test_static_file",
          "module": "test_helpers",
          "class_name": null,
          "file_path": "__internal__/data/flask/tests/test_helpers.py",
          "line_number": 45,
          "end_line_number": 90,
          "source_code": "def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "self",
            "app",
            "req_ctx"
          ],
          "imports": [
            "io",
            "os",
            "pytest",
            "werkzeug.exceptions",
            "flask",
            "flask.helpers.get_debug_flag",
            "flask.views.MethodView"
          ],
          "fixtures": [],
          "assertions": [
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age is None",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 3600",
            "assert rv.cache_control.max_age == 10",
            "assert rv.cache_control.max_age == 10"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "rv.close",
              "body": "def close(self):\n    called.append(42)",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to perform cleanup operations, typically related to resource management, by appending a specific value (42) to a list named `called`. This indicates that the method has been invoked, which can be useful for tracking or debugging purposes.\n\n**How It Works**:  \nWhen the `close` method is called, it executes a single line of code that appends the integer 42 to the `called` list. This action serves as a simple signal that the method has been executed, allowing developers to verify that the cleanup process has occurred. The method does not return any value or perform any additional operations beyond this append action."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_override_defaults",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 234,
        "end_line_number": 253,
        "source_code": "def test_override_defaults(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        dotted_dir_file = self.reload_path / \".dotted_dir\" / \"file.txt\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                # We need to add *.txt otherwise no regular files will match\n                reload_includes=[\".*\", \"*.txt\"],\n                reload_excludes=[\"*.py\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, dotted_dir_file)\n            assert not self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, dotted_dir_file)",
          "assert not self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for a short duration (0.1 seconds) to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload.\n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another class) with the specified `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes. It checks if the reloader correctly detects changes in the specified files and triggers a restart.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which indicates the paths of any files that triggered a reload, or `None` if no changes were detected. \n\nThis method is typically used in testing scenarios to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If it is, it calls the `touch_soon` function on the provided files to simulate a change.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for 0.1 seconds to allow for any potential file system updates.\n4. It then touches (updates the timestamp of) each file in the provided list to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no files triggered a reload, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_explicit_paths",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 262,
        "end_line_number": 279,
        "source_code": "def test_explicit_paths(self, touch_soon) -> None:\n        dotted_file = self.reload_path / \".dotted\"\n        non_dotted_file = self.reload_path / \"ext\" / \"ext.jpg\"\n        python_file = self.reload_path / \"main.py\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_includes=[\".dotted\", \"ext/ext.jpg\"],\n            )\n            reloader = self._setup_reloader(config)\n\n            assert self._reload_tester(touch_soon, reloader, dotted_file)\n            assert self._reload_tester(touch_soon, reloader, non_dotted_file)\n            assert self._reload_tester(touch_soon, reloader, python_file)\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [pytest.param(WatchFilesReload, marks=skip_if_m1), WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, non_dotted_file)",
          "assert self._reload_tester(touch_soon, reloader, python_file)"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:\nThe `_reload_tester` method is designed to test the reloading functionality of a file reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:\n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for a short duration (0.1 seconds) to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a modification.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that have changed, or `None` if no changes were detected.\n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_watchfiles_no_changes",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 283,
        "end_line_number": 308,
        "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
        ],
        "arguments": [
          "self"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(reloader, WatchFilesReload)",
          "assert reloader.should_restart() is None"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application is set up to automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time before reloading.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to begin monitoring for changes.\n5. Finally, it returns the initialized reloader instance for further use."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_watchfiles_no_changes",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 283,
        "end_line_number": 308,
        "source_code": "def test_watchfiles_no_changes(self) -> None:\n        sub_dir = self.reload_path / \"app\" / \"sub\"\n\n        with as_cwd(self.reload_path):\n            config = Config(\n                app=\"tests.test_config:asgi_app\",\n                reload=True,\n                reload_excludes=[str(sub_dir)],\n            )\n            reloader = self._setup_reloader(config)\n\n            from watchfiles import watch\n\n            assert isinstance(reloader, WatchFilesReload)\n            # just so we can make rust_timeout 100ms\n            reloader.watcher = watch(\n                sub_dir,\n                watch_filter=None,\n                stop_event=reloader.should_exit,\n                yield_on_timeout=True,\n                rust_timeout=100,\n            )\n\n            assert reloader.should_restart() is None\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.skipif(WatchFilesReload is None, reason='watchfiles not available')",
          "pytest.mark.parametrize('reloader_class', [WatchFilesReload])"
        ],
        "arguments": [
          "self"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert isinstance(reloader, WatchFilesReload)",
          "assert reloader.should_restart() is None"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "reloader.should_restart",
            "body": "def should_restart(self):\n    nonlocal step\n    step += 1\n    if step == 1:\n        return None\n    elif step == 2:\n        return [tmp_path / 'foobar.py']\n    else:\n        raise StopIteration()",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `should_restart` method determines whether the application should restart based on the number of times it has been called. It is part of a reloader mechanism that monitors changes and decides when to reload the application.\n\n**How It Works**:  \nThe method uses a nonlocal variable `step` to track its invocation count. On the first call (`step == 1`), it returns `None`, indicating no restart is needed. On the second call (`step == 2`), it returns a list containing the path to a file (`foobar.py`), suggesting that this file change should trigger a restart. On any subsequent calls, it raises a `StopIteration` exception, signaling that no further checks are necessary. This method is typically used in a reloader context to manage application lifecycle events based on file changes."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_stop",
              "body": "@app.reload_process_stop\ndef reload_process_stop(_):\n    results.append('reload_process_stop')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_stop` method is a listener decorator in the Sanic framework that allows developers to define a callback function that will be executed when the reload process of the application stops. This is useful for performing cleanup actions or logging when the application is reloaded.\n\n**How It Works**:  \nWhen the `@app.reload_process_stop` decorator is applied to a function, it registers that function as a listener for the \"reload_process_stop\" event. The function can then perform any desired actions, such as logging a message or executing specific code. The method is part of a broader event-driven architecture in Sanic, where various events can trigger specific listener functions, enhancing the application's responsiveness to state changes."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_detect_new_reload_dirs",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 311,
        "end_line_number": 332,
        "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon",
          "caplog",
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)",
          "assert caplog.records[-2].levelno == logging.INFO",
          "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._setup_reloader",
            "body": "def _setup_reloader(self, config: Config) -> BaseReload:\n    config.reload_delay = 0\n    if self.reloader_class is WatchGodReload:\n        with pytest.deprecated_call():\n            reloader = self.reloader_class(config, target=run, sockets=[])\n    else:\n        reloader = self.reloader_class(config, target=run, sockets=[])\n    assert config.should_reload\n    reloader.startup()\n    return reloader",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_setup_reloader` method initializes a reloader instance based on the provided configuration, ensuring that the application can automatically reload when changes are detected in the code.\n\n**How It Works**:  \n1. It sets the `reload_delay` in the `config` to `0`, which minimizes the wait time for detecting changes.\n2. Depending on the `reloader_class`, it creates an instance of the reloader (either `WatchGodReload` or another specified class) with the given `config`, a target function (`run`), and an empty list of sockets.\n3. It asserts that the configuration indicates the application should reload (`config.should_reload`).\n4. The reloader's `startup` method is called to prepare it for monitoring file changes.\n5. Finally, it returns the initialized reloader instance for further use in the application."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reload_listeners_attached",
          "module": "test_server_events",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/test_server_events.py",
          "line_number": 217,
          "end_line_number": 226,
          "source_code": "def test_reload_listeners_attached(app):\n    async def dummy(*_): ...\n\n    app.reload_process_start(dummy)\n    app.reload_process_stop(dummy)\n    app.listener(\"reload_process_start\")(dummy)\n    app.listener(\"reload_process_stop\")(dummy)\n\n    assert len(app.listeners.get(\"reload_process_start\")) == 2\n    assert len(app.listeners.get(\"reload_process_stop\")) == 2",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app"
          ],
          "imports": [
            "asyncio",
            "signal",
            "contextlib.closing",
            "socket.socket",
            "pytest",
            "sanic_testing.testing.HOST",
            "sanic.Blueprint",
            "sanic.exceptions.BadRequest",
            "sanic.exceptions.SanicException",
            "conftest.get_port"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(app.listeners.get('reload_process_start')) == 2",
            "assert len(app.listeners.get('reload_process_stop')) == 2"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "app.reload_process_start",
              "body": "@app.reload_process_start\ndef reload_process_start(_):\n    results.append('reload_process_start')",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `reload_process_start` method is a listener decorator in a Sanic application that allows developers to define a callback function that will be executed when the reload process starts. This is useful for performing any necessary actions or logging when the application is about to reload.\n\n**How It Works**:  \nWhen the `reload_process_start` method is decorated with `@app.reload_process_start`, it registers the decorated function to be called at the start of the reload process. The function takes a single argument (the app instance) and appends a message to a `results` list, indicating that the reload process has started. This mechanism allows developers to hook into the reload lifecycle and execute custom logic, such as cleanup tasks or logging, before the application reloads."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_detect_new_reload_dirs",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 311,
        "end_line_number": 332,
        "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon",
          "caplog",
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)",
          "assert caplog.records[-2].levelno == logging.INFO",
          "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)`, then sleeps for 0.1 seconds to allow any file system events to settle.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that triggered a reload. If no changes were detected, it returns `None`. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_should_detect_new_reload_dirs",
        "module": "test_reload",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/supervisors/test_reload.py",
        "line_number": 311,
        "end_line_number": 332,
        "source_code": "def test_should_detect_new_reload_dirs(self, touch_soon, caplog: pytest.LogCaptureFixture, tmp_path: Path) -> None:\n        app_dir = tmp_path / \"app\"\n        app_file = app_dir / \"file.py\"\n        app_dir.mkdir()\n        app_file.touch()\n        app_first_dir = tmp_path / \"app_first\"\n        app_first_file = app_first_dir / \"file.py\"\n\n        with as_cwd(tmp_path):\n            config = Config(app=\"tests.test_config:asgi_app\", reload=True, reload_includes=[\"app*\"])\n            reloader = self._setup_reloader(config)\n            assert self._reload_tester(touch_soon, reloader, app_file)\n\n            app_first_dir.mkdir()\n            assert self._reload_tester(touch_soon, reloader, app_first_file)\n            assert caplog.records[-2].levelno == logging.INFO\n            assert (\n                caplog.records[-1].message == \"WatchGodReload detected a new reload \"\n                f\"dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\"\n            )\n\n            reloader.shutdown()",
        "docstring": null,
        "decorators": [
          "pytest.mark.parametrize('reloader_class', [WatchGodReload])"
        ],
        "arguments": [
          "self",
          "touch_soon",
          "caplog",
          "tmp_path"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "platform",
          "signal",
          "socket",
          "sys",
          "pathlib.Path",
          "time.sleep",
          "pytest",
          "tests.utils.as_cwd",
          "uvicorn.config.Config",
          "uvicorn.supervisors.basereload.BaseReload",
          "uvicorn.supervisors.basereload._display_path",
          "uvicorn.supervisors.statreload.StatReload",
          "uvicorn.supervisors.watchfilesreload.WatchFilesReload",
          "uvicorn.supervisors.watchgodreload.WatchGodReload",
          "watchfiles.watch"
        ],
        "fixtures": [],
        "assertions": [
          "assert self._reload_tester(touch_soon, reloader, app_file)",
          "assert self._reload_tester(touch_soon, reloader, app_first_file)",
          "assert caplog.records[-2].levelno == logging.INFO",
          "assert caplog.records[-1].message == f\"WatchGodReload detected a new reload dir '{app_first_dir.name}' in '{tmp_path}'; Adding to watch list.\""
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "self._reload_tester",
            "body": "def _reload_tester(self, touch_soon, reloader: BaseReload, *files: Path) -> list[Path] | None:\n    reloader.restart()\n    if WatchFilesReload is not None and isinstance(reloader, WatchFilesReload):\n        touch_soon(*files)\n    else:\n        assert not next(reloader)\n        sleep(0.1)\n        for file in files:\n            file.touch()\n    return next(reloader)",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `_reload_tester` method is designed to test the reloading functionality of a specified reloader (either `WatchFilesReload` or another type) by simulating file changes and checking if the reloader correctly detects these changes.\n\n**How It Works**:  \n1. The method first calls `reloader.restart()` to initiate the reloading process.\n2. It checks if the reloader is an instance of `WatchFilesReload`. If so, it invokes the `touch_soon` function on the provided files, which likely updates their timestamps to simulate changes.\n3. If the reloader is not `WatchFilesReload`, it asserts that there are no changes detected by calling `next(reloader)` and then sleeps for a short duration (0.1 seconds) to allow for any potential file system updates.\n4. It then touches each file in the `files` argument to simulate a change.\n5. Finally, it returns the result of `next(reloader)`, which should indicate the paths of any files that have changed, or `None` if no changes were detected. \n\nThis method is typically used in tests to ensure that the reloader behaves as expected when files are modified."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_start_stop_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 158,
          "end_line_number": 174,
          "source_code": "def test_reloader_triggers_start_stop_listeners(\n    app: Sanic, app_loader: AppLoader\n):\n    results = []\n\n    @app.reload_process_start\n    def reload_process_start(_):\n        results.append(\"reload_process_start\")\n\n    @app.reload_process_stop\n    def reload_process_stop(_):\n        results.append(\"reload_process_stop\")\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    run_reloader(reloader)\n\n    assert results == [\"reload_process_start\", \"reload_process_stop\"]",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert results == ['reload_process_start', 'reload_process_stop']"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:\nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It utilizes a signal to manage the reloading process.\n\n**How It Works**:\nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that stops the reloader when a signal (SIGALRM) is received. The method sets an alarm to trigger this stop function after 1 second. It then calls the `reloader` function, which is expected to handle the logic for monitoring file changes and reloading the application. The reloader runs in a loop, checking for file modifications at specified intervals, and can be gracefully stopped using the defined signal handler."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 186,
          "end_line_number": 210,
          "source_code": "def test_triggered(app_loader):\n    paths = set()\n\n    def check_file(filename, mtimes):\n        if (isinstance(filename, Path) and (filename.name == \"server.py\")) or (\n            isinstance(filename, str) and \"sanic/app.py\" in filename\n        ):\n            paths.add(str(filename))\n            return True\n        return False\n\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert len(paths) == 2\n\n    publisher.send.assert_called()\n    call_arg = publisher.send.call_args_list[0][0][0]\n    assert call_arg.startswith(\"__ALL_PROCESSES__:\")\n    assert call_arg.count(\",\") == 1\n    for path in paths:\n        assert str(path) in call_arg",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert len(paths) == 2",
            "assert call_arg.startswith('__ALL_PROCESSES__:')",
            "assert call_arg.count(',') == 1",
            "assert str(path) in call_arg"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully.\n\n**How It Works**:  \nThe method takes a `reloader` function as an argument. It defines a nested `stop` function that calls the `stop` method of the `reloader`, which sets a flag to terminate the reloading loop. The method then registers this `stop` function to be called when a `SIGALRM` signal is received, and it sets an alarm to trigger this signal after 1 second. Finally, it invokes the `reloader` function, which enters a loop to monitor specified files for changes, reloading the application as necessary."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_not_triggered",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 177,
          "end_line_number": 183,
          "source_code": "def test_not_triggered(app_loader):\n    reload_dir = Path(__file__).parent.parent / \"fake\"\n    publisher = Mock()\n    reloader = Reloader(publisher, 0.1, {reload_dir}, app_loader)\n    run_reloader(reloader)\n\n    publisher.send.assert_not_called()",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when an alarm signal is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It sets up a signal handler for the `SIGALRM` signal, linking it to the `stop` function.\n3. An alarm is set to trigger after 1 second, which will invoke the `stop` function if the reloader is still running.\n4. Finally, it calls the `reloader` instance, which enters a loop to monitor specified directories for file changes. If changes are detected, it triggers the appropriate events and reloads the application."
            }
          ]
        },
        {
          "repo_name": "sanic",
          "name": "test_reloader_triggers_reload_listeners",
          "module": "test_reloader",
          "class_name": null,
          "file_path": "__internal__/data/sanic/tests/worker/test_reloader.py",
          "line_number": 213,
          "end_line_number": 237,
          "source_code": "def test_reloader_triggers_reload_listeners(app: Sanic, app_loader: AppLoader):\n    before = Event()\n    after = Event()\n    changed_files = set()\n\n    def check_file(filename, mtimes):\n        return not after.is_set()\n\n    @app.before_reload_trigger\n    async def before_reload_trigger(_):\n        before.set()\n\n    @app.after_reload_trigger\n    async def after_reload_trigger(_, changed):\n        after.set()\n        changed_files.update(changed)\n\n    reloader = Reloader(Mock(), 0.1, set(), app_loader)\n    reloader.check_file = check_file  # type: ignore\n    run_reloader(reloader)\n\n    assert before.is_set()\n    assert after.is_set()\n    assert len(changed_files) > 0\n    assert changed_files == set(reloader.files())",
          "docstring": null,
          "decorators": [],
          "arguments": [
            "app",
            "app_loader"
          ],
          "imports": [
            "re",
            "signal",
            "threading",
            "asyncio.Event",
            "logging.DEBUG",
            "pathlib.Path",
            "time.sleep",
            "unittest.mock.Mock",
            "pytest",
            "sanic.app.Sanic",
            "sanic.worker.constants.ProcessState",
            "sanic.worker.constants.RestartOrder",
            "sanic.worker.loader.AppLoader",
            "sanic.worker.process.WorkerProcess",
            "sanic.worker.reloader.Reloader"
          ],
          "fixtures": [],
          "assertions": [
            "assert before.is_set()",
            "assert after.is_set()",
            "assert len(changed_files) > 0",
            "assert changed_files == set(reloader.files())"
          ],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [],
          "methods_under_test": [
            {
              "name": "run_reloader",
              "body": "def run_reloader(reloader):\n\n    def stop(*_):\n        reloader.stop()\n    signal.signal(signal.SIGALRM, stop)\n    signal.alarm(1)\n    reloader()",
              "method_explanation": "**Main Purpose of the Method**:  \nThe `run_reloader` method is designed to start a reloader process that monitors file changes and triggers a reload of the application when changes are detected. It sets up a signal handler to stop the reloader gracefully when a specific signal (SIGALRM) is received.\n\n**How It Works**:  \n1. The method defines a nested function `stop`, which calls the `stop` method of the `reloader` instance to terminate the reloading process.\n2. It registers the `stop` function as a handler for the SIGALRM signal using `signal.signal()`.\n3. It sets an alarm to trigger after 1 second using `signal.alarm(1)`, which will invoke the `stop` function if the alarm goes off.\n4. Finally, it calls the `reloader` instance (which is callable) to start the reloading process, allowing it to monitor file changes and reload the application as necessary."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_fragmentation",
        "module": "test_http",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
        "line_number": 902,
        "end_line_number": 944,
        "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
        "docstring": null,
        "decorators": [
          "skip_if_no_httptools"
        ],
        "arguments": [
          "unused_tcp_port"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "socket",
          "threading",
          "time",
          "typing.TYPE_CHECKING",
          "typing.Any",
          "pytest",
          "tests.response.Response",
          "uvicorn.Server",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Scope",
          "uvicorn.config.WS_PROTOCOLS",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn",
          "uvicorn.main.ServerState",
          "uvicorn.protocols.http.h11_impl.H11Protocol",
          "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
          "sys",
          "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
          "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
          "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
          "typing.TypeAlias",
          "typing_extensions.TypeAlias"
        ],
        "fixtures": [],
        "assertions": [
          "assert bad_response != response[:len(bad_response)]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "sock.close",
            "body": "def close(self):\n    assert not self.closed\n    self.closed = True",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `close` method is designed to safely close a socket connection by marking it as closed, preventing any further operations on it.\n\n**How It Works**:  \nThe method first asserts that the socket is not already closed (`self.closed` should be `False`). If the assertion passes, it sets `self.closed` to `True`, indicating that the socket is now closed. This prevents any subsequent read or write operations on the socket, ensuring that resources are properly released and avoiding potential errors from attempting to use a closed socket."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of resources associated with the connection."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_pass_ssl_context",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 980,
          "end_line_number": 1062,
          "source_code": "def test_https_connect_pass_ssl_context(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            tls_m.assert_called_with(\n                                mock.ANY,\n                                mock.ANY,\n                                _SSL_CONTEXT_VERIFIED,\n                                server_hostname=\"www.python.org\",\n                                ssl_handshake_timeout=mock.ANY,\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertEqual(proxy_req.method, \"CONNECT\")\n                            self.assertEqual(\n                                proxy_req.url, URL(\"https://www.python.org\")\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate an active connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the method sets a flag (`self._close`) to indicate that the connection should be closed. If there is an associated waiter (a task that is waiting for a condition to be met), it cancels that waiter to prevent further processing. This method is typically called when the application is done using the connection, ensuring a clean shutdown of resources associated with it."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "proxy_resp.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to gracefully terminate a connection, stopping the acceptance of new messages and ensuring that any ongoing message processing is completed before fully closing the connection.\n\n**How It Works**:\nWhen invoked, the `close` method sets a flag (`self._close`) to indicate that the connection should no longer accept new messages. If there is an active waiter (a task waiting for a response), it cancels that waiter to prevent further processing. This method is typically called when the connection is no longer needed, allowing for a clean shutdown of the associated resources."
            }
          ]
        }
      ]
    },
    {
      "host_test": {
        "repo_name": "uvicorn",
        "name": "test_fragmentation",
        "module": "test_http",
        "class_name": null,
        "file_path": "__internal__/data/uvicorn/tests/protocols/test_http.py",
        "line_number": 902,
        "end_line_number": 944,
        "source_code": "def test_fragmentation(unused_tcp_port: int):\n    def receive_all(sock: socket.socket):\n        chunks: list[bytes] = []\n        while True:\n            chunk = sock.recv(1024)\n            if not chunk:\n                break\n            chunks.append(chunk)\n        return b\"\".join(chunks)\n\n    app = Response(\"Hello, world\", media_type=\"text/plain\")\n\n    def send_fragmented_req(path: str):\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((\"127.0.0.1\", unused_tcp_port))\n        d = (f\"GET {path} HTTP/1.1\\r\\n\" \"Host: localhost\\r\\n\" \"Connection: close\\r\\n\\r\\n\").encode()\n        split = len(path) // 2\n        sock.sendall(d[:split])\n        time.sleep(0.01)\n        sock.sendall(d[split:])\n        resp = receive_all(sock)\n        # see https://github.com/kmonsoor/py-amqplib/issues/45\n        # we skip the error on bsd systems if python is too slow\n        try:\n            sock.shutdown(socket.SHUT_RDWR)\n        except Exception:  # pragma: no cover\n            pass\n        sock.close()\n        return resp\n\n    config = Config(app=app, http=\"httptools\", port=unused_tcp_port)\n    server = Server(config=config)\n    t = threading.Thread(target=server.run)\n    t.daemon = True\n    t.start()\n    time.sleep(1)  # wait for uvicorn to start\n\n    path = \"/?param=\" + \"q\" * 10\n    response = send_fragmented_req(path)\n    bad_response = b\"HTTP/1.1 400 Bad Request\"\n    assert bad_response != response[: len(bad_response)]\n    server.should_exit = True\n    t.join()",
        "docstring": null,
        "decorators": [
          "skip_if_no_httptools"
        ],
        "arguments": [
          "unused_tcp_port"
        ],
        "imports": [
          "__future__.annotations",
          "logging",
          "socket",
          "threading",
          "time",
          "typing.TYPE_CHECKING",
          "typing.Any",
          "pytest",
          "tests.response.Response",
          "uvicorn.Server",
          "uvicorn._types.ASGIApplication",
          "uvicorn._types.ASGIReceiveCallable",
          "uvicorn._types.ASGISendCallable",
          "uvicorn._types.Scope",
          "uvicorn.config.WS_PROTOCOLS",
          "uvicorn.config.Config",
          "uvicorn.lifespan.off.LifespanOff",
          "uvicorn.lifespan.on.LifespanOn",
          "uvicorn.main.ServerState",
          "uvicorn.protocols.http.h11_impl.H11Protocol",
          "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
          "sys",
          "uvicorn.protocols.http.httptools_impl.HttpToolsProtocol",
          "uvicorn.protocols.websockets.websockets_impl.WebSocketProtocol",
          "uvicorn.protocols.websockets.wsproto_impl.WSProtocol",
          "typing.TypeAlias",
          "typing_extensions.TypeAlias"
        ],
        "fixtures": [],
        "assertions": [
          "assert bad_response != response[:len(bad_response)]"
        ],
        "setup_method": null,
        "teardown_method": null,
        "mocks": [],
        "methods_under_test": [
          {
            "name": "sock.shutdown",
            "body": "def shutdown(self):\n    calls.append('shutdown')",
            "method_explanation": "**Main Purpose of the Method**:  \nThe `shutdown` method is designed to gracefully terminate a server process and close all associated sockets. It ensures that no new connections are accepted and that existing connections are properly shut down.\n\n**How It Works**:  \nWhen invoked, the method first logs a shutdown message. It then iterates over all server instances to close them, followed by closing any provided sockets. After that, it requests a shutdown on all active connections by calling their respective `shutdown` methods. Finally, it pauses for a brief moment (0.1 seconds) to allow for any cleanup processes to complete before fully exiting. This method is crucial for ensuring that resources are released properly and that the server can shut down without leaving hanging connections."
          }
        ]
      },
      "similar_tests": [
        {
          "repo_name": "aiohttp",
          "name": "test_https_auth",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 1070,
          "end_line_number": 1156,
          "source_code": "def test_https_auth(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            auth=aiohttp.helpers.BasicAuth(\"user\", \"pass\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ) as host_m:\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ):\n                            self.assertIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(req.url.path, \"/\")\n                            self.assertNotIn(\"AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"PROXY-AUTHORIZATION\", req.headers)\n                            self.assertNotIn(\"AUTHORIZATION\", proxy_req.headers)\n                            self.assertIn(\"PROXY-AUTHORIZATION\", proxy_req.headers)\n\n                            host_m.assert_called_with(\n                                \"proxy.example.com\", 80, traces=mock.ANY\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting the resulting futures. Finally, it waits for all close operations to complete, handling any exceptions that may arise during the process. This ensures that the application can shut down gracefully without leaving any hanging connections."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting their closure futures. Finally, it waits for all closure operations to complete, handling any exceptions that may arise during this process. This ensures that the application can shut down gracefully without leaving any hanging connections."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_default",
          "module": "test_proxy",
          "class_name": "TestProxy",
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 260,
          "end_line_number": 333,
          "source_code": "def test_proxy_server_hostname_default(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"www.python.org\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting their closure futures. Finally, it waits for all closure operations to complete, handling any exceptions that may arise during this process. This ensures that the application can shut down gracefully without leaving any hanging connections."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_https_connect_http_proxy_error",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 768,
          "end_line_number": 836,
          "source_code": "def test_https_connect_http_proxy_error(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\", URL(\"http://proxy.example.com\"), loop=self.loop\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 400\n                m.return_value.reason = \"bad request\"\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    tr.get_extra_info.return_value = None\n                    # Called on connection to http://proxy.example.com\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        req = ClientRequest(\n                            \"GET\",\n                            URL(\"https://www.python.org\"),\n                            proxy=URL(\"http://proxy.example.com\"),\n                            loop=self.loop,\n                        )\n                        with self.assertRaisesRegex(\n                            aiohttp.ClientHttpProxyError, \"400, message='bad request'\"\n                        ):\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                        self.loop.run_until_complete(proxy_req.close())\n                        proxy_resp.close()\n                        self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to cleanly terminate all open transports associated with a web application or connection, ensuring that resources are properly released and any ongoing operations are completed.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any scheduled cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting the resulting futures. Finally, it waits for all close operations to complete, handling any exceptions that may arise during this process. This ensures that the application can shut down gracefully without leaving any hanging connections."
            }
          ]
        },
        {
          "repo_name": "aiohttp",
          "name": "test_proxy_server_hostname_override",
          "module": "test_proxy",
          "class_name": null,
          "file_path": "__internal__/data/aiohttp/tests/test_proxy.py",
          "line_number": 341,
          "end_line_number": 417,
          "source_code": "def test_proxy_server_hostname_override(\n        self, start_connection: mock.Mock, ClientRequestMock: mock.Mock\n    ) -> None:\n        proxy_req = ClientRequest(\n            \"GET\",\n            URL(\"http://proxy.example.com\"),\n            loop=self.loop,\n        )\n        ClientRequestMock.return_value = proxy_req\n\n        proxy_resp = ClientResponse(\n            \"get\",\n            URL(\"http://proxy.example.com\"),\n            request_info=mock.Mock(),\n            writer=None,\n            continue100=None,\n            timer=TimerNoop(),\n            traces=[],\n            loop=self.loop,\n            session=mock.Mock(),\n        )\n        with mock.patch.object(\n            proxy_req, \"send\", autospec=True, return_value=proxy_resp\n        ):\n            with mock.patch.object(proxy_resp, \"start\", autospec=True) as m:\n                m.return_value.status = 200\n\n                async def make_conn() -> aiohttp.TCPConnector:\n                    return aiohttp.TCPConnector()\n\n                connector = self.loop.run_until_complete(make_conn())\n                r = {\n                    \"hostname\": \"hostname\",\n                    \"host\": \"127.0.0.1\",\n                    \"port\": 80,\n                    \"family\": socket.AF_INET,\n                    \"proto\": 0,\n                    \"flags\": 0,\n                }\n                with mock.patch.object(\n                    connector, \"_resolve_host\", autospec=True, return_value=[r]\n                ):\n                    tr, proto = mock.Mock(), mock.Mock()\n                    with mock.patch.object(\n                        self.loop,\n                        \"create_connection\",\n                        autospec=True,\n                        return_value=(tr, proto),\n                    ):\n                        with mock.patch.object(\n                            self.loop,\n                            \"start_tls\",\n                            autospec=True,\n                            return_value=mock.Mock(),\n                        ) as tls_m:\n                            req = ClientRequest(\n                                \"GET\",\n                                URL(\"https://www.python.org\"),\n                                proxy=URL(\"http://proxy.example.com\"),\n                                server_hostname=\"server-hostname.example.com\",\n                                loop=self.loop,\n                            )\n                            self.loop.run_until_complete(\n                                connector._create_connection(\n                                    req, [], aiohttp.ClientTimeout()\n                                )\n                            )\n\n                            self.assertEqual(\n                                tls_m.call_args.kwargs[\"server_hostname\"],\n                                \"server-hostname.example.com\",\n                            )\n\n                            self.loop.run_until_complete(proxy_req.close())\n                            proxy_resp.close()\n                            self.loop.run_until_complete(req.close())\n                self.loop.run_until_complete(connector.close())",
          "docstring": null,
          "decorators": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)"
          ],
          "arguments": [
            "self",
            "start_connection",
            "ClientRequestMock"
          ],
          "imports": [
            "asyncio",
            "gc",
            "socket",
            "ssl",
            "unittest",
            "unittest.mock",
            "pytest",
            "yarl.URL",
            "aiohttp",
            "aiohttp.client_reqrep.ClientRequest",
            "aiohttp.client_reqrep.ClientResponse",
            "aiohttp.client_reqrep.Fingerprint",
            "aiohttp.connector._SSL_CONTEXT_VERIFIED",
            "aiohttp.helpers.TimerNoop",
            "aiohttp.test_utils.make_mocked_coro"
          ],
          "fixtures": [],
          "assertions": [],
          "setup_method": null,
          "teardown_method": null,
          "mocks": [
            "mock.patch('aiohttp.connector.ClientRequest')",
            "mock.patch('aiohttp.connector.aiohappyeyeballs.start_connection', autospec=True, spec_set=True)",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()",
            "mock.Mock()"
          ],
          "methods_under_test": [
            {
              "name": "req.close",
              "body": "def close(self) -> None:\n    pass",
              "method_explanation": "**Main Purpose of the Method**:\nThe `close` method is designed to terminate all open transports associated with a web application or connection, ensuring that resources are properly released and no further data can be sent or received.\n\n**How It Works**:\nWhen invoked, the `close` method first checks if there are any active connections that need to be closed. It sets a flag to indicate that the object is closed and cancels any ongoing cleanup tasks. It then iterates through all active connections, calling their `close` methods and collecting the resulting futures. Finally, it waits for all close operations to complete, handling any exceptions that may arise during the process. This method is typically used in the context of shutting down a web server or cleaning up resources when they are no longer needed."
            }
          ]
        }
      ]
    }
  ]
}