{
  "relevant_pairs": [
    {
      "host_item": {
        "test": "tests/test_appctx.py",
        "code": "src/flask/ctx.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_ctx.py",
          "code": "src/quart/ctx.py",
          "code_similarity_score": 0.7406927347183228,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_ctx.py in the donor project to test src/flask/ctx.py in the host project through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom unittest.mock import Mock\n\nimport pytest\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.exceptions import BadRequest\n\nfrom flask import Flask, g, request\nfrom flask.ctx import (\n    after_this_request,\n    AppContext,\n    copy_current_app_context,\n    copy_current_request_context,\n    has_app_context,\n    has_request_context,\n    RequestContext,\n)\nfrom flask.globals import _cv_request\nfrom flask.sessions import SessionMixin\nfrom flask.signals import appcontext_pushed, appcontext_popped\nfrom flask.typing import WSGIEnvironment\nfrom flask.wrappers import Request\n\n\n# Mocking a WSGI environment for testing\ndef make_test_environ() -> WSGIEnvironment:\n    return {\n        \"REQUEST_METHOD\": \"GET\",\n        \"PATH_INFO\": \"/\",\n        \"SERVER_NAME\": \"localhost\",\n        \"SERVER_PORT\": \"5000\",\n        \"wsgi.url_scheme\": \"http\",\n    }\n\n\nasync def test_request_context_match() -> None:\n    app = Flask(__name__)\n    url_adapter = Mock()\n    rule = Mock()\n    rule.endpoint = \"index\"\n    url_adapter.match.return_value = (rule, {\"arg\": \"value\"})\n    app.create_url_adapter = lambda *_: url_adapter  # type: ignore\n    environ = make_test_environ()\n    request = Request(environ)\n    with RequestContext(app, environ, request):\n        assert request.url_rule == rule\n        assert request.view_args == {\"arg\": \"value\"}\n\n\nasync def test_bad_request_if_websocket_route() -> None:\n    app = Flask(__name__)\n    url_adapter = Mock()\n    url_adapter.match.side_effect = BadRequest()\n    app.create_url_adapter = lambda *_: url_adapter  # type: ignore\n    environ = make_test_environ()\n    request = Request(environ)\n    with RequestContext(app, environ, request):\n        assert isinstance(request.routing_exception, BadRequest)\n\n\nasync def test_after_this_request() -> None:\n    app = Flask(__name__)\n    environ = make_test_environ()\n    with RequestContext(app, environ, Request(environ)) as context:\n        after_this_request(lambda response: \"hello\")  # type: ignore\n        assert context._after_request_functions[0](None) == \"hello\"  # type: ignore\n\n\nasync def test_has_request_context() -> None:\n    app = Flask(__name__)\n    environ = make_test_environ()\n    with RequestContext(app, environ, Request(environ)):\n        assert has_request_context() is True\n        assert has_app_context() is True\n    assert has_request_context() is False\n    assert has_app_context() is False\n\n\nasync def test_has_app_context() -> None:\n    app = Flask(__name__)\n    with AppContext(app):\n        assert has_app_context() is True\n    assert has_app_context() is False\n\n\nasync def test_copy_current_app_context() -> None:\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index() -> str:\n        g.foo = \"bar\"\n\n        @copy_current_app_context\n        def within_context() -> None:\n            assert g.foo == \"bar\"\n\n        asyncio.ensure_future(within_context())\n        return \"\"\n\n    test_client = app.test_client()\n    response = test_client.get(\"/\")\n    assert response.status_code == 200\n\n\ndef test_copy_current_app_context_error() -> None:\n    with pytest.raises(RuntimeError):\n        copy_current_app_context(lambda: None)()\n\n\nasync def test_copy_current_request_context() -> None:\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index() -> str:\n        @copy_current_request_context\n        def within_context() -> None:\n            assert request.path == \"/\"\n\n        asyncio.ensure_future(within_context())\n        return \"\"\n\n    test_client = app.test_client()\n    response = test_client.get(\"/\")\n    assert response.status_code == 200\n\n\ndef test_copy_current_request_context_error() -> None:\n    with pytest.raises(RuntimeError):\n        copy_current_request_context(lambda: None)()\n\n\nasync def test_works_without_copy_current_request_context() -> None:\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index() -> str:\n        def within_context() -> None:\n            assert request.path == \"/\"\n\n        asyncio.ensure_future(within_context())\n        return \"\"\n\n    test_client = app.test_client()\n    response = test_client.get(\"/\")\n    assert response.status_code == 200"
        },
        {
          "framework": "quart",
          "test": "tests/test_basic.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6715313196182251,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_basic.py to test src/flask/ctx.py through test transplantation.\n\nimport pytest\nfrom flask import Flask, g, request, has_request_context, has_app_context, after_this_request, copy_current_request_context\nfrom flask.ctx import _AppCtxGlobals, AppContext, RequestContext\nfrom werkzeug.exceptions import HTTPException\n\n@pytest.fixture\ndef app() -> Flask:\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"index\"\n\n    @app.route(\"/after_this_request\")\n    def after_this_request_route():\n        @after_this_request\n        def add_header(response):\n            response.headers['X-Foo'] = 'Bar'\n            return response\n        return \"after_this_request\"\n\n    @app.route(\"/copy_context\")\n    def copy_context_route():\n        @copy_current_request_context\n        def do_some_work():\n            assert has_request_context()\n            assert has_app_context()\n        do_some_work()\n        return \"copy_context\"\n\n    return app\n\ndef test_app_ctx_globals() -> None:\n    g = _AppCtxGlobals()\n    g.test = \"value\"\n    assert g.test == \"value\"\n    assert g.get(\"test\") == \"value\"\n    assert g.get(\"missing\", \"default\") == \"default\"\n    g.pop(\"test\")\n    with pytest.raises(AttributeError):\n        g.test\n\ndef test_app_context(app: Flask) -> None:\n    with app.app_context():\n        assert has_app_context()\n        assert not has_request_context()\n\ndef test_request_context(app: Flask) -> None:\n    with app.test_request_context('/'):\n        assert has_request_context()\n        assert has_app_context()\n\ndef test_after_this_request(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/after_this_request\")\n    assert response.status_code == 200\n    assert response.headers['X-Foo'] == 'Bar'\n\ndef test_copy_current_request_context(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/copy_context\")\n    assert response.status_code == 200\n\ndef test_has_request_context(app: Flask) -> None:\n    with app.test_request_context('/'):\n        assert has_request_context()\n\ndef test_has_app_context(app: Flask) -> None:\n    with app.app_context():\n        assert has_app_context()\n\ndef test_app_ctx_globals_repr(app: Flask) -> None:\n    with app.app_context():\n        assert repr(g) == f\"<flask.g of '{app.name}'>\"\n\ndef test_request_context_repr(app: Flask) -> None:\n    with app.test_request_context('/'):\n        ctx = _cv_request.get()\n        assert repr(ctx) == f\"<RequestContext '/' [GET] of {app.name}>\"\n\ndef test_app_context_push_pop(app: Flask) -> None:\n    ctx = AppContext(app)\n    ctx.push()\n    assert has_app_context()\n    ctx.pop()\n    assert not has_app_context()\n\ndef test_request_context_push_pop(app: Flask) -> None:\n    ctx = RequestContext(app, app.test_request_context('/').request)\n    ctx.push()\n    assert has_request_context()\n    ctx.pop()\n    assert not has_request_context()\n\ndef test_after_this_request_no_context(app: Flask) -> None:\n    with pytest.raises(RuntimeError):\n        after_this_request(lambda response: response)\n\ndef test_copy_current_request_context_no_context(app: Flask) -> None:\n    with pytest.raises(RuntimeError):\n        copy_current_request_context(lambda: None)\n\ndef test_app_context_pop_exception(app: Flask) -> None:\n    ctx = AppContext(app)\n    ctx.push()\n    with pytest.raises(AssertionError):\n        ctx.pop()\n        ctx.pop()\n\ndef test_request_context_pop_exception(app: Flask) -> None:\n    ctx = RequestContext(app, app.test_request_context('/').request)\n    ctx.push()\n    with pytest.raises(AssertionError):\n        ctx.pop()\n        ctx.pop()"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_basic.py",
        "code": "src/flask/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_basic.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6715313196182251,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_basic.py\n# to test the functionality in src/flask/app.py through test transplantation.\n\nimport pytest\nfrom flask import Flask, jsonify, request, Response, url_for\nfrom werkzeug.exceptions import HTTPException\n\n@pytest.fixture\ndef app() -> Flask:\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index() -> str:\n        return \"index\"\n\n    @app.route(\"/json/\", methods=[\"POST\"])\n    def json() -> Response:\n        data = request.get_json()\n        return jsonify(data)\n\n    @app.route(\"/error/\")\n    def error() -> str:\n        raise HTTPException(description=\"Something Unique\", response=Response(status=409))\n\n    @app.route(\"/param/<value>\")\n    def param(value: str) -> str:\n        return value\n\n    @app.errorhandler(HTTPException)\n    def handle_http_exception(e: HTTPException) -> Response:\n        return Response(e.description, status=e.code)\n\n    return app\n\n@pytest.mark.parametrize(\"path\", [\"/\"])\ndef test_index(path: str, app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 200\n    assert b\"index\" in response.data\n\ndef test_json(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.post(\"/json/\", json={\"value\": \"json\"})\n    assert response.status_code == 200\n    assert b'{\"value\":\"json\"}\\n' == response.data\n\ndef test_generic_error(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/error/\")\n    assert response.status_code == 409\n    assert b\"Something Unique\" in response.data\n\ndef test_url_defaults(app: Flask) -> None:\n    @app.url_defaults\n    def defaults(endpoint: str, values: dict) -> None:\n        if endpoint == 'param':\n            values.setdefault('value', 'hello')\n\n    with app.test_request_context(\"/\"):\n        assert url_for(\"param\") == \"/param/hello\"\n\ndef test_not_found_error(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/not_found/\")\n    assert response.status_code == 404\n    assert b\"Not Found\" in response.data\n\ndef test_make_response_str(app: Flask) -> None:\n    response = app.make_response(\"Result\")\n    assert response.status_code == 200\n    assert response.data == b\"Result\"\n\n    response = app.make_response((\"Result\", 200))\n    assert response.status_code == 200\n    assert response.data == b\"Result\"\n\n    response = app.make_response((\"Result\", {\"name\": \"value\"}))\n    assert response.status_code == 200\n    assert response.data == b\"Result\"\n    assert response.headers[\"name\"] == \"value\"\n\n    response = app.make_response((\"Result\", 404, {\"name\": \"value\"}))\n    assert response.status_code == 404\n    assert response.data == b\"Result\"\n    assert response.headers[\"name\"] == \"value\"\n\ndef test_make_response_errors(app: Flask) -> None:\n    with pytest.raises(TypeError):\n        app.make_response((\"Result\", {\"name\": \"value\"}, 200))\n    with pytest.raises(TypeError):\n        app.make_response((\"Result\", {\"name\": \"value\"}, 200, \"a\"))\n    with pytest.raises(TypeError):\n        app.make_response((\"Result\",))"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_instance_config.py",
        "code": " src/flask/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_basic.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6715313196182251,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_basic.py in Quart to test Flask functionality in src/flask/app.py\n\nfrom __future__ import annotations\n\nimport pytest\nfrom flask import Flask, jsonify, request, url_for, abort, Response\nfrom werkzeug.wrappers import Response as WerkzeugResponse\n\n@pytest.fixture\ndef app() -> Flask:\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index() -> str:\n        return \"index\"\n\n    @app.route(\"/\u2764\ufe0f\")\n    def iri() -> str:\n        return \"\ud83d\udc94\"\n\n    @app.route(\"/sync/\")\n    def sync() -> str:\n        return \"index\"\n\n    @app.route(\"/json/\", methods=[\"POST\"])\n    def json() -> Response:\n        data = request.get_json()\n        return jsonify(data)\n\n    @app.route(\"/implicit_json/\", methods=[\"POST\"])\n    def implicit_json() -> Response:\n        data = request.get_json()\n        return jsonify(data)\n\n    @app.route(\"/werkzeug/\")\n    def werkzeug() -> WerkzeugResponse:\n        return WerkzeugResponse(b\"Hello\")\n\n    @app.route(\"/error/\")\n    def error() -> str:\n        abort(409)\n        return \"OK\"\n\n    @app.route(\"/param/<value>\")\n    def param(value: str) -> str:\n        return value\n\n    @app.route(\"/stream\")\n    def stream() -> Response:\n        def _gen():\n            yield \"Hello \"\n            yield \"World\"\n        return Response(_gen(), mimetype='text/plain')\n\n    @app.errorhandler(409)\n    def generic_http_handler(_: Exception) -> tuple[str, int]:\n        return \"Something Unique\", 409\n\n    @app.errorhandler(404)\n    def not_found_handler(_: Exception) -> tuple[str, int]:\n        return \"Not Found\", 404\n\n    return app\n\n\n@pytest.mark.parametrize(\"path\", [\"/\", \"/sync/\"])\ndef test_index(path: str, app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 200\n    assert b\"index\" in response.data\n\n\ndef test_iri(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/\u2764\ufe0f\")\n    assert \"\ud83d\udc94\".encode() in response.data\n\n\ndef test_options(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.options(\"/\")\n    assert response.status_code == 200\n    assert {method.strip() for method in response.headers[\"Allow\"].split(\",\")} == {\n        \"HEAD\",\n        \"OPTIONS\",\n        \"GET\",\n    }\n\n\ndef test_json(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.post(\"/json/\", json={\"value\": \"json\"})\n    assert response.status_code == 200\n    assert b'{\"value\":\"json\"}\\n' == response.data\n\n\ndef test_implicit_json(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.post(\"/implicit_json/\", json={\"value\": \"json\"})\n    assert response.status_code == 200\n    assert b'{\"value\":\"json\"}\\n' == response.data\n\n\ndef test_werkzeug(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/werkzeug/\")\n    assert response.status_code == 200\n    assert b\"Hello\" == response.data\n\n\ndef test_generic_error(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/error/\")\n    assert response.status_code == 409\n    assert b\"Something Unique\" in response.data\n\n\ndef test_url_defaults(app: Flask) -> None:\n    @app.url_defaults\n    def defaults(_: str, values: dict) -> None:\n        values[\"value\"] = \"hello\"\n\n    with app.test_request_context(\"/\"):\n        assert url_for(\"param\") == \"/param/hello\"\n\n\ndef test_not_found_error(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/not_found/\")\n    assert response.status_code == 404\n    assert b\"Not Found\" in response.data\n\n\ndef test_make_response_str(app: Flask) -> None:\n    response = app.make_response(\"Result\")\n    assert response.status_code == 200\n    assert response.data == b\"Result\"\n\n    response = app.make_response((\"Result\", 200))\n    response = app.make_response((\"Result\", {\"name\": \"value\"}))\n    assert response.status_code == 200\n    assert response.data == b\"Result\"\n    assert response.headers[\"name\"] == \"value\"\n\n    response = app.make_response((\"Result\", 404, {\"name\": \"value\"}))\n    assert response.status_code == 404\n    assert response.data == b\"Result\"\n    assert response.headers[\"name\"] == \"value\"\n\n\ndef test_make_response_response(app: Flask) -> None:\n    response = app.make_response(Response(\"Result\"))\n    assert response.status_code == 200\n    assert response.data == b\"Result\"\n\n    response = app.make_response((Response(\"Result\"), {\"name\": \"value\"}))\n    assert response.status_code == 200\n    assert response.data == b\"Result\"\n    assert response.headers[\"name\"] == \"value\"\n\n    response = app.make_response((Response(\"Result\"), 404, {\"name\": \"value\"}))\n    assert response.status_code == 404\n    assert response.data == b\"Result\"\n    assert response.headers[\"name\"] == \"value\"\n\n\ndef test_make_response_errors(app: Flask) -> None:\n    with pytest.raises(TypeError):\n        app.make_response((\"Result\", {\"name\": \"value\"}, 200))  # type: ignore\n    with pytest.raises(TypeError):\n        app.make_response((\"Result\", {\"name\": \"value\"}, 200, \"a\"))  # type: ignore\n    with pytest.raises(TypeError):\n        app.make_response((\"Result\",))  # type: ignore\n\n\ndef test_root_path(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/\", root_path=\"/bob\")\n    assert response.status_code == 404\n    response = test_client.get(\"/bob/\", root_path=\"/bob\")\n    assert response.status_code == 200\n\n\ndef test_stream(app: Flask) -> None:\n    test_client = app.test_client()\n    response = test_client.get(\"/stream\")\n    assert response.data == b\"Hello World\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_reqctx.py",
        "code": " src/flask/ctx.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_ctx.py",
          "code": "src/quart/ctx.py",
          "code_similarity_score": 0.7406927347183228,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_ctx.py to test the functionality in src/flask/ctx.py through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom unittest.mock import Mock\n\nimport pytest\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.exceptions import BadRequest\n\nfrom flask import Flask, g, request\nfrom flask.ctx import (\n    after_this_request,\n    AppContext,\n    copy_current_app_context,\n    copy_current_request_context,\n    has_app_context,\n    has_request_context,\n    RequestContext,\n)\nfrom flask.testing import make_test_headers_path_and_query_string\nfrom flask.wrappers import Request\n\n\n@pytest.fixture\ndef app():\n    app = Flask(__name__)\n    return app\n\n\n@pytest.fixture\ndef http_scope():\n    return {\n        \"type\": \"http\",\n        \"asgi\": {\"version\": \"3.0\"},\n        \"http_version\": \"1.1\",\n        \"server\": (\"127.0.0.1\", 5000),\n        \"client\": (\"127.0.0.1\", 12345),\n        \"scheme\": \"http\",\n        \"method\": \"GET\",\n        \"root_path\": \"\",\n        \"path\": \"/\",\n        \"raw_path\": b\"/\",\n        \"query_string\": b\"\",\n        \"headers\": [],\n    }\n\n\nasync def test_request_context_match(app, http_scope) -> None:\n    url_adapter = Mock()\n    rule = Mock()\n    rule.endpoint = \"index\"\n    url_adapter.match.return_value = (rule, {\"arg\": \"value\"})\n    app.create_url_adapter = lambda *_: url_adapter  # type: ignore\n    request = Request(\n        http_scope,\n        b\"\",\n        Headers([(\"host\", \"flask.com\")]),\n    )\n    with RequestContext(app, request):\n        assert request.url_rule == rule\n        assert request.view_args == {\"arg\": \"value\"}\n\n\nasync def test_bad_request_if_websocket_route(app, http_scope) -> None:\n    url_adapter = Mock()\n    url_adapter.match.side_effect = BadRequest()\n    app.create_url_adapter = lambda *_: url_adapter  # type: ignore\n    request = Request(\n        http_scope,\n        b\"\",\n        Headers([(\"host\", \"flask.com\")]),\n    )\n    with RequestContext(app, request):\n        assert isinstance(request.routing_exception, BadRequest)\n\n\nasync def test_after_this_request(app, http_scope) -> None:\n    headers, path, query_string = make_test_headers_path_and_query_string(app, \"/\")\n    with RequestContext(\n        app,\n        Request(\n            http_scope,\n            query_string,\n            headers,\n        ),\n    ) as context:\n        after_this_request(lambda response: \"hello\")  # type: ignore\n        assert context._after_request_functions[0](None) == \"hello\"  # type: ignore\n\n\nasync def test_has_request_context(app, http_scope) -> None:\n    headers, path, query_string = make_test_headers_path_and_query_string(app, \"/\")\n    request = Request(\n        http_scope,\n        query_string,\n        headers,\n    )\n    with RequestContext(app, request):\n        assert has_request_context() is True\n        assert has_app_context() is True\n    assert has_request_context() is False\n    assert has_app_context() is False\n\n\nasync def test_has_app_context(app) -> None:\n    with AppContext(app):\n        assert has_app_context() is True\n    assert has_app_context() is False\n\n\nasync def test_copy_current_app_context(app) -> None:\n    @app.route(\"/\")\n    def index() -> str:\n        g.foo = \"bar\"\n\n        @copy_current_app_context\n        async def within_context() -> None:\n            assert g.foo == \"bar\"\n\n        await asyncio.ensure_future(within_context())\n        return \"\"\n\n    test_client = app.test_client()\n    response = await test_client.get(\"/\")\n    assert response.status_code == 200\n\n\ndef test_copy_current_app_context_error() -> None:\n    with pytest.raises(RuntimeError):\n        copy_current_app_context(lambda: None)()\n\n\nasync def test_copy_current_request_context(app) -> None:\n    @app.route(\"/\")\n    def index() -> str:\n        @copy_current_request_context\n        async def within_context() -> None:\n            assert request.path == \"/\"\n\n        await asyncio.ensure_future(within_context())\n        return \"\"\n\n    test_client = app.test_client()\n    response = await test_client.get(\"/\")\n    assert response.status_code == 200\n\n\ndef test_copy_current_request_context_error() -> None:\n    with pytest.raises(RuntimeError):\n        copy_current_request_context(lambda: None)()"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_subclassing.py",
        "code": "src/flask/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_static_hosting.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6523383855819702,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_static_hosting.py to test the functionality in src/flask/app.py\n\nfrom __future__ import annotations\nimport pytest\nfrom pathlib import Path\nfrom flask.app import Flask\n\n@pytest.fixture\ndef app():\n    # Create a Flask app instance with static folder and URL path\n    app = Flask(__name__, static_folder=\"./assets\", static_url_path=\"/static\")\n    return app\n\n@pytest.fixture\ndef client(app):\n    # Create a test client for the Flask app\n    return app.test_client()\n\nasync def test_static_file_serving(client):\n    # Test serving a static file\n    response = await client.get(\"/static/config.cfg\")\n    assert response.status_code == 200\n    data = await response.get_data(as_text=False)\n    expected_data = (Path(__file__).parent / \"assets/config.cfg\").read_bytes()\n    assert data == expected_data\n\nasync def test_static_file_not_found(client):\n    # Test requesting a non-existent static file\n    response = await client.get(\"/static/foo\")\n    assert response.status_code == 404\n\nasync def test_static_file_escape_attempt(client):\n    # Test attempting to escape the static folder\n    response = await client.get(\"/static/../foo\")\n    assert response.status_code == 404\n\n    response = await client.get(\"/static/../assets/config.cfg\")\n    assert response.status_code == 404\n\nasync def test_static_file_non_escaping_path(client):\n    # Test non-escaping path with ..\n    response = await client.get(\"/static/foo/../config.cfg\")\n    assert response.status_code == 200\n    data = await response.get_data(as_text=False)\n    expected_data = (Path(__file__).parent / \"assets/config.cfg\").read_bytes()\n    assert data == expected_data"
        }
      ]
    }
  ]
}