# This test file was generated by adapting tests from tests/test_appctx.py
# to test the functionality in src/quart/app.py through test transplantation.

import pytest
from quart import Quart, url_for, g, jsonify
from quart.globals import _cv_app, _cv_request

@pytest.fixture
def app():
    app = Quart(__name__)
    app.config["SERVER_NAME"] = "localhost"
    app.config["PREFERRED_URL_SCHEME"] = "https"
    return app

@pytest.fixture
async def app_ctx(app):
    async with app.app_context():
        yield

@pytest.fixture
async def request_ctx(app):
    async with app.test_request_context('/'):
        yield

# Test URL generation with SERVER_NAME and PREFERRED_URL_SCHEME set
@pytest.mark.asyncio
async def test_basic_url_generation(app):
    @app.route("/")
    async def index():
        return "Hello"

    async with app.app_context():
        rv = url_for("index")
        assert rv == "https://localhost/"

# Test URL generation raises RuntimeError without SERVER_NAME
@pytest.mark.asyncio
async def test_url_generation_requires_server_name(app):
    app.config.pop("SERVER_NAME", None)
    async with app.app_context():
        with pytest.raises(RuntimeError):
            url_for("index")

# Test URL generation fails without context
def test_url_generation_without_context_fails():
    with pytest.raises(RuntimeError):
        url_for("index")

# Test request context implies app context
@pytest.mark.asyncio
async def test_request_context_means_app_context(app):
    async with app.test_request_context():
        assert _cv_app.get().app is app
    assert _cv_app.get() is None

# Test app context provides current app
@pytest.mark.asyncio
async def test_app_context_provides_current_app(app):
    async with app.app_context():
        assert _cv_app.get().app is app
    assert _cv_app.get() is None

# Test app context teardown
@pytest.mark.asyncio
async def test_app_tearing_down(app):
    cleanup_stuff = []

    @app.teardown_appcontext
    async def cleanup(exception):
        cleanup_stuff.append(exception)

    async with app.app_context():
        pass

    assert cleanup_stuff == [None]

# Test app context teardown with previous exception
@pytest.mark.asyncio
async def test_app_tearing_down_with_previous_exception(app):
    cleanup_stuff = []

    @app.teardown_appcontext
    async def cleanup(exception):
        cleanup_stuff.append(exception)

    try:
        raise Exception("dummy")
    except Exception:
        pass

    async with app.app_context():
        pass

    assert cleanup_stuff == [None]

# Test app context teardown with handled exception by except block
@pytest.mark.asyncio
async def test_app_tearing_down_with_handled_exception_by_except_block(app):
    cleanup_stuff = []

    @app.teardown_appcontext
    async def cleanup(exception):
        cleanup_stuff.append(exception)

    async with app.app_context():
        try:
            raise Exception("dummy")
        except Exception:
            pass

    assert cleanup_stuff == [None]

# Test app context teardown with handled exception by app handler
@pytest.mark.asyncio
async def test_app_tearing_down_with_handled_exception_by_app_handler(app):
    app.config["PROPAGATE_EXCEPTIONS"] = True
    cleanup_stuff = []

    @app.teardown_appcontext
    async def cleanup(exception):
        cleanup_stuff.append(exception)

    @app.route("/")
    async def index():
        raise Exception("dummy")

    @app.errorhandler(Exception)
    async def handler(f):
        return jsonify(str(f))

    async with app.app_context():
        test_client = app.test_client()
        await test_client.get("/")

    assert cleanup_stuff == [None]

# Test app context teardown with unhandled exception
@pytest.mark.asyncio
async def test_app_tearing_down_with_unhandled_exception(app):
    app.config["PROPAGATE_EXCEPTIONS"] = True
    cleanup_stuff = []

    @app.teardown_appcontext
    async def cleanup(exception):
        cleanup_stuff.append(exception)

    @app.route("/")
    async def index():
        raise ValueError("dummy")

    with pytest.raises(ValueError, match="dummy"):
        async with app.app_context():
            test_client = app.test_client()
            await test_client.get("/")

    assert len(cleanup_stuff) == 1
    assert isinstance(cleanup_stuff[0], ValueError)
    assert str(cleanup_stuff[0]) == "dummy"

# Test app context globals methods
@pytest.mark.asyncio
async def test_app_ctx_globals_methods(app, app_ctx):
    # get
    assert g.get("foo") is None
    assert g.get("foo", "bar") == "bar"
    # __contains__
    assert "foo" not in g
    g.foo = "bar"
    assert "foo" in g
    # setdefault
    g.setdefault("bar", "the cake is a lie")
    g.setdefault("bar", "hello world")
    assert g.bar == "the cake is a lie"
    # pop
    assert g.pop("bar") == "the cake is a lie"
    with pytest.raises(KeyError):
        g.pop("bar")
    assert g.pop("bar", "more cake") == "more cake"
    # __iter__
    assert list(g) == ["foo"]
    # __repr__
    assert repr(g) == f"<quart.g of '{app.name}'>"

# Test custom app context globals class
@pytest.mark.asyncio
async def test_custom_app_ctx_globals_class(app):
    class CustomRequestGlobals:
        def __init__(self):
            self.spam = "eggs"

    app.app_ctx_globals_class = CustomRequestGlobals
    async with app.app_context():
        assert await app.render_template_string("{{ g.spam }}") == "eggs"

# Test context reference counts
@pytest.mark.asyncio
async def test_context_refcounts(app):
    called = []

    @app.teardown_request
    async def teardown_req(error=None):
        called.append("request")

    @app.teardown_appcontext
    async def teardown_app(error=None):
        called.append("app")

    @app.route("/")
    async def index():
        async with app.app_context():
            async with app.test_request_context('/'):
                pass

        assert _cv_request.get().request.environ["werkzeug.request"] is not None
        return ""

    test_client = app.test_client()
    res = await test_client.get("/")
    assert res.status_code == 200
    assert await res.get_data() == b""
    assert called == ["request", "app"]

# Test clean pop
@pytest.mark.asyncio
async def test_clean_pop(app):
    app.testing = False
    called = []

    @app.teardown_request
    async def teardown_req(error=None):
        raise ZeroDivisionError

    @app.teardown_appcontext
    async def teardown_app(error=None):
        called.append("TEARDOWN")

    async with app.app_context():
        called.append(app.name)

    assert called == [app.name, "TEARDOWN"]
    assert _cv_app.get() is None