{
  "relevant_pairs": [
    {
      "host_item": {
        "test": "tests/test_app.py",
        "code": "src/quart/app.py"
      },
      "similar_items": [
        {
          "framework": "sanic",
          "test": "tests/test_keep_alive_timeout.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.7302649617195129,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_keep_alive_timeout.py to test src/quart/app.py\n\nimport asyncio\nimport pytest\nfrom quart import Quart, websocket\nfrom quart.testing import QuartClient\n\n# Configuration for testing\nCONFIG_FOR_TESTS = {\"KEEP_ALIVE_TIMEOUT\": 2, \"KEEP_ALIVE\": True}\n\n# Create Quart app instances for testing\napp_reuse = Quart(__name__)\napp_client_timeout = Quart(__name__)\napp_server_timeout = Quart(__name__)\napp_context = Quart(__name__)\n\n# Update app configurations\napp_reuse.config.update(CONFIG_FOR_TESTS)\napp_client_timeout.config.update(CONFIG_FOR_TESTS)\napp_server_timeout.config.update(CONFIG_FOR_TESTS)\napp_context.config.update(CONFIG_FOR_TESTS)\n\n# Define routes for the apps\n@app_reuse.route(\"/1\")\nasync def handler1():\n    return \"OK\"\n\n@app_client_timeout.route(\"/1\")\nasync def handler2():\n    return \"OK\"\n\n@app_server_timeout.route(\"/1\")\nasync def handler3():\n    return \"OK\"\n\n@app_context.route(\"/ctx\", methods=[\"POST\"])\nasync def set_ctx():\n    websocket._get_current_object()._quart_ctx.ctx.foo = \"hello\"\n    return \"OK\"\n\n@app_context.route(\"/ctx\", methods=[\"GET\"])\nasync def get_ctx():\n    return websocket._get_current_object()._quart_ctx.ctx.foo\n\n@pytest.mark.asyncio\nasync def test_keep_alive_timeout_reuse():\n    \"\"\"Test that the server and client can reuse the connection when both have longer keep-alive timeouts.\"\"\"\n    client = QuartClient(app_reuse)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.get(\"/1\", headers=headers)\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n        await asyncio.sleep(1)\n\n        response = await client.get(\"/1\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n@pytest.mark.asyncio\nasync def test_keep_alive_client_timeout():\n    \"\"\"Test that the client creates a new connection when its keep-alive timeout is shorter than the server's.\"\"\"\n    client = QuartClient(app_client_timeout)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.get(\"/1\", headers=headers)\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n        await asyncio.sleep(2)\n\n        response = await client.get(\"/1\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n@pytest.mark.asyncio\nasync def test_keep_alive_server_timeout():\n    \"\"\"Test that the client handles server timeout by either resetting connection or creating a new one.\"\"\"\n    client = QuartClient(app_server_timeout)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.get(\"/1\", headers=headers)\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n        await asyncio.sleep(3)\n\n        response = await client.get(\"/1\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n@pytest.mark.asyncio\nasync def test_keep_alive_connection_context():\n    \"\"\"Test that the connection context is maintained across requests.\"\"\"\n    client = QuartClient(app_context)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.post(\"/ctx\", headers=headers)\n        assert response.status_code == 200\n\n        await asyncio.sleep(1)\n\n        response = await client.get(\"/ctx\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"hello\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_asgi.py",
        "code": "src/quart/asgi.py"
      },
      "similar_items": [
        {
          "framework": "sanic",
          "test": "tests/test_create_task.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.6864539384841919,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_create_task.py to src/quart/asgi.py\n\nimport asyncio\nfrom threading import Event\n\nimport pytest\nfrom quart import Quart, websocket\nfrom quart.wrappers import Response\n\nfrom src.quart.asgi import ASGIHTTPConnection, ASGIWebsocketConnection, ASGILifespan\n\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n    return app\n\n\ndef test_asgi_http_connection(app):\n    e = Event()\n\n    async def coro():\n        await asyncio.sleep(0.05)\n        e.set()\n\n    @app.route(\"/early\")\n    async def not_set():\n        return Response(str(e.is_set()))\n\n    @app.route(\"/late\")\n    async def set():\n        await asyncio.sleep(0.1)\n        return Response(str(e.is_set()))\n\n    app.add_background_task(coro)\n\n    test_client = app.test_client()\n    response = test_client.get(\"/early\")\n    assert response.data == b\"False\"\n\n    app.add_background_task(coro)\n    response = test_client.get(\"/late\")\n    assert response.data == b\"True\"\n\n\ndef test_asgi_websocket_connection(app):\n    e = Event()\n\n    async def coro():\n        e.set()\n\n    @app.websocket(\"/ws\")\n    async def ws():\n        await websocket.accept()\n        await websocket.send(str(e.is_set()))\n\n    @app.before_serving\n    async def setup():\n        app.add_background_task(coro)\n\n    test_client = app.test_client()\n    with test_client.websocket(\"/ws\") as ws:\n        response = ws.receive()\n        assert response == \"True\"\n\n\ndef test_asgi_lifespan(app):\n    e = Event()\n\n    async def coro():\n        e.set()\n\n    @app.before_serving\n    async def setup():\n        app.add_background_task(coro)\n\n    @app.route(\"/\")\n    async def index():\n        return Response(str(e.is_set()))\n\n    test_client = app.test_client()\n    response = test_client.get(\"/\")\n    assert response.data == b\"True\"\n\n\ndef test_create_named_task_fails_outside_app(app):\n    async def dummy(): ...\n\n    message = \"Cannot name task outside of a running application\"\n    with pytest.raises(RuntimeError, match=message):\n        app.add_background_task(dummy, name=\"dummy_task\")\n    assert not app._task_registry\n\n    message = 'Registered task named \"dummy_task\" not found.'\n    with pytest.raises(KeyError, match=message):\n        app.get_task(\"dummy_task\")"
        },
        {
          "framework": "sanic",
          "test": "tests/test_cancellederror.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.7236013412475586,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_cancellederror.py to test src/quart/asgi.py\n\nimport asyncio\nimport pytest\nfrom quart import Quart, jsonify\nfrom quart.asgi import ASGIHTTPConnection\nfrom hypercorn.typing import HTTPScope, ASGIReceiveCallable, ASGISendCallable\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n\n    @app.route('/')\n    async def handler():\n        raise asyncio.CancelledError(\"STOP!!\")\n\n    @app.errorhandler(asyncio.CancelledError)\n    async def handle_cancel(error):\n        return jsonify({\"message\": str(error)}), 418\n\n    return app\n\n@pytest.mark.asyncio\nasync def test_can_raise_in_handler(app):\n    test_client = app.test_client()\n    response = await test_client.get('/')\n    assert response.status_code == 418\n    assert (await response.get_json())[\"message\"] == \"STOP!!\"\n\n@pytest.mark.asyncio\nasync def test_asgi_http_connection_cancelled_error(app):\n    scope = HTTPScope(\n        type=\"http\",\n        asgi={\"version\": \"3.0\", \"spec_version\": \"2.1\"},\n        method=\"GET\",\n        scheme=\"http\",\n        path=\"/\",\n        query_string=b\"\",\n        headers=[],\n        client=(\"127.0.0.1\", 12345),\n        server=(\"127.0.0.1\", 8000),\n        extensions={},\n        http_version=\"1.1\",\n    )\n\n    async def mock_receive() -> ASGIReceiveCallable:\n        return {\"type\": \"http.request\"}\n\n    async def mock_send(message: ASGISendCallable) -> None:\n        assert message[\"type\"] == \"http.response.start\"\n        assert message[\"status\"] == 418\n\n    connection = ASGIHTTPConnection(app, scope)\n    await connection(mock_receive, mock_send)"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_background_tasks.py",
        "code": "src/quart/app.py"
      },
      "similar_items": [
        {
          "framework": "sanic",
          "test": "tests/test_cancellederror.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.7236013412475586,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_cancellederror.py to src/quart/app.py\n\nimport pytest\nfrom asyncio import CancelledError\nfrom quart import Quart, request, jsonify\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n\n    @app.route(\"/\", methods=[\"GET\"])\n    async def handler():\n        # Simulate a scenario where a CancelledError might be raised\n        raise CancelledError(\"STOP!!\")\n\n    @app.errorhandler(CancelledError)\n    async def handle_cancel(error):\n        # Handle the CancelledError and return a JSON response\n        return jsonify({\"message\": str(error)}), 418\n\n    return app\n\n@pytest.mark.asyncio\nasync def test_cancelled_error_handling(app):\n    # Test to ensure that CancelledError is properly handled\n    test_client = app.test_client()\n    response = await test_client.get(\"/\")\n    \n    # Assert that the response status code is 418\n    assert response.status_code == 418\n    # Assert that the response JSON contains the correct message\n    assert (await response.get_json())[\"message\"] == \"STOP!!\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_basic.py",
        "code": "src/quart/app.py"
      },
      "similar_items": [
        {
          "framework": "flask",
          "test": "tests/test_basic.py",
          "code": "src/flask/app.py",
          "code_similarity_score": 0.7030597925186157,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_basic.py\n# to test the functionality in src/quart/app.py through test transplantation.\n\nimport pytest\nfrom quart import Quart, jsonify, request, session, g, url_for\nfrom quart.wrappers import Response\nfrom werkzeug.exceptions import BadRequest, Forbidden, NotFound\nfrom werkzeug.routing import BuildError\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n    app.secret_key = 'test_key'\n    return app\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\ndef test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def index():\n        return \"Hello World\"\n\n    rv = client.options(\"/\")\n    assert sorted(rv.headers[\"Allow\"].split(\", \")) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"\n\ndef test_method_route(app, client):\n    @app.get(\"/\")\n    async def hello():\n        return \"Hello\"\n\n    response = client.get(\"/\")\n    assert response.data == b\"Hello\"\n\ndef test_provide_automatic_options_attr(app):\n    async def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = client.options(\"/\")\n    assert rv.status_code == 405\n\ndef test_request_dispatching(app, client):\n    @app.route(\"/\")\n    async def index():\n        return request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    async def more():\n        return request.method\n\n    response = client.get(\"/\")\n    assert response.data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.headers[\"Allow\"].split(\", \")) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.headers[\"Allow\"].split(\", \")) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n\ndef test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    async def set_value():\n        session[\"value\"] = (await request.form)[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    async def get_value():\n        return session.get(\"value\", \"None\")\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"\n\ndef test_flashes(app, client):\n    @app.route(\"/flash\")\n    async def flash_message():\n        session.modified = False\n        session[\"message\"] = \"Hello\"\n        return \"\"\n\n    @app.route(\"/get_flash\")\n    async def get_flash():\n        return session.get(\"message\", \"\")\n\n    client.get(\"/flash\")\n    assert client.get(\"/get_flash\").data == b\"Hello\"\n\ndef test_error_handling(app, client):\n    @app.errorhandler(404)\n    async def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    async def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    async def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    async def index():\n        raise NotFound()\n\n    @app.route(\"/error\")\n    async def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    async def error2():\n        raise Forbidden()\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data\n\ndef test_url_generation(app):\n    @app.route(\"/hello/<name>\", methods=[\"POST\"])\n    async def hello(name):\n        return f\"Hello {name}\"\n\n    with app.test_request_context():\n        assert url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n        assert url_for(\"hello\", name=\"test x\", _external=True) == \"http://localhost/hello/test%20x\"\n\ndef test_static_files(app, client):\n    app.static_folder = \"static\"\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()"
        },
        {
          "framework": "sanic",
          "test": "tests/test_tasks.py",
          "code": [
            "sanic/app.py",
            "sanic/application/state.py"
          ],
          "code_similarity_score": 0.6785894632339478,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_tasks.py in the donor code\n# to test the functionality in src/quart/app.py in the host code through test transplantation.\n\nimport asyncio\nfrom asyncio.tasks import Task\nfrom unittest.mock import Mock, call\n\nimport pytest\n\nfrom quart.app import Quart\nfrom quart.testing import TestClientProtocol\n\ntry:\n    from unittest.mock import AsyncMock\nexcept ImportError:\n    from tests.asyncmock import AsyncMock  # type: ignore\n\npytestmark = pytest.mark.asyncio\n\n# Dummy async function to simulate background tasks\nasync def dummy(n=0):\n    for _ in range(n):\n        await asyncio.sleep(1)\n    return True\n\n# Fixture to create a Quart app instance for testing\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n    return app\n\n# Test to ensure that adding a task returns a Task instance\nasync def test_add_task_returns_task(app: Quart):\n    task = app.add_background_task(dummy)\n\n    assert isinstance(task, Task)\n    assert len(app.background_tasks) == 1\n\n# Test to ensure that adding a named task registers it correctly\nasync def test_add_task_with_name(app: Quart):\n    task = app.add_background_task(dummy, name=\"dummy\")\n\n    assert isinstance(task, Task)\n    assert len(app.background_tasks) == 1\n    assert task in app.background_tasks\n\n# Test to ensure that a task can be cancelled\nasync def test_cancel_task(app: Quart):\n    task = app.add_background_task(dummy, name=\"dummy\")\n\n    assert task\n    assert not task.done()\n    assert not task.cancelled()\n\n    await asyncio.sleep(0.1)\n\n    assert not task.done()\n    assert not task.cancelled()\n\n    task.cancel()\n\n    assert task.cancelled()\n\n# Test to ensure that completed tasks are purged from the registry\nasync def test_purge_tasks(app: Quart):\n    task = app.add_background_task(dummy, name=\"dummy\")\n\n    task.cancel()\n\n    assert len(app.background_tasks) == 1\n\n    app.background_tasks.discard(task)\n\n    assert len(app.background_tasks) == 0\n\n# Test to ensure that tasks are shut down properly when the app stops\ndef test_shutdown_tasks_on_app_stop():\n    class TestQuart(Quart):\n        shutdown_tasks = Mock()\n\n    app = TestQuart(__name__)\n\n    @app.route(\"/\")\n    async def handler():\n        return \"Hello, World!\"\n\n    client: TestClientProtocol = app.test_client()\n    client.get(\"/\")\n\n    app.shutdown_tasks.call_args == [\n        call(timeout=0),\n        call(15.0),\n    ]"
        },
        {
          "framework": "flask",
          "test": "tests/test_subclassing.py",
          "code": "src/flask/app.py",
          "code_similarity_score": 0.6740709543228149,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by transplanting tests from tests/test_subclassing.py\n# to test the functionality in src/quart/app.py\n\nfrom io import StringIO\nimport asyncio\nimport pytest\nfrom quart import Quart\n\n# Define a subclass of Quart to suppress exception logging\nclass SuppressedQuart(Quart):\n    def log_exception(self, exc_info):\n        pass\n\n@pytest.fixture\ndef app():\n    # Create an instance of the SuppressedQuart app\n    app = SuppressedQuart(__name__)\n\n    # Define a route that raises an exception\n    @app.route(\"/\")\n    async def index():\n        raise Exception(\"test\")\n\n    return app\n\n@pytest.mark.asyncio\nasync def test_suppressed_exception_logging(app):\n    # Create a StringIO object to capture output\n    out = StringIO()\n\n    # Use the test client to make a request to the route that raises an exception\n    async with app.test_client() as client:\n        response = await client.get(\"/\", errors_stream=out)\n\n    # Assert that the status code is 500, indicating an internal server error\n    assert response.status_code == 500\n\n    # Assert that the response data contains \"Internal Server Error\"\n    assert b\"Internal Server Error\" in (await response.get_data())\n\n    # Assert that no exception details were logged to the output\n    assert not out.getvalue()"
        },
        {
          "framework": "flask",
          "test": "tests/test_regression.py",
          "code": "src/flask/app.py",
          "code_similarity_score": 0.6740142107009888,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_regression.py\n# to test the functionality in src/quart/app.py through test transplantation.\n\nimport pytest\nfrom quart import Quart, abort, redirect, url_for\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    async def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    async def index():\n        raise abort(redirect(url_for(\"test\")))\n\n    @app.route(\"/test\")\n    async def test():\n        raise Foo()\n\n    return app\n\n@pytest.mark.asyncio\nasync def test_aborting(app):\n    # Create a test client using the Quart test client\n    async with app.test_client() as client:\n        # Test the redirect from the index route\n        response = await client.get(\"/\")\n        location_parts = response.headers[\"Location\"].rpartition(\"/\")\n\n        if location_parts[0]:\n            # For older Werkzeug that used absolute redirects.\n            assert location_parts[0] == \"http://localhost\"\n\n        assert location_parts[2] == \"test\"\n\n        # Test the custom error handler for the Foo exception\n        response = await client.get(\"/test\")\n        assert response.data == b\"42\""
        },
        {
          "framework": "flask",
          "test": "tests/test_appctx.py",
          "code": "src/flask/ctx.py",
          "code_similarity_score": 0.6835055351257324,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_appctx.py\n# to test the functionality in src/quart/app.py through test transplantation.\n\nimport pytest\nfrom quart import Quart, url_for, g, jsonify\nfrom quart.globals import _cv_app, _cv_request\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n    return app\n\n@pytest.fixture\nasync def app_ctx(app):\n    async with app.app_context():\n        yield\n\n@pytest.fixture\nasync def request_ctx(app):\n    async with app.test_request_context('/'):\n        yield\n\n# Test URL generation with SERVER_NAME and PREFERRED_URL_SCHEME set\n@pytest.mark.asyncio\nasync def test_basic_url_generation(app):\n    @app.route(\"/\")\n    async def index():\n        return \"Hello\"\n\n    async with app.app_context():\n        rv = url_for(\"index\")\n        assert rv == \"https://localhost/\"\n\n# Test URL generation raises RuntimeError without SERVER_NAME\n@pytest.mark.asyncio\nasync def test_url_generation_requires_server_name(app):\n    app.config.pop(\"SERVER_NAME\", None)\n    async with app.app_context():\n        with pytest.raises(RuntimeError):\n            url_for(\"index\")\n\n# Test URL generation fails without context\ndef test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        url_for(\"index\")\n\n# Test request context implies app context\n@pytest.mark.asyncio\nasync def test_request_context_means_app_context(app):\n    async with app.test_request_context():\n        assert _cv_app.get().app is app\n    assert _cv_app.get() is None\n\n# Test app context provides current app\n@pytest.mark.asyncio\nasync def test_app_context_provides_current_app(app):\n    async with app.app_context():\n        assert _cv_app.get().app is app\n    assert _cv_app.get() is None\n\n# Test app context teardown\n@pytest.mark.asyncio\nasync def test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    async with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n# Test app context teardown with previous exception\n@pytest.mark.asyncio\nasync def test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    async with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\n# Test app context teardown with handled exception by except block\n@pytest.mark.asyncio\nasync def test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    async with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\n# Test app context teardown with handled exception by app handler\n@pytest.mark.asyncio\nasync def test_app_tearing_down_with_handled_exception_by_app_handler(app):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    async def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    async def handler(f):\n        return jsonify(str(f))\n\n    async with app.app_context():\n        test_client = app.test_client()\n        await test_client.get(\"/\")\n\n    assert cleanup_stuff == [None]\n\n# Test app context teardown with unhandled exception\n@pytest.mark.asyncio\nasync def test_app_tearing_down_with_unhandled_exception(app):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    async def index():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        async with app.app_context():\n            test_client = app.test_client()\n            await test_client.get(\"/\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"\n\n# Test app context globals methods\n@pytest.mark.asyncio\nasync def test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert g.get(\"foo\") is None\n    assert g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in g\n    g.foo = \"bar\"\n    assert \"foo\" in g\n    # setdefault\n    g.setdefault(\"bar\", \"the cake is a lie\")\n    g.setdefault(\"bar\", \"hello world\")\n    assert g.bar == \"the cake is a lie\"\n    # pop\n    assert g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        g.pop(\"bar\")\n    assert g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(g) == [\"foo\"]\n    # __repr__\n    assert repr(g) == f\"<quart.g of '{app.name}'>\"\n\n# Test custom app context globals class\n@pytest.mark.asyncio\nasync def test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    async with app.app_context():\n        assert await app.render_template_string(\"{{ g.spam }}\") == \"eggs\"\n\n# Test context reference counts\n@pytest.mark.asyncio\nasync def test_context_refcounts(app):\n    called = []\n\n    @app.teardown_request\n    async def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    async def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    async def index():\n        async with app.app_context():\n            async with app.test_request_context('/'):\n                pass\n\n        assert _cv_request.get().request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    test_client = app.test_client()\n    res = await test_client.get(\"/\")\n    assert res.status_code == 200\n    assert await res.get_data() == b\"\"\n    assert called == [\"request\", \"app\"]\n\n# Test clean pop\n@pytest.mark.asyncio\nasync def test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    async def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    async def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    async with app.app_context():\n        called.append(app.name)\n\n    assert called == [app.name, \"TEARDOWN\"]\n    assert _cv_app.get() is None"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_ctx.py",
        "code": "src/quart/ctx.py"
      },
      "similar_items": [
        {
          "framework": "flask",
          "test": "tests/test_reqctx.py",
          "code": " src/flask/ctx.py",
          "code_similarity_score": 0.7406929135322571,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_reqctx.py to test src/quart/ctx.py\n\nimport pytest\nfrom quart import Quart, request, has_request_context, has_app_context\nfrom quart.ctx import RequestContext, AppContext\nfrom quart.sessions import SecureCookieSessionInterface, SessionInterface\nfrom quart.globals import _cv_request, _cv_app\n\n# Test to ensure that the request context is properly torn down\ndef test_teardown_on_pop():\n    app = Quart(__name__)\n    buffer = []\n\n    @app.teardown_request\n    async def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]\n\n# Test to ensure that the request context is properly torn down with a previous exception\ndef test_teardown_with_previous_exception():\n    app = Quart(__name__)\n    buffer = []\n\n    @app.teardown_request\n    async def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]\n\n# Test to ensure that the request context is properly torn down with a handled exception\ndef test_teardown_with_handled_exception():\n    app = Quart(__name__)\n    buffer = []\n\n    @app.teardown_request\n    async def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]\n\n# Test to ensure that the request context is properly bound\ndef test_context_binding():\n    app = Quart(__name__)\n\n    @app.route(\"/\")\n    async def index():\n        return f\"Hello {request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    async def meh():\n        return request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not request\n\n# Test to ensure that the request context is properly tested\ndef test_context_test():\n    app = Quart(__name__)\n    assert not request\n    assert not has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert request\n        assert has_request_context()\n    finally:\n        ctx.pop()\n\n# Test to ensure that the request context is manually bound\ndef test_manual_context_binding():\n    app = Quart(__name__)\n\n    @app.route(\"/\")\n    async def index():\n        return f\"Hello {request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n# Test to ensure that the session error pops the context\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        async def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomQuart(Quart):\n        session_interface = FailingSessionInterface()\n\n    app = CustomQuart(__name__)\n\n    @app.route(\"/\")\n    async def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not request\n    assert not has_app_context()\n\n# Test to ensure that the session dynamic cookie name works\ndef test_session_dynamic_cookie_name():\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomQuart(Quart):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomQuart(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    async def set():\n        request.session[\"value\"] = request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    async def get():\n        v = request.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    async def set_dynamic_cookie():\n        request.session[\"value\"] = request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    async def get_dynamic_cookie():\n        v = request.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\""
        },
        {
          "framework": "flask",
          "test": "tests/test_appctx.py",
          "code": "src/flask/ctx.py",
          "code_similarity_score": 0.6835055351257324,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_appctx.py to test src/quart/ctx.py\n\nimport pytest\nfrom quart import Quart, url_for, g\nfrom quart.ctx import AppContext, RequestContext, has_app_context, has_request_context\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    async def index():\n        return \"Hello, World!\"\n\n    return app\n\ndef test_basic_url_generation(app):\n    \"\"\"Test URL generation within an app context.\"\"\"\n    with app.app_context():\n        rv = url_for(\"index\")\n        assert rv == \"https://localhost/\"\n\ndef test_url_generation_requires_server_name(app):\n    \"\"\"Test URL generation raises error without SERVER_NAME.\"\"\"\n    app.config.pop(\"SERVER_NAME\", None)\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            url_for(\"index\")\n\ndef test_url_generation_without_context_fails():\n    \"\"\"Test URL generation fails without an app context.\"\"\"\n    with pytest.raises(RuntimeError):\n        url_for(\"index\")\n\ndef test_request_context_means_app_context(app):\n    \"\"\"Test that a request context implies an app context.\"\"\"\n    with app.test_request_context():\n        assert has_app_context()\n    assert not has_app_context()\n\ndef test_app_context_provides_current_app(app):\n    \"\"\"Test that the app context provides the current app.\"\"\"\n    with app.app_context():\n        assert has_app_context()\n    assert not has_app_context()\n\ndef test_app_tearing_down(app):\n    \"\"\"Test app context teardown.\"\"\"\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\ndef test_app_tearing_down_with_previous_exception(app):\n    \"\"\"Test app context teardown with a previous exception.\"\"\"\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]\n\ndef test_app_tearing_down_with_handled_exception_by_except_block(app):\n    \"\"\"Test app context teardown with handled exception.\"\"\"\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]\n\ndef test_app_tearing_down_with_unhandled_exception(app):\n    \"\"\"Test app context teardown with unhandled exception.\"\"\"\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    async def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/error\")\n    async def error():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        with app.test_client() as client:\n            client.get(\"/error\")\n\n    assert len(cleanup_stuff) == 1\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"\n\ndef test_app_ctx_globals_methods(app):\n    \"\"\"Test methods on the app context globals.\"\"\"\n    with app.app_context():\n        # get\n        assert g.get(\"foo\") is None\n        assert g.get(\"foo\", \"bar\") == \"bar\"\n        # __contains__\n        assert \"foo\" not in g\n        g.foo = \"bar\"\n        assert \"foo\" in g\n        # setdefault\n        g.setdefault(\"bar\", \"the cake is a lie\")\n        g.setdefault(\"bar\", \"hello world\")\n        assert g.bar == \"the cake is a lie\"\n        # pop\n        assert g.pop(\"bar\") == \"the cake is a lie\"\n        with pytest.raises(KeyError):\n            g.pop(\"bar\")\n        assert g.pop(\"bar\", \"more cake\") == \"more cake\"\n        # __iter__\n        assert list(g) == [\"foo\"]\n        # __repr__\n        assert repr(g) == \"<quart.g of 'quart_test'>\"\n\ndef test_custom_app_ctx_globals_class(app):\n    \"\"\"Test using a custom app context globals class.\"\"\"\n    class CustomAppGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomAppGlobals\n    with app.app_context():\n        assert g.spam == \"eggs\"\n\ndef test_context_refcounts(app):\n    \"\"\"Test reference counting for contexts.\"\"\"\n    called = []\n\n    @app.teardown_request\n    async def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    async def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    async def index():\n        with app.app_context():\n            with app.test_request_context():\n                pass\n        return \"\"\n\n    with app.test_client() as client:\n        res = client.get(\"/\")\n        assert res.status_code == 200\n        assert res.data == b\"\"\n        assert called == [\"request\", \"app\"]\n\ndef test_clean_pop(app):\n    \"\"\"Test clean pop of app context.\"\"\"\n    called = []\n\n    @app.teardown_request\n    async def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    async def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(app.name)\n\n    assert called == [\"quart_test\", \"TEARDOWN\"]\n    assert not has_app_context()"
        },
        {
          "framework": "sanic",
          "test": "tests/test_handler.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.7270543575286865,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_handler.py\n# to test the functionality in src/quart/ctx.py through test transplantation.\n\nimport pytest\nfrom quart import Quart, websocket\nfrom quart.ctx import RequestContext, WebsocketContext, AppContext\nfrom quart.globals import _cv_request, _cv_websocket, _cv_app\nfrom quart.testing import QuartClient\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n\n    @app.route('/')\n    async def index():\n        return 'Hello, World!'\n\n    @app.websocket('/ws')\n    async def ws():\n        await websocket.accept()\n        await websocket.send('Hello, Websocket!')\n        await websocket.close()\n\n    return app\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\n@pytest.mark.asyncio\nasync def test_request_context(app, client: QuartClient):\n    # Test the RequestContext push and pop\n    async with app.test_request_context('/'):\n        assert _cv_request.get() is not None\n        assert isinstance(_cv_request.get(), RequestContext)\n    assert _cv_request.get() is None\n\n@pytest.mark.asyncio\nasync def test_websocket_context(app, client: QuartClient):\n    # Test the WebsocketContext push and pop\n    async with app.test_websocket('/ws'):\n        assert _cv_websocket.get() is not None\n        assert isinstance(_cv_websocket.get(), WebsocketContext)\n    assert _cv_websocket.get() is None\n\n@pytest.mark.asyncio\nasync def test_app_context(app):\n    # Test the AppContext push and pop\n    async with app.app_context():\n        assert _cv_app.get() is not None\n        assert isinstance(_cv_app.get(), AppContext)\n    assert _cv_app.get() is None\n\n@pytest.mark.asyncio\nasync def test_after_this_request(app, client: QuartClient):\n    # Test the after_this_request functionality\n    operations = []\n\n    @app.route('/after')\n    async def after():\n        @app.after_this_request\n        def after_request(response):\n            operations.append(2)\n            return response\n\n        operations.append(1)\n        return 'After request'\n\n    response = await client.get('/after')\n    assert response.status_code == 200\n    assert operations == [1, 2]\n\n@pytest.mark.asyncio\nasync def test_after_this_websocket(app):\n    # Test the after_this_websocket functionality\n    operations = []\n\n    @app.websocket('/after_ws')\n    async def after_ws():\n        @app.after_this_websocket\n        def after_websocket(response=None):\n            operations.append(2)\n            return response\n\n        operations.append(1)\n        await websocket.accept()\n        await websocket.close()\n\n    async with app.test_websocket('/after_ws'):\n        pass\n\n    assert operations == [1, 2]"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_static_hosting.py",
        "code": "src/quart/app.py"
      },
      "similar_items": [
        {
          "framework": "sanic",
          "test": "tests/test_cancellederror.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.7236013412475586,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_cancellederror.py to test functionality in src/quart/app.py through test transplantation.\n\nimport pytest\nfrom asyncio import CancelledError\nfrom quart import Quart, request, jsonify\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n\n    @app.route(\"/\")\n    async def handler():\n        # Simulate a situation where a CancelledError might be raised\n        raise CancelledError(\"STOP!!\")\n\n    @app.errorhandler(CancelledError)\n    async def handle_cancel(error):\n        # Handle the CancelledError and return a JSON response\n        return jsonify({\"message\": str(error)}), 418\n\n    return app\n\n@pytest.mark.asyncio\nasync def test_can_raise_in_handler(app):\n    # Test that a CancelledError is properly handled and returns the expected response\n    test_client = app.test_client()\n    response = await test_client.get(\"/\")\n    assert response.status_code == 418\n    assert (await response.get_json())[\"message\"] == \"STOP!!\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_sync.py",
        "code": "src/quart/app.py"
      },
      "similar_items": [
        {
          "framework": "sanic",
          "test": "tests/test_keep_alive_timeout.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.7302649617195129,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_keep_alive_timeout.py to test src/quart/app.py through test transplantation.\n\nimport asyncio\nimport pytest\nfrom quart import Quart, websocket\nfrom quart.testing import QuartClient\n\n# Configuration for testing keep-alive timeout\nCONFIG_FOR_TESTS = {\"KEEP_ALIVE_TIMEOUT\": 2, \"KEEP_ALIVE\": True}\n\n# Initialize Quart app instances for different test scenarios\nkeep_alive_timeout_app_reuse = Quart(__name__)\nkeep_alive_app_client_timeout = Quart(__name__)\nkeep_alive_app_server_timeout = Quart(__name__)\nkeep_alive_app_context = Quart(__name__)\n\n# Update app configurations\nkeep_alive_timeout_app_reuse.config.update(CONFIG_FOR_TESTS)\nkeep_alive_app_client_timeout.config.update(CONFIG_FOR_TESTS)\nkeep_alive_app_server_timeout.config.update(CONFIG_FOR_TESTS)\nkeep_alive_app_context.config.update(CONFIG_FOR_TESTS)\n\n# Define routes for the apps\n@keep_alive_timeout_app_reuse.route(\"/1\")\nasync def handler1():\n    return \"OK\"\n\n@keep_alive_app_client_timeout.route(\"/1\")\nasync def handler2():\n    return \"OK\"\n\n@keep_alive_app_server_timeout.route(\"/1\")\nasync def handler3():\n    return \"OK\"\n\n@keep_alive_app_context.route(\"/ctx\", methods=[\"POST\"])\nasync def set_ctx():\n    websocket._get_current_object().ctx.foo = \"hello\"\n    return \"OK\"\n\n@keep_alive_app_context.route(\"/ctx\", methods=[\"GET\"])\nasync def get_ctx():\n    return websocket._get_current_object().ctx.foo\n\n@pytest.mark.asyncio\nasync def test_keep_alive_timeout_reuse():\n    \"\"\"Test that the server and client successfully reuse the connection when both have longer keep-alive timeouts.\"\"\"\n    client = QuartClient(keep_alive_timeout_app_reuse)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.get(\"/1\", headers=headers)\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n        await asyncio.sleep(1)\n\n        response = await client.get(\"/1\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n@pytest.mark.asyncio\nasync def test_keep_alive_client_timeout():\n    \"\"\"Test that the client creates a new connection when its keep-alive timeout is shorter than the server's.\"\"\"\n    client = QuartClient(keep_alive_app_client_timeout)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.get(\"/1\", headers=headers)\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n        await asyncio.sleep(2)\n\n        response = await client.get(\"/1\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n@pytest.mark.asyncio\nasync def test_keep_alive_server_timeout():\n    \"\"\"Test that the client handles server connection reset when the server's keep-alive timeout is shorter.\"\"\"\n    client = QuartClient(keep_alive_app_server_timeout)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.get(\"/1\", headers=headers)\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n        await asyncio.sleep(3)\n\n        response = await client.get(\"/1\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"OK\"\n\n@pytest.mark.asyncio\nasync def test_keep_alive_connection_context():\n    \"\"\"Test that the connection context is maintained across requests.\"\"\"\n    client = QuartClient(keep_alive_app_context)\n    async with client:\n        headers = {\"Connection\": \"keep-alive\"}\n        response = await client.post(\"/ctx\", headers=headers)\n        assert response.status_code == 200\n\n        await asyncio.sleep(1)\n\n        response = await client.get(\"/ctx\")\n        assert response.status_code == 200\n        assert await response.get_data(as_text=True) == \"hello\""
        },
        {
          "framework": "sanic",
          "test": "tests/test_cancellederror.py",
          "code": "sanic/app.py",
          "code_similarity_score": 0.7236013412475586,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_cancellederror.py to test functionality in src/quart/app.py through test transplantation.\n\nimport pytest\nfrom asyncio import CancelledError\nfrom quart import Quart, request, jsonify\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n\n    @app.route('/')\n    async def handler():\n        # Simulate a scenario where a CancelledError might be raised\n        raise CancelledError(\"STOP!!\")\n\n    @app.errorhandler(CancelledError)\n    async def handle_cancel(error):\n        # Handle the CancelledError and return a JSON response with status 418\n        return jsonify({\"message\": str(error)}), 418\n\n    return app\n\n@pytest.mark.asyncio\nasync def test_can_raise_in_handler(app):\n    # Use Quart's test client to simulate a request to the handler\n    test_client = app.test_client()\n    response = await test_client.get('/')\n\n    # Assert that the response status code is 418\n    assert response.status_code == 418\n\n    # Assert that the response JSON contains the expected message\n    json_data = await response.get_json()\n    assert json_data[\"message\"] == \"STOP!!\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_templating.py",
        "code": "src/quart/templating.py"
      },
      "similar_items": [
        {
          "framework": "flask",
          "test": "tests/test_templating.py",
          "code": "src/flask/templating.py",
          "code_similarity_score": 0.6990987062454224,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_templating.py to test src/quart/templating.py\n\nimport pytest\nfrom quart import Quart, render_template, render_template_string, stream_template_string\nfrom jinja2 import TemplateNotFound\nfrom markupsafe import Markup\n\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n    app.config['TESTING'] = True\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"context_template.html\", value=23)\n\n    return app\n\n@pytest.fixture\ndef client(app):\n    return app.test_client()\n\n@pytest.mark.asyncio\nasync def test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"context_template.html\", value=23)\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"\n\n@pytest.mark.asyncio\nasync def test_original_win(app, client):\n    @app.route(\"/\")\n    async def index():\n        return await render_template_string(\"{{ config }}\", config=42)\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"42\"\n\n@pytest.mark.asyncio\nasync def test_simple_stream(app, client):\n    @app.route(\"/\")\n    async def index():\n        return await stream_template_string(\"{{ config }}\", config=42)\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"42\"\n\n@pytest.mark.asyncio\nasync def test_request_less_rendering(app):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = await render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n@pytest.mark.asyncio\nasync def test_standard_context(app, client):\n    @app.route(\"/\")\n    async def index():\n        app_ctx = app.app_context()\n        app_ctx.push()\n        app_ctx.g.foo = 23\n        app_ctx.session[\"test\"] = \"aha\"\n        return await render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = await client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n@pytest.mark.asyncio\nasync def test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = (await client.get(\"/\")).data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n@pytest.mark.asyncio\nasync def test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = (await client.get(\"/\")).data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n@pytest.mark.asyncio\nasync def test_escaping_without_template_filename(app):\n    assert await render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert await render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n@pytest.mark.asyncio\nasync def test_macros(app):\n    macro = await app.jinja_env.get_template(\"_macro.html\").module.hello\n    assert macro(\"World\") == \"Hello World!\"\n\n@pytest.mark.asyncio\nasync def test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n@pytest.mark.asyncio\nasync def test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n@pytest.mark.asyncio\nasync def test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n@pytest.mark.asyncio\nasync def test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n@pytest.mark.asyncio\nasync def test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n@pytest.mark.asyncio\nasync def test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n@pytest.mark.asyncio\nasync def test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n@pytest.mark.asyncio\nasync def test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n@pytest.mark.asyncio\nasync def test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n@pytest.mark.asyncio\nasync def test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n@pytest.mark.asyncio\nasync def test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n@pytest.mark.asyncio\nasync def test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n@pytest.mark.asyncio\nasync def test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_test.html\", value=False)\n\n    rv = await client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n@pytest.mark.asyncio\nasync def test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_test.html\", value=False)\n\n    rv = await client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n@pytest.mark.asyncio\nasync def test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_test.html\", value=False)\n\n    rv = await client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n@pytest.mark.asyncio\nasync def test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"template_test.html\", value=False)\n\n    rv = await client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n@pytest.mark.asyncio\nasync def test_add_template_global(app):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"]() == 42\n\n    rv = await render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n@pytest.mark.asyncio\nasync def test_custom_template_loader():\n    class MyQuart(Quart):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyQuart(__name__)\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\"index.html\")\n\n    client = app.test_client()\n    rv = await client.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n@pytest.mark.asyncio\nasync def test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    async def index():\n        return await render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = await client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"\n\n@pytest.mark.asyncio\nasync def test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = Quart(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = Quart(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = Quart(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = Quart(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = Quart(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n\n@pytest.mark.asyncio\nasync def test_custom_jinja_env():\n    class CustomEnvironment(Quart.jinja_environment):\n        pass\n\n    class CustomQuart(Quart):\n        jinja_environment = CustomEnvironment\n\n    app = CustomQuart(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_views.py",
        "code": "src/quart/views.py"
      },
      "similar_items": [
        {
          "framework": "sanic",
          "test": "tests/test_views.py",
          "code": [
            "sanic/views.py"
          ],
          "code_similarity_score": 0.7349960803985596,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_views.py in the donor code to test src/quart/views.py in the host code\n\nimport pytest\nfrom quart import Quart, request, jsonify\nfrom quart.views import MethodView\n\n# Fixture to create a Quart app for testing\n@pytest.fixture\ndef app():\n    app = Quart(__name__)\n    return app\n\n# Test all HTTP methods for a MethodView\n@pytest.mark.parametrize(\"method\", [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"])\n@pytest.mark.asyncio\nasync def test_methods(app, method):\n    class DummyView(MethodView):\n        async def get(self, **kwargs):\n            return jsonify({\"method\": \"GET\"})\n\n        async def post(self, **kwargs):\n            return jsonify({\"method\": \"POST\"})\n\n        async def put(self, **kwargs):\n            return jsonify({\"method\": \"PUT\"})\n\n        async def delete(self, **kwargs):\n            return jsonify({\"method\": \"DELETE\"})\n\n        async def patch(self, **kwargs):\n            return jsonify({\"method\": \"PATCH\"})\n\n        async def options(self, **kwargs):\n            return jsonify({\"method\": \"OPTIONS\"})\n\n        async def head(self, **kwargs):\n            return jsonify({\"method\": \"HEAD\"})\n\n    app.add_url_rule('/', view_func=DummyView.as_view('dummy'))\n\n    test_client = app.test_client()\n    response = await getattr(test_client, method.lower())('/')\n    assert (await response.get_json())[\"method\"] == method\n\n# Test a MethodView with only a GET method implemented\n@pytest.mark.asyncio\nasync def test_unexisting_methods(app):\n    class DummyView(MethodView):\n        async def get(self, **kwargs):\n            return jsonify(\"I am get method\")\n\n    app.add_url_rule('/', view_func=DummyView.as_view('dummy'))\n\n    test_client = app.test_client()\n    response = await test_client.get('/')\n    assert (await response.get_data(as_text=True)) == \"I am get method\"\n\n    response = await test_client.post('/')\n    assert response.status_code == 405  # Method Not Allowed\n\n# Test a MethodView with URL parameters\n@pytest.mark.asyncio\nasync def test_argument_methods(app):\n    class DummyView(MethodView):\n        async def get(self, my_param_here, **kwargs):\n            return jsonify(f\"I am get method with {my_param_here}\")\n\n    app.add_url_rule('/<my_param_here>', view_func=DummyView.as_view('dummy'))\n\n    test_client = app.test_client()\n    response = await test_client.get('/test123')\n    assert (await response.get_data(as_text=True)) == \"I am get method with test123\"\n\n# Test a MethodView with decorators\n@pytest.mark.asyncio\nasync def test_with_decorator(app):\n    results = []\n\n    def simple_decorator(func):\n        async def wrapper(*args, **kwargs):\n            results.append(1)\n            return await func(*args, **kwargs)\n        return wrapper\n\n    class DummyView(MethodView):\n        decorators = [simple_decorator]\n\n        async def get(self, **kwargs):\n            return jsonify(\"I am get method\")\n\n    app.add_url_rule('/', view_func=DummyView.as_view('dummy'))\n\n    test_client = app.test_client()\n    response = await test_client.get('/')\n    assert (await response.get_data(as_text=True)) == \"I am get method\"\n    assert results[0] == 1"
        }
      ]
    }
  ]
}