# This test file was generated by adapting tests from tests/test_app.py in the donor code
# to test the functionality in sanic/app.py in the host code through test transplantation.

import asyncio
from unittest.mock import AsyncMock
import pytest
from sanic import Sanic
from sanic.response import text
from sanic.exceptions import SanicException
from sanic.request import Request
from sanic.websocket import WebSocketProtocol

# Define a simple error for testing purposes
class SimpleError(Exception):
    pass

# Test that adding routes with duplicate names raises an exception
def test_endpoint_overwrite():
    app = Sanic("test_app")

    async def route(request):
        return text("")

    async def route2(request):
        return text("")

    app.add_route(route, "/a", name="index")
    app.add_route(route, "/a/a", name="index")  # Should not assert, as same view func
    with pytest.raises(SanicException):
        app.add_route(route2, "/a/b", name="index")

# Test that the app handles exceptions in routes properly
async def test_app_route_exception():
    app = Sanic("test_app")

    @app.route("/exception")
    async def exception(request):
        raise Exception()

    request, response = await app.asgi_client.get("/exception")
    assert response.status == 500

# Test that the app handles exceptions in middleware properly
async def test_app_middleware_exception():
    app = Sanic("test_app")

    @app.middleware("request")
    async def middleware(request):
        raise Exception()

    @app.route("/")
    async def route(request):
        return text("")

    request, response = await app.asgi_client.get("/")
    assert response.status == 500

# Test that the app handles asyncio.CancelledError in request handlers
async def test_app_handle_request_asyncio_cancelled_error():
    app = Sanic("test_app")

    @app.route("/")
    async def index(request):
        raise asyncio.CancelledError()

    with pytest.raises(asyncio.CancelledError):
        request, response = await app.asgi_client.get("/")

# Test that the app handles asyncio.CancelledError in websocket handlers
async def test_app_handle_websocket_asyncio_cancelled_error():
    app = Sanic("test_app")

    @app.websocket("/ws")
    async def index(request, ws):
        raise asyncio.CancelledError()

    with pytest.raises(asyncio.CancelledError):
        async with app.asgi_client.websocket("/ws") as ws:
            await ws.send("")

# Test that the app can handle background tasks
async def test_background_task():
    app = Sanic("test_app")
    task_ran = False

    async def background_task(app):
        nonlocal task_ran
        task_ran = True

    app.add_task(background_task(app))
    await asyncio.sleep(0.1)  # Give time for the task to run
    assert task_ran

# Test that the app can handle exceptions in background tasks
async def test_background_task_exception():
    app = Sanic("test_app")

    async def background_task(app):
        raise SimpleError()

    app.add_task(background_task(app))
    await asyncio.sleep(0.1)  # Give time for the task to run
    # No assertion needed, just ensure no unhandled exceptions

# Test that the app can handle websocket connections
async def test_websocket():
    app = Sanic("test_app")

    @app.websocket("/ws")
    async def ws_handler(request, ws):
        data = await ws.recv()
        await ws.send(data)

    async with app.asgi_client.websocket("/ws") as ws:
        await ws.send("hello")
        data = await ws.recv()
        assert data == "hello"