# This test file was generated by transplanting tests from tests/test_asgi.py to sanic/app.py

import asyncio
from unittest.mock import AsyncMock, Mock

import pytest
from sanic import Sanic
from sanic.request import Request
from sanic.response import HTTPResponse
from sanic.app import ASGIApp
from sanic.exceptions import SanicException

@pytest.fixture
def app():
    return Sanic("test_app")

@pytest.fixture
def asgi_app(app):
    return ASGIApp(app)

@pytest.mark.asyncio
async def test_handle_request(app):
    # Test that handle_request processes a request correctly
    request = Request(b"/", {}, "GET", "http", app)
    response = HTTPResponse("Hello, world!")
    
    async def handler(request):
        return response

    app.router.add("/test", handler, methods=["GET"])
    request.path = "/test"
    await app.handle_request(request)
    assert request.stream.response.body == b"Hello, world!"

@pytest.mark.asyncio
async def test_handle_exception(app):
    # Test that handle_exception handles exceptions correctly
    request = Request(b"/", {}, "GET", "http", app)
    
    async def handler(request):
        raise ValueError("Test exception")

    app.router.add("/test", handler, methods=["GET"])
    request.path = "/test"
    with pytest.raises(ValueError):
        await app.handle_request(request)

@pytest.mark.asyncio
async def test_dispatch_event(app):
    # Test that dispatch can trigger an event
    event_triggered = False

    @app.signal("test.event")
    async def event_handler():
        nonlocal event_triggered
        event_triggered = True

    await app.dispatch("test.event")
    assert event_triggered

@pytest.mark.asyncio
async def test_add_task(app):
    # Test that add_task schedules a task correctly
    task_completed = False

    async def task():
        nonlocal task_completed
        task_completed = True

    app.add_task(task())
    await asyncio.sleep(0.1)  # Allow the task to complete
    assert task_completed

@pytest.mark.asyncio
async def test_websocket_handler(app):
    # Test that websocket handler processes messages correctly
    request = Request(b"/", {}, "GET", "http", app)
    request.transport = Mock()
    request.transport.get_websocket_connection = Mock(return_value=AsyncMock())

    async def websocket_handler(request, ws):
        await ws.send("Hello, websocket!")

    app.router.add("/ws", websocket_handler, methods=["GET"], websocket=True)
    request.path = "/ws"
    await app.handle_request(request)

    ws = request.transport.get_websocket_connection()
    ws.send.assert_called_with("Hello, websocket!")

@pytest.mark.asyncio
async def test_asgi_lifespan(asgi_app):
    # Test that ASGI lifespan events are handled correctly
    receive = AsyncMock()
    send = AsyncMock()

    receive.side_effect = [
        {"type": "lifespan.startup"},
        {"type": "lifespan.shutdown"},
    ]

    await asgi_app({"type": "lifespan"}, receive, send)

    send.assert_any_call({"type": "lifespan.startup.complete"})
    send.assert_any_call({"type": "lifespan.shutdown.complete"})

@pytest.mark.asyncio
async def test_url_for(app):
    # Test that url_for constructs URLs correctly
    async def handler(request):
        return HTTPResponse("Hello, world!")

    app.router.add("/test", handler, methods=["GET"], name="test_handler")
    url = app.url_for("test_handler")
    assert url == "/test"

    url_with_params = app.url_for("test_handler", _external=True, _scheme="https")
    assert url_with_params.startswith("https://")