# This test file was generated by adapting tests from tests/test_asgi.py
# to test the functionality in sanic/app.py through test transplantation.

import asyncio
from unittest.mock import AsyncMock, Mock

import pytest
from sanic import Sanic
from sanic.request import Request
from sanic.response import HTTPResponse
from sanic.exceptions import SanicException, ServerError
from sanic.app import ASGIApp

@pytest.fixture
def app():
    return Sanic("test_app")

@pytest.mark.asyncio
async def test_handle_request(app):
    # Test that handle_request processes a request and returns a response
    request = Request(b"/", {}, "GET", "http", "1.1", None, None, None, None)
    response = HTTPResponse("Hello, world!")
    
    async def handler(request):
        return response
    
    app.router.add("/test", handler, methods=["GET"])
    
    request._match_info = {}
    request.route = app.router.routes[0]
    
    await app.handle_request(request)
    assert request.stream.response == response

@pytest.mark.asyncio
async def test_handle_exception(app):
    # Test that handle_exception processes an exception and returns an error response
    request = Request(b"/", {}, "GET", "http", "1.1", None, None, None, None)
    
    async def handler(request):
        raise SanicException("Test exception", status_code=500)
    
    app.router.add("/test", handler, methods=["GET"])
    
    request._match_info = {}
    request.route = app.router.routes[0]
    
    with pytest.raises(SanicException):
        await app.handle_request(request)

@pytest.mark.asyncio
async def test_dispatch_event(app):
    # Test that dispatch sends an event to the signal router
    event_name = "test.event"
    mock_handler = AsyncMock()
    
    app.signal(event_name)(mock_handler)
    
    await app.dispatch(event_name, context={"key": "value"})
    mock_handler.assert_awaited_once_with(app, key="value")

@pytest.mark.asyncio
async def test_asgi_lifespan(app):
    # Test that ASGI lifespan events are handled correctly
    scope = {"type": "lifespan"}
    receive = AsyncMock()
    send = AsyncMock()
    
    app.asgi = True
    asgi_app = ASGIApp(app, scope, receive, send)
    
    await asgi_app(scope, receive, send)
    send.assert_any_call({"type": "lifespan.startup.complete"})
    send.assert_any_call({"type": "lifespan.shutdown.complete"})

@pytest.mark.asyncio
async def test_asgi_http_connection(app):
    # Test that ASGI HTTP connections are handled correctly
    scope = {
        "type": "http",
        "method": "GET",
        "path": "/",
        "headers": [],
        "query_string": b"",
        "client": ("127.0.0.1", 80),
        "server": None,
    }
    receive = AsyncMock()
    send = AsyncMock()
    
    asgi_app = ASGIApp(app, scope, receive, send)
    
    await asgi_app(scope, receive, send)
    send.assert_any_call({"type": "http.response.start", "status": 404, "headers": []})

@pytest.mark.asyncio
async def test_asgi_websocket_connection(app):
    # Test that ASGI WebSocket connections are handled correctly
    scope = {
        "type": "websocket",
        "path": "/ws",
        "headers": [],
        "query_string": b"",
        "client": ("127.0.0.1", 80),
        "server": None,
    }
    receive = AsyncMock()
    send = AsyncMock()
    
    asgi_app = ASGIApp(app, scope, receive, send)
    
    await asgi_app(scope, receive, send)
    send.assert_any_call({"type": "websocket.close", "code": 1000})