{
  "relevant_pairs": [
    {
      "host_item": {
        "test": "tests/test_app.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_sync.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6635478734970093,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_sync.py in donor to test functionality in sanic/app.py\n\nfrom __future__ import annotations\n\nimport threading\nfrom collections.abc import Generator\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\n\n@pytest.fixture(name=\"app\")\ndef _app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def index(request: Request) -> HTTPResponse:\n        return HTTPResponse(request.method)\n\n    @app.route(\"/gen\")\n    async def gen(request: Request) -> HTTPResponse:\n        def _gen() -> Generator[bytes, None, None]:\n            yield b\"%d\" % threading.current_thread().ident\n            for _ in range(2):\n                yield b\"b\"\n\n        return HTTPResponse(body=_gen(), status=200)\n\n    return app\n\n\n@pytest.fixture(name=\"test_client\")\ndef _test_client(app: Sanic) -> SanicTestClient:\n    return app.test_client\n\n\nasync def test_sync_request_context(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/\")\n    assert response.body == b\"GET\"\n    request, response = await test_client.post(\"/\")\n    assert response.body == b\"POST\"\n\n\nasync def test_sync_generator(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/gen\")\n    result = response.body\n    assert result[-2:] == b\"bb\"\n    assert int(result[:-2]) != threading.current_thread().ident"
        },
        {
          "framework": "quart",
          "test": "tests/test_background_tasks.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6877192258834839,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_background_tasks.py in donor to sanic/app.py in host\n\nimport asyncio\nimport time\nfrom sanic import Sanic\nfrom sanic.response import text\n\n# Test to ensure that a background task can be added and executed correctly\nasync def test_background_task():\n    app = Sanic(\"test_background_task\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\"\n\n# Test to ensure that a background task can be added during the startup phase\nasync def test_lifespan_background_task():\n    app = Sanic(\"test_lifespan_background_task\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.main_process_start\n    async def startup(app, loop):\n        app.add_task(background)\n\n    async with app.asgi_client:\n        pass\n\n    assert data == \"data\"\n\n# Test to ensure that a synchronous background task can be added and executed correctly\nasync def test_sync_background_task():\n    app = Sanic(\"test_sync_background_task\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    def background():\n        nonlocal data\n        time.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_asgi.py",
        "code": "sanic/asgi.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_asgi.py to sanic/asgi.py through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.exceptions import BadRequest, ServerError\nfrom sanic.models.asgi import ASGIScope, ASGIReceive, ASGISend\nfrom sanic.request import Request\nfrom sanic.response import BaseHTTPResponse\nfrom sanic.asgi import ASGIApp, Lifespan\n\n\n@pytest.fixture\ndef sanic_app():\n    app = Sanic(\"test_app\")\n    return app\n\n\n@pytest.mark.asyncio\nasync def test_lifespan_startup(sanic_app):\n    # Test that the startup sequence completes without errors\n    scope = {\"type\": \"lifespan\"}\n    receive = AsyncMock()\n    send = AsyncMock()\n    lifespan = Lifespan(sanic_app, scope, receive, send)\n\n    receive.return_value = {\"type\": \"lifespan.startup\"}\n    await lifespan()\n\n    send.assert_called_with({\"type\": \"lifespan.startup.complete\"})\n\n\n@pytest.mark.asyncio\nasync def test_lifespan_shutdown(sanic_app):\n    # Test that the shutdown sequence completes without errors\n    scope = {\"type\": \"lifespan\"}\n    receive = AsyncMock()\n    send = AsyncMock()\n    lifespan = Lifespan(sanic_app, scope, receive, send)\n\n    receive.return_value = {\"type\": \"lifespan.shutdown\"}\n    await lifespan()\n\n    send.assert_called_with({\"type\": \"lifespan.shutdown.complete\"})\n\n\n@pytest.mark.asyncio\nasync def test_asgi_app_create(sanic_app):\n    # Test the creation of an ASGIApp instance\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"headers\": [(b\"host\", b\"sanic\")],\n        \"raw_path\": b\"/\",\n        \"query_string\": b\"\",\n    }\n    receive = AsyncMock()\n    send = AsyncMock()\n\n    app_instance = await ASGIApp.create(sanic_app, scope, receive, send)\n\n    assert isinstance(app_instance, ASGIApp)\n    assert app_instance.sanic_app == sanic_app\n    assert app_instance.request.method == \"GET\"\n\n\n@pytest.mark.asyncio\nasync def test_asgi_app_read(sanic_app):\n    # Test reading from an ASGI message\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"headers\": [(b\"host\", b\"sanic\")],\n        \"raw_path\": b\"/\",\n        \"query_string\": b\"\",\n    }\n    receive = AsyncMock()\n    send = AsyncMock()\n\n    app_instance = await ASGIApp.create(sanic_app, scope, receive, send)\n    app_instance.transport.receive = AsyncMock(\n        return_value={\"body\": b\"test\", \"more_body\": False}\n    )\n\n    body = await app_instance.read()\n    assert body == b\"test\"\n\n\n@pytest.mark.asyncio\nasync def test_asgi_app_respond(sanic_app):\n    # Test responding with a BaseHTTPResponse\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"headers\": [(b\"host\", b\"sanic\")],\n        \"raw_path\": b\"/\",\n        \"query_string\": b\"\",\n    }\n    receive = AsyncMock()\n    send = AsyncMock()\n\n    app_instance = await ASGIApp.create(sanic_app, scope, receive, send)\n    response = Mock(spec=BaseHTTPResponse)\n    response.status = 200\n    response.processed_headers = []\n\n    app_instance.stage = app_instance.stage.HANDLER\n    app_instance.respond(response)\n\n    assert app_instance.response == response\n\n\n@pytest.mark.asyncio\nasync def test_asgi_app_send(sanic_app):\n    # Test sending data through ASGIApp\n    scope = {\n        \"type\": \"http\",\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"headers\": [(b\"host\", b\"sanic\")],\n        \"raw_path\": b\"/\",\n        \"query_string\": b\"\",\n    }\n    receive = AsyncMock()\n    send = AsyncMock()\n\n    app_instance = await ASGIApp.create(sanic_app, scope, receive, send)\n    app_instance.transport.send = AsyncMock()\n\n    await app_instance.send(\"data\", end_stream=True)\n\n    app_instance.transport.send.assert_called_with(\n        {\n            \"type\": \"http.response.body\",\n            \"body\": b\"data\",\n            \"more_body\": False,\n        }\n    )"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_base.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_app.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6890430450439453,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_app.py in the donor project to test sanic/app.py in the host project through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import NoReturn\nfrom unittest.mock import AsyncMock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import text\nfrom sanic.exceptions import SanicException\nfrom sanic_testing.testing import SanicTestClient\n\nTEST_RESPONSE = text(\"\")\n\n\nclass SimpleError(Exception):\n    pass\n\n\ndef test_endpoint_overwrite() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/a\", methods=[\"GET\"])\n    def route(request):\n        return text(\"\")\n\n    @app.route(\"/a/a\", methods=[\"GET\"])\n    def route2(request):\n        return text(\"\")\n\n    with pytest.raises(SanicException):\n        @app.route(\"/a/b\", methods=[\"GET\"])\n        def route3(request):\n            return text(\"\")\n\n\n@pytest.mark.parametrize(\n    \"methods, expected_methods\",\n    [\n        ([\"GET\"], {\"GET\", \"HEAD\"}),\n        ([\"POST\"], {\"POST\"}),\n        ([\"PUT\", \"DELETE\"], {\"PUT\", \"DELETE\"}),\n    ],\n)\ndef test_add_route_methods(methods: list[str], expected_methods: set[str]) -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", methods=methods)\n    def route(request):\n        return text(\"\")\n\n    route = app.router.routes_all[0]\n    assert set(route.methods) == expected_methods\n\n\nasync def test_host_matching() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", host=\"quart.com\")\n    async def route(request):\n        return text(\"\")\n\n    test_client = SanicTestClient(app)\n    request, response = await test_client.get(\"/\", headers={\"host\": \"quart.com\"})\n    assert response.status == 200\n\n    request, response = await test_client.get(\"/\", headers={\"host\": \"localhost\"})\n    assert response.status == 404\n\n\n@pytest.mark.parametrize(\n    \"result, expected, raises\",\n    [\n        (None, None, True),\n        (TEST_RESPONSE, TEST_RESPONSE, False),\n        ((\"hello\", {\"X-Header\": \"bob\"}), text(\"hello\", headers={\"X-Header\": \"bob\"}), False),\n        ((\"hello\", 201), text(\"hello\", status=201), False),\n        (int, None, True),\n    ],\n)\nasync def test_make_response(result, expected, raises: bool) -> None:\n    app = Sanic(\"test_app\")\n\n    try:\n        response = await app._make_response(result)\n    except TypeError:\n        if not raises:\n            raise\n    else:\n        assert response.headers == expected.headers\n        assert response.status == expected.status\n        assert response.body == expected.body\n\n\n@pytest.fixture(name=\"basic_app\")\ndef _basic_app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def route(request):\n        return text(\"\")\n\n    @app.route(\"/exception/\")\n    async def exception(request):\n        raise Exception()\n\n    return app\n\n\nasync def test_app_route_exception(basic_app: Sanic) -> None:\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/exception/\")\n    assert response.status == 500\n\n\nasync def test_app_before_request_exception(basic_app: Sanic) -> None:\n    @basic_app.on_request\n    async def before(request):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_after_request_exception(basic_app: Sanic) -> None:\n    @basic_app.on_response\n    async def after(request, response):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_handle_request_asyncio_cancelled_error() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def index(request):\n        raise asyncio.CancelledError()\n\n    test_client = SanicTestClient(app)\n    with pytest.raises(asyncio.CancelledError):\n        request, response = await test_client.get(\"/\")\n\n\n@pytest.mark.parametrize(\n    \"debug, raises\",\n    [\n        (False, False),\n        (True, True),\n    ],\n)\nasync def test_propagation(debug: bool, raises: bool) -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def exception(request):\n        raise SimpleError()\n\n    app.config.DEBUG = debug\n    test_client = SanicTestClient(app)\n\n    if raises:\n        with pytest.raises(SimpleError):\n            request, response = await test_client.get(\"/\")\n    else:\n        request, response = await test_client.get(\"/\")\n        assert response.status == 500"
        },
        {
          "framework": "quart",
          "test": "tests/test_ctx.py",
          "code": "src/quart/ctx.py",
          "code_similarity_score": 0.6635375022888184,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_ctx.py to test sanic/app.py through test transplantation.\n\nimport asyncio\nfrom unittest.mock import Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import text\nfrom sanic.router import Router\nfrom sanic.exceptions import BadRequest\nfrom sanic.models.handler_types import MiddlewareType\nfrom sanic.middleware import Middleware\n\n# Test to ensure that request context matches correctly\nasync def test_request_context_match():\n    app = Sanic(\"test_app\")\n    router = Mock(spec=Router)\n    route = Mock()\n    route.extra = {}\n    router.get.return_value = (route, lambda x: x, {})\n    app.router = router\n\n    request = Request(b\"/\", {}, \"GET\", app)\n    await app.handle_request(request)\n\n    assert request.route == route\n\n# Test to ensure BadRequest is raised for invalid routes\nasync def test_bad_request_if_invalid_route():\n    app = Sanic(\"test_app\")\n    router = Mock(spec=Router)\n    router.get.side_effect = BadRequest(\"Invalid route\")\n    app.router = router\n\n    request = Request(b\"/invalid\", {}, \"GET\", app)\n    with pytest.raises(BadRequest):\n        await app.handle_request(request)\n\n# Test to ensure middleware is executed after request\nasync def test_after_this_request_middleware():\n    app = Sanic(\"test_app\")\n\n    @app.middleware(\"request\")\n    async def add_header(request):\n        request.ctx.added_header = \"value\"\n\n    @app.route(\"/\")\n    async def handler(request):\n        return text(\"Hello\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert request.ctx.added_header == \"value\"\n\n# Test to ensure request context is available\nasync def test_has_request_context():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        assert request is not None\n        return text(\"Hello\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n# Test to ensure app context is available\nasync def test_has_app_context():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        assert app is not None\n        return text(\"Hello\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n# Test to ensure middleware can be copied and executed in app context\nasync def test_copy_current_app_context():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        @app.ext.dependency\n        async def within_context():\n            assert app is not None\n\n        await asyncio.ensure_future(within_context())\n        return text(\"Hello\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n# Test to ensure middleware can be copied and executed in request context\nasync def test_copy_current_request_context():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        @app.ext.dependency\n        async def within_context():\n            assert request is not None\n\n        await asyncio.ensure_future(within_context())\n        return text(\"Hello\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n# Test to ensure middleware can be copied and executed in websocket context\nasync def test_copy_current_websocket_context():\n    app = Sanic(\"test_app\")\n\n    @app.websocket(\"/\")\n    async def handler(request, ws):\n        @app.ext.dependency\n        async def within_context():\n            return request.path\n\n        data = await asyncio.ensure_future(within_context())\n        await ws.send(data)\n\n    test_client = app.test_client()\n    async with test_client.websocket(\"/\") as test_websocket:\n        data = await test_websocket.receive()\n    assert data == \"/\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_cancellederror.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_sync.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6635478734970093,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_sync.py in the donor project to test sanic/app.py in the host project\n\nfrom __future__ import annotations\n\nimport threading\nfrom collections.abc import Generator\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\n\n\n@pytest.fixture(name=\"app\")\ndef _app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def index(request: Request) -> HTTPResponse:\n        return HTTPResponse(request.method)\n\n    @app.route(\"/gen\")\n    async def gen(request: Request) -> HTTPResponse:\n        def _gen() -> Generator[bytes, None, None]:\n            yield b\"%d\" % threading.current_thread().ident\n            for _ in range(2):\n                yield b\"b\"\n\n        return HTTPResponse(_gen(), status=200)\n\n    return app\n\n\n@pytest.mark.asyncio\nasync def test_sync_request_context(app: Sanic) -> None:\n    \"\"\"Test that the request context correctly handles GET and POST methods.\"\"\"\n    test_client = app.test_client\n    request, response = await test_client.get(\"/\")\n    assert response.body == b\"GET\"\n    request, response = await test_client.post(\"/\")\n    assert response.body == b\"POST\"\n\n\n@pytest.mark.asyncio\nasync def test_sync_generator(app: Sanic) -> None:\n    \"\"\"Test that the generator route returns the expected response.\"\"\"\n    test_client = app.test_client\n    request, response = await test_client.get(\"/gen\")\n    result = response.body\n    assert result[-2:] == b\"bb\"\n    assert int(result[:-2]) != threading.current_thread().ident"
        },
        {
          "framework": "quart",
          "test": "tests/test_background_tasks.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6877192258834839,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_background_tasks.py in the donor to sanic/app.py in the host\n\nimport asyncio\nimport time\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import text\n\n@pytest.mark.asyncio\nasync def test_background_task():\n    app = Sanic(\"test_app\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request: Request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\"\n\n@pytest.mark.asyncio\nasync def test_lifespan_background_task():\n    app = Sanic(\"test_app\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.main_process_start\n    async def startup(app, loop):\n        app.add_task(background)\n\n    async with app.test_client() as client:\n        pass\n\n    assert data == \"data\"\n\n@pytest.mark.asyncio\nasync def test_sync_background_task():\n    app = Sanic(\"test_app\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    def background():\n        nonlocal data\n        time.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request: Request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\""
        },
        {
          "framework": "quart",
          "test": "tests/test_app.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6890430450439453,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_app.py in the donor code to test sanic/app.py in the host code through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import NoReturn\nfrom unittest.mock import AsyncMock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.exceptions import SanicException\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\nTEST_RESPONSE = HTTPResponse(\"\")\n\n\nclass SimpleError(Exception):\n    pass\n\n\ndef test_endpoint_overwrite() -> None:\n    app = Sanic(\"test_app\")\n\n    def route(request):\n        return HTTPResponse(\"\")\n\n    def route2(request):\n        return HTTPResponse(\"\")\n\n    async def route3(request):\n        return HTTPResponse(\"\")\n\n    app.add_route(route, \"/a\", methods=[\"GET\"], name=\"index\")\n    app.add_route(route, \"/a/a\", methods=[\"GET\"], name=\"index\")  # Should not assert, as same view func\n    with pytest.raises(SanicException):\n        app.add_route(route2, \"/a/b\", methods=[\"GET\"], name=\"index\")\n    app.add_route(route3, \"/b\", methods=[\"GET\"], name=\"async\")\n    app.add_route(route3, \"/b/a\", methods=[\"GET\"], name=\"async\")  # Should not assert, as same view func\n    with pytest.raises(SanicException):\n        app.add_route(route2, \"/b/b\", methods=[\"GET\"], name=\"async\")\n\n\n@pytest.mark.parametrize(\n    \"methods, expected_methods\",\n    [\n        ([\"GET\"], {\"GET\", \"HEAD\"}),\n        ([\"GET\", \"OPTIONS\"], {\"GET\", \"HEAD\", \"OPTIONS\"}),\n    ],\n)\ndef test_add_route_methods(methods, expected_methods) -> None:\n    app = Sanic(\"test_app\")\n\n    def route(request):\n        return HTTPResponse(\"\")\n\n    app.add_route(route, \"/\", methods=methods)\n    route = app.router.routes_all[0]\n    assert set(route.methods) == expected_methods\n\n\nasync def test_host_matching() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", host=\"quart.com\")\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    test_client = SanicTestClient(app)\n    request, response = await test_client.get(\"/\", headers={\"host\": \"quart.com\"})\n    assert response.status == 200\n\n    request, response = await test_client.get(\"/\", headers={\"host\": \"localhost\"})\n    assert response.status == 404\n\n\n@pytest.mark.parametrize(\n    \"result, expected, raises\",\n    [\n        (None, None, True),\n        (TEST_RESPONSE, TEST_RESPONSE, False),\n        ((\"hello\", {\"X-Header\": \"bob\"}), HTTPResponse(\"hello\", headers={\"X-Header\": \"bob\"}), False),\n        ((\"hello\", 201), HTTPResponse(\"hello\", status=201), False),\n        ((\"hello\", 201, {\"X-Header\": \"bob\"}), HTTPResponse(\"hello\", status=201, headers={\"X-Header\": \"bob\"}), False),\n        (int, None, True),\n    ],\n)\nasync def test_make_response(result, expected, raises) -> None:\n    app = Sanic(\"test_app\")\n\n    try:\n        response = await app._make_response(result)\n    except TypeError:\n        if not raises:\n            raise\n    else:\n        assert response.headers == expected.headers\n        assert response.status == expected.status\n        assert response.body == expected.body\n\n\n@pytest.fixture(name=\"basic_app\")\ndef _basic_app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    @app.route(\"/exception/\")\n    async def exception(request):\n        raise Exception()\n\n    return app\n\n\nasync def test_app_route_exception(basic_app: Sanic) -> None:\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/exception/\")\n    assert response.status == 500\n\n\nasync def test_app_before_request_exception(basic_app: Sanic) -> None:\n    @basic_app.on_request\n    async def before(request):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_after_request_exception(basic_app: Sanic) -> None:\n    @basic_app.on_response\n    async def after(request, response):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_handle_request_asyncio_cancelled_error() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def index(request):\n        raise asyncio.CancelledError()\n\n    request = Request(b\"\", app, \"GET\", \"/\", None, None, None, None, None, None)\n    with pytest.raises(asyncio.CancelledError):\n        await app.handle_request(request)\n\n\n@pytest.mark.parametrize(\n    \"debug, testing, raises\",\n    [\n        (False, False, False),\n        (True, False, True),\n        (False, True, True),\n        (True, True, True),\n    ],\n)\nasync def test_propagation(debug: bool, testing: bool, raises: bool) -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def exception(request):\n        raise SimpleError()\n\n    app.config.DEBUG = debug\n    app.config.TESTING = testing\n    test_client = SanicTestClient(app)\n\n    if raises:\n        with pytest.raises(SimpleError):\n            request = Request(b\"\", app, \"GET\", \"/\", None, None, None, None, None, None)\n            await app.handle_request(request)\n    else:\n        request, response = await test_client.get(\"/\")\n        assert response.status == 500"
        },
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_asgi.py to test sanic/app.py through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.app import ASGIApp\nfrom sanic.asgi import Lifespan\n\n@pytest.fixture\ndef app():\n    return Sanic(\"test_app\")\n\n@pytest.fixture\ndef asgi_app(app):\n    return ASGIApp(app)\n\n@pytest.fixture\ndef lifespan(app):\n    return Lifespan(app, {}, None, None)\n\n@pytest.mark.asyncio\nasync def test_handle_request(app):\n    # Test that handle_request processes a request and returns a response\n    request = Request(b\"/\", {}, \"GET\", \"http\", \"1.1\", None, None, None, None, None, None)\n    response = HTTPResponse(\"Hello, world!\")\n    \n    async def handler(request):\n        return response\n    \n    app.router.add(\"/test\", handler, methods=[\"GET\"])\n    \n    await app.handle_request(request)\n    assert request.stream.response.body == b\"Hello, world!\"\n\n@pytest.mark.asyncio\nasync def test_handle_exception(app):\n    # Test that handle_exception processes an exception and returns a response\n    request = Request(b\"/\", {}, \"GET\", \"http\", \"1.1\", None, None, None, None, None, None)\n    \n    async def handler(request):\n        raise ValueError(\"Test exception\")\n    \n    app.router.add(\"/test\", handler, methods=[\"GET\"])\n    \n    with pytest.raises(ValueError):\n        await app.handle_request(request)\n\n@pytest.mark.asyncio\nasync def test_asgi_lifespan_startup(lifespan):\n    # Test that ASGI lifespan startup completes successfully\n    async def receive():\n        return {\"type\": \"lifespan.startup\"}\n    \n    async def send(message):\n        assert message[\"type\"] == \"lifespan.startup.complete\"\n    \n    await lifespan(receive, send)\n\n@pytest.mark.asyncio\nasync def test_asgi_lifespan_shutdown(lifespan):\n    # Test that ASGI lifespan shutdown completes successfully\n    async def receive():\n        return {\"type\": \"lifespan.shutdown\"}\n    \n    async def send(message):\n        assert message[\"type\"] == \"lifespan.shutdown.complete\"\n    \n    await lifespan(receive, send)\n\n@pytest.mark.asyncio\nasync def test_asgi_app_call(asgi_app):\n    # Test that ASGI app processes a request and returns a response\n    scope = {\n        \"type\": \"http\",\n        \"method\": \"GET\",\n        \"path\": \"/\",\n        \"headers\": [],\n        \"query_string\": b\"\",\n        \"http_version\": \"1.1\",\n        \"scheme\": \"http\",\n    }\n    \n    async def receive():\n        return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}\n    \n    async def send(message):\n        if message[\"type\"] == \"http.response.start\":\n            assert message[\"status\"] == 200\n        elif message[\"type\"] == \"http.response.body\":\n            assert message[\"body\"] == b\"Hello, world!\"\n    \n    asgi_app.app.router.add(\"/\", lambda request: HTTPResponse(\"Hello, world!\"), methods=[\"GET\"])\n    await asgi_app(scope, receive, send)"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_create_task.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_asgi.py to test the functionality in sanic/app.py\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.app import ASGIApp\nfrom sanic.exceptions import SanicException\n\n# Test that the ASGI app can handle HTTP requests correctly\nasync def test_http_request_handling():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        return HTTPResponse(\"Hello, world!\")\n\n    scope = {\n        \"type\": \"http\",\n        \"asgi\": {},\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"scheme\": \"http\",\n        \"path\": \"/\",\n        \"query_string\": b\"\",\n        \"headers\": [(b\"host\", b\"localhost\")],\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n    }\n\n    async def receive():\n        return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}\n\n    async def send(message):\n        assert message[\"type\"] == \"http.response.start\" or message[\"type\"] == \"http.response.body\"\n\n    asgi_app = ASGIApp(app, scope, receive, send)\n    await asgi_app()\n\n# Test that the ASGI app can handle WebSocket connections correctly\nasync def test_websocket_handling():\n    app = Sanic(\"test_app\")\n\n    @app.websocket(\"/ws\")\n    async def handler(request, ws):\n        await ws.send(\"Hello, world!\")\n\n    scope = {\n        \"type\": \"websocket\",\n        \"asgi\": {},\n        \"http_version\": \"1.1\",\n        \"scheme\": \"ws\",\n        \"path\": \"/ws\",\n        \"query_string\": b\"\",\n        \"headers\": [(b\"host\", b\"localhost\")],\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n        \"subprotocols\": [],\n    }\n\n    async def receive():\n        return {\"type\": \"websocket.connect\"}\n\n    async def send(message):\n        assert message[\"type\"] == \"websocket.accept\" or message[\"type\"] == \"websocket.send\"\n\n    asgi_app = ASGIApp(app, scope, receive, send)\n    await asgi_app()\n\n# Test that the app raises an exception for invalid server events\nasync def test_invalid_server_event():\n    app = Sanic(\"test_app\")\n\n    with pytest.raises(SanicException):\n        await app._server_event(\"invalid\", \"event\")\n\n# Test that the app can handle exceptions in request handling\nasync def test_handle_exception():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def handler(request):\n        raise ValueError(\"Test exception\")\n\n    scope = {\n        \"type\": \"http\",\n        \"asgi\": {},\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"scheme\": \"http\",\n        \"path\": \"/\",\n        \"query_string\": b\"\",\n        \"headers\": [(b\"host\", b\"localhost\")],\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n    }\n\n    async def receive():\n        return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}\n\n    async def send(message):\n        assert message[\"type\"] == \"http.response.start\" or message[\"type\"] == \"http.response.body\"\n\n    asgi_app = ASGIApp(app, scope, receive, send)\n    await asgi_app()"
        },
        {
          "framework": "quart",
          "test": "tests/test_sync.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6635478734970093,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_sync.py in the donor project to test sanic/app.py in the host project\n\nfrom __future__ import annotations\n\nimport threading\nfrom collections.abc import Generator\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\n\n@pytest.fixture(name=\"app\")\ndef _app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def index(request: Request) -> HTTPResponse:\n        return HTTPResponse(request.method)\n\n    @app.route(\"/gen\")\n    async def gen(request: Request) -> HTTPResponse:\n        def _gen() -> Generator[bytes, None, None]:\n            yield b\"%d\" % threading.current_thread().ident\n            for _ in range(2):\n                yield b\"b\"\n\n        return HTTPResponse(body=_gen(), status=200)\n\n    return app\n\n\n@pytest.fixture(name=\"test_client\")\ndef _test_client(app: Sanic) -> SanicTestClient:\n    return app.test_client\n\n\n@pytest.mark.asyncio\nasync def test_sync_request_context(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/\")\n    assert response.body == b\"GET\"\n    request, response = await test_client.post(\"/\")\n    assert response.body == b\"POST\"\n\n\n@pytest.mark.asyncio\nasync def test_sync_generator(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/gen\")\n    result = response.body\n    assert result[-2:] == b\"bb\"\n    assert int(result[:-2]) != threading.current_thread().ident"
        },
        {
          "framework": "quart",
          "test": "tests/test_background_tasks.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6877192258834839,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_background_tasks.py to test the functionality in sanic/app.py through test transplantation.\n\nimport asyncio\nimport time\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import text\n\n@pytest.fixture\ndef app():\n    app = Sanic(\"test_app\")\n    app.config.DATA = \"data\"\n    return app\n\n# Test to ensure that a background task can be added and executed\n@pytest.mark.asyncio\nasync def test_background_task(app: Sanic):\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request: Request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\"\n\n# Test to ensure that a background task can be added during the lifespan of the app\n@pytest.mark.asyncio\nasync def test_lifespan_background_task(app: Sanic):\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.main_process_start\n    async def startup(app, loop):\n        app.add_task(background)\n\n    async with app.test_client() as client:\n        pass\n\n    assert data == \"data\"\n\n# Test to ensure that a synchronous background task can be added and executed\n@pytest.mark.asyncio\nasync def test_sync_background_task(app: Sanic):\n    data = None\n\n    def background():\n        nonlocal data\n        time.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request: Request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_ext_integration.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_asgi.py to test sanic/app.py\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.app import ASGIApp\nfrom sanic.exceptions import SanicException\nfrom sanic.signals import Event\n\n@pytest.fixture\ndef app():\n    return Sanic(\"test_app\")\n\n@pytest.mark.asyncio\nasync def test_handle_exception(app):\n    # Test that handle_exception properly handles exceptions and returns a response\n    request = Mock(spec=Request)\n    exception = SanicException(\"Test exception\")\n    \n    response = await app.handle_exception(request, exception)\n    \n    assert isinstance(response, HTTPResponse)\n    assert response.status == 500\n\n@pytest.mark.asyncio\nasync def test_dispatch_event(app):\n    # Test that dispatching an event works correctly\n    event_name = \"test.event\"\n    mock_handler = AsyncMock()\n    \n    app.signal(event_name)(mock_handler)\n    \n    await app.dispatch(event_name, context={\"key\": \"value\"})\n    \n    mock_handler.assert_awaited_once()\n    mock_handler.assert_awaited_with(app, {\"key\": \"value\"})\n\n@pytest.mark.asyncio\nasync def test_add_task(app):\n    # Test that tasks can be added and run correctly\n    async def sample_task():\n        return \"Task Completed\"\n    \n    task = app.add_task(sample_task())\n    \n    assert task is not None\n    assert await task == \"Task Completed\"\n\n@pytest.mark.asyncio\nasync def test_get_task(app):\n    # Test that tasks can be retrieved by name\n    async def sample_task():\n        return \"Task Completed\"\n    \n    app.add_task(sample_task(), name=\"sample_task\")\n    \n    task = app.get_task(\"sample_task\")\n    \n    assert task is not None\n    assert await task == \"Task Completed\"\n\n@pytest.mark.asyncio\nasync def test_cancel_task(app):\n    # Test that tasks can be cancelled\n    async def sample_task():\n        await asyncio.sleep(10)\n    \n    app.add_task(sample_task(), name=\"sample_task\")\n    \n    await app.cancel_task(\"sample_task\")\n    \n    task = app.get_task(\"sample_task\", raise_exception=False)\n    assert task is None or task.cancelled()\n\n@pytest.mark.asyncio\nasync def test_asgi_lifespan(app):\n    # Test ASGI lifespan events\n    asgi_app = ASGIApp(app)\n    \n    async def mock_receive():\n        return {\"type\": \"lifespan.startup\"}\n    \n    mock_send = AsyncMock()\n    \n    await asgi_app({\"type\": \"lifespan\"}, mock_receive, mock_send)\n    \n    mock_send.assert_any_call({\"type\": \"lifespan.startup.complete\"})\n\n@pytest.mark.asyncio\nasync def test_websocket_handler(app):\n    # Test that websocket handlers are set up correctly\n    @app.websocket(\"/ws\")\n    async def websocket_handler(request, ws):\n        await ws.send(\"Hello, world!\")\n    \n    assert app.websocket_enabled\n    assert \"/ws\" in app.router.routes_all"
        },
        {
          "framework": "quart",
          "test": "tests/test_app.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6890430450439453,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_app.py in the donor project to test sanic/app.py in the host project through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import NoReturn\nfrom unittest.mock import AsyncMock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.exceptions import SanicException\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\nTEST_RESPONSE = HTTPResponse(\"\")\n\n\nclass SimpleError(Exception):\n    pass\n\n\ndef test_endpoint_overwrite() -> None:\n    app = Sanic(\"test_app\")\n\n    def route(request):\n        return HTTPResponse(\"\")\n\n    def route2(request):\n        return HTTPResponse(\"\")\n\n    async def route3(request):\n        return HTTPResponse(\"\")\n\n    app.add_route(route, \"/a\", methods=[\"GET\"], name=\"index\")\n    app.add_route(\n        route, \"/a/a\", methods=[\"GET\"], name=\"index\"\n    )  # Should not assert, as same view func\n    with pytest.raises(SanicException):\n        app.add_route(route2, \"/a/b\", methods=[\"GET\"], name=\"index\")\n    app.add_route(route3, \"/b\", methods=[\"GET\"], name=\"async\")\n    app.add_route(\n        route3, \"/b/a\", methods=[\"GET\"], name=\"async\"\n    )  # Should not assert, as same view func\n    with pytest.raises(SanicException):\n        app.add_route(route2, \"/b/b\", methods=[\"GET\"], name=\"async\")\n\n\n@pytest.mark.parametrize(\n    \"methods, expected_methods\",\n    [\n        ({\"GET\"}, {\"HEAD\", \"GET\"}),\n        ({\"GET\", \"OPTIONS\"}, {\"HEAD\", \"GET\", \"OPTIONS\"}),\n    ],\n)\ndef test_add_route_methods(\n    methods: set[str], expected_methods: set[str]\n) -> None:\n    app = Sanic(\"test_app\")\n\n    def route(request):\n        return HTTPResponse(\"\")\n\n    app.add_route(route, \"/\", methods=methods, name=\"end\")\n    assert set(app.router.routes_all[0].methods) == expected_methods\n\n\nasync def test_host_matching() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", host=\"quart.com\")\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    test_client = SanicTestClient(app)\n    request, response = await test_client.get(\"/\", headers={\"host\": \"quart.com\"})\n    assert response.status == 200\n\n    request, response = await test_client.get(\"/\", headers={\"host\": \"localhost\"})\n    assert response.status == 404\n\n\n@pytest.mark.parametrize(\n    \"result, expected, raises\",\n    [\n        (None, None, True),\n        (TEST_RESPONSE, TEST_RESPONSE, False),\n        (\n            (\"hello\", {\"X-Header\": \"bob\"}),\n            HTTPResponse(\"hello\", headers={\"X-Header\": \"bob\"}),\n            False,\n        ),\n        ((\"hello\", 201), HTTPResponse(\"hello\", status=201), False),\n        (\n            (\"hello\", 201, {\"X-Header\": \"bob\"}),\n            HTTPResponse(\"hello\", status=201, headers={\"X-Header\": \"bob\"}),\n            False,\n        ),\n        (int, None, True),\n    ],\n)\nasync def test_make_response(\n    result, expected, raises\n) -> None:\n    app = Sanic(\"test_app\")\n    try:\n        response = await app._make_response(result)\n    except TypeError:\n        if not raises:\n            raise\n    else:\n        assert response.headers == expected.headers\n        assert response.status == expected.status\n        assert response.body == expected.body\n\n\n@pytest.fixture(name=\"basic_app\")\ndef _basic_app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    @app.route(\"/exception/\")\n    async def exception(request):\n        raise Exception()\n\n    return app\n\n\nasync def test_app_route_exception(basic_app: Sanic) -> None:\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/exception/\")\n    assert response.status == 500\n\n\nasync def test_app_before_request_exception(basic_app: Sanic) -> None:\n    @basic_app.on_request\n    async def before(request):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_after_request_exception(basic_app: Sanic) -> None:\n    @basic_app.on_response\n    async def after(request, response):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_handle_request_asyncio_cancelled_error() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def index(request) -> NoReturn:\n        raise asyncio.CancelledError()\n\n    request = Request(b\"\", None, \"GET\", \"/\")\n    with pytest.raises(asyncio.CancelledError):\n        await app.handle_request(request)\n\n\n@pytest.mark.parametrize(\n    \"debug, raises\",\n    [\n        (False, False),\n        (True, True),\n    ],\n)\nasync def test_propagation(debug: bool, raises: bool) -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def exception(request):\n        raise SimpleError()\n\n    app.config.DEBUG = debug\n    test_client = SanicTestClient(app)\n\n    if raises:\n        with pytest.raises(SimpleError):\n            request = Request(b\"\", None, \"GET\", \"/\")\n            await app.handle_request(request)\n    else:\n        request, response = await test_client.get(\"/\")\n        assert response.status == 500"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_handler.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_sync.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6635478734970093,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_sync.py in the donor to test the functionality in sanic/app.py\n\nfrom __future__ import annotations\n\nimport threading\nfrom collections.abc import Generator\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\n\n@pytest.fixture(name=\"app\")\ndef _app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def index(request: Request) -> HTTPResponse:\n        return HTTPResponse(request.method)\n\n    @app.route(\"/gen\")\n    async def gen(request: Request) -> HTTPResponse:\n        def _gen() -> Generator[bytes, None, None]:\n            yield b\"%d\" % threading.current_thread().ident\n            for _ in range(2):\n                yield b\"b\"\n\n        return HTTPResponse(body=_gen(), status=200, content_type=\"text/plain\")\n\n    return app\n\n\n@pytest.fixture(name=\"test_client\")\ndef _test_client(app: Sanic) -> SanicTestClient:\n    return app.test_client\n\n\nasync def test_sync_request_context(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/\")\n    assert response.body == b\"GET\"\n    request, response = await test_client.post(\"/\")\n    assert response.body == b\"POST\"\n\n\nasync def test_sync_generator(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/gen\")\n    result = response.body\n    assert result[-2:] == b\"bb\"\n    assert int(result[:-2]) != threading.current_thread().ident"
        },
        {
          "framework": "quart",
          "test": "tests/test_background_tasks.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6877192258834839,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_background_tasks.py in Quart to sanic/app.py in Sanic\n\nimport asyncio\nimport time\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import text\n\n@pytest.mark.asyncio\nasync def test_background_task():\n    app = Sanic(\"test_background_task\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background())\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\"\n\n@pytest.mark.asyncio\nasync def test_lifespan_background_task():\n    app = Sanic(\"test_lifespan_background_task\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.main_process_start\n    async def startup(app, loop):\n        app.add_task(background())\n\n    async with app.asgi_client:\n        pass\n\n    assert data == \"data\"\n\n@pytest.mark.asyncio\nasync def test_sync_background_task():\n    app = Sanic(\"test_sync_background_task\")\n    app.config.DATA = \"data\"\n\n    data = None\n\n    def background():\n        nonlocal data\n        time.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background())\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n    assert data == \"data\""
        },
        {
          "framework": "quart",
          "test": "tests/test_app.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6890430450439453,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_app.py in the donor code\n# to test the functionality in sanic/app.py in the host code through test transplantation.\n\nimport asyncio\nfrom unittest.mock import AsyncMock\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import text\nfrom sanic.exceptions import SanicException\nfrom sanic.request import Request\nfrom sanic.websocket import WebSocketProtocol\n\n# Define a simple error for testing purposes\nclass SimpleError(Exception):\n    pass\n\n# Test that adding routes with duplicate names raises an exception\ndef test_endpoint_overwrite():\n    app = Sanic(\"test_app\")\n\n    async def route(request):\n        return text(\"\")\n\n    async def route2(request):\n        return text(\"\")\n\n    app.add_route(route, \"/a\", name=\"index\")\n    app.add_route(route, \"/a/a\", name=\"index\")  # Should not assert, as same view func\n    with pytest.raises(SanicException):\n        app.add_route(route2, \"/a/b\", name=\"index\")\n\n# Test that the app handles exceptions in routes properly\nasync def test_app_route_exception():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/exception\")\n    async def exception(request):\n        raise Exception()\n\n    request, response = await app.asgi_client.get(\"/exception\")\n    assert response.status == 500\n\n# Test that the app handles exceptions in middleware properly\nasync def test_app_middleware_exception():\n    app = Sanic(\"test_app\")\n\n    @app.middleware(\"request\")\n    async def middleware(request):\n        raise Exception()\n\n    @app.route(\"/\")\n    async def route(request):\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 500\n\n# Test that the app handles asyncio.CancelledError in request handlers\nasync def test_app_handle_request_asyncio_cancelled_error():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def index(request):\n        raise asyncio.CancelledError()\n\n    with pytest.raises(asyncio.CancelledError):\n        request, response = await app.asgi_client.get(\"/\")\n\n# Test that the app handles asyncio.CancelledError in websocket handlers\nasync def test_app_handle_websocket_asyncio_cancelled_error():\n    app = Sanic(\"test_app\")\n\n    @app.websocket(\"/ws\")\n    async def index(request, ws):\n        raise asyncio.CancelledError()\n\n    with pytest.raises(asyncio.CancelledError):\n        async with app.asgi_client.websocket(\"/ws\") as ws:\n            await ws.send(\"\")\n\n# Test that the app can handle background tasks\nasync def test_background_task():\n    app = Sanic(\"test_app\")\n    task_ran = False\n\n    async def background_task(app):\n        nonlocal task_ran\n        task_ran = True\n\n    app.add_task(background_task(app))\n    await asyncio.sleep(0.1)  # Give time for the task to run\n    assert task_ran\n\n# Test that the app can handle exceptions in background tasks\nasync def test_background_task_exception():\n    app = Sanic(\"test_app\")\n\n    async def background_task(app):\n        raise SimpleError()\n\n    app.add_task(background_task(app))\n    await asyncio.sleep(0.1)  # Give time for the task to run\n    # No assertion needed, just ensure no unhandled exceptions\n\n# Test that the app can handle websocket connections\nasync def test_websocket():\n    app = Sanic(\"test_app\")\n\n    @app.websocket(\"/ws\")\n    async def ws_handler(request, ws):\n        data = await ws.recv()\n        await ws.send(data)\n\n    async with app.asgi_client.websocket(\"/ws\") as ws:\n        await ws.send(\"hello\")\n        data = await ws.recv()\n        assert data == \"hello\""
        },
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_asgi.py to test the functionality in sanic/app.py\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.app import ASGIApp\n\n@pytest.fixture\ndef app():\n    app = Sanic(\"test_app\")\n    return app\n\n@pytest.mark.asyncio\nasync def test_handle_request(app):\n    # Test that the handle_request method processes a request correctly\n    request = Mock(spec=Request)\n    request.path = \"/\"\n    request.method = \"GET\"\n    request.headers = {\"host\": \"localhost\"}\n    request.stream = None\n    request.responded = False\n\n    async def handler(request):\n        return HTTPResponse(\"Hello, world!\")\n\n    app.router.add(\"/\", handler, methods=[\"GET\"])\n\n    await app.handle_request(request)\n    assert request.responded\n\n@pytest.mark.asyncio\nasync def test_handle_exception(app):\n    # Test that the handle_exception method handles exceptions correctly\n    request = Mock(spec=Request)\n    request.path = \"/\"\n    request.method = \"GET\"\n    request.headers = {\"host\": \"localhost\"}\n    request.stream = None\n\n    async def handler(request):\n        raise ValueError(\"An error occurred\")\n\n    app.router.add(\"/\", handler, methods=[\"GET\"])\n\n    with pytest.raises(ValueError):\n        await app.handle_request(request)\n\n@pytest.mark.asyncio\nasync def test_dispatch_event(app):\n    # Test that the dispatch method correctly dispatches events\n    event_name = \"test.event\"\n    mock_handler = AsyncMock()\n\n    @app.signal(event_name)\n    async def handle_event(**context):\n        await mock_handler(**context)\n\n    await app.dispatch(event_name, context={\"key\": \"value\"})\n    mock_handler.assert_called_once_with(key=\"value\")\n\n@pytest.mark.asyncio\nasync def test_asgi_lifespan(app):\n    # Test that the ASGI lifespan events are handled correctly\n    asgi_app = ASGIApp(app)\n\n    async def receive():\n        return {\"type\": \"lifespan.startup\"}\n\n    async def send(message):\n        assert message[\"type\"] == \"lifespan.startup.complete\"\n\n    await asgi_app({\"type\": \"lifespan\"}, receive, send)\n\n@pytest.mark.asyncio\nasync def test_websocket_handler(app):\n    # Test that the websocket handler processes messages correctly\n    request = Mock(spec=Request)\n    request.path = \"/ws\"\n    request.method = \"GET\"\n    request.headers = {\"host\": \"localhost\"}\n    request.stream = None\n\n    async def websocket_handler(request, ws):\n        await ws.send(\"Hello, WebSocket!\")\n\n    app.router.add(\"/ws\", websocket_handler, methods=[\"GET\"], websocket=True)\n\n    # Mock WebSocket connection\n    ws = Mock()\n    ws.send = AsyncMock()\n\n    await app._websocket_handler(websocket_handler, request, ws)\n    ws.send.assert_called_once_with(\"Hello, WebSocket!\")"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_json_encoding.py",
        "code": "sanic/response/__init__.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/wrappers/test_response.py",
          "code": "src/quart/wrappers/response.py",
          "code_similarity_score": 0.6822955012321472,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/wrappers/test_response.py to sanic/response/__init__.py\n\nimport pytest\nfrom sanic.response import (\n    BaseHTTPResponse,\n    HTTPResponse,\n    JSONResponse,\n    ResponseStream,\n    empty,\n    file,\n    file_stream,\n    html,\n    json,\n    raw,\n    redirect,\n    text,\n    validate_file,\n    json_dumps,\n)\nfrom io import BytesIO\nfrom pathlib import Path\n\n# Test the empty response function\ndef test_empty_response():\n    response = empty()\n    assert response.status == 204\n    assert response.body == b\"\"\n\n# Test the text response function\ndef test_text_response():\n    response = text(\"Hello, world!\")\n    assert response.status == 200\n    assert response.body == b\"Hello, world!\"\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n# Test the json response function\ndef test_json_response():\n    response = json({\"message\": \"Hello, world!\"})\n    assert response.status == 200\n    assert response.body == b'{\"message\":\"Hello, world!\"}'\n    assert response.content_type == \"application/json\"\n\n# Test the html response function\ndef test_html_response():\n    response = html(\"<p>Hello, world!</p>\")\n    assert response.status == 200\n    assert response.body == b\"<p>Hello, world!</p>\"\n    assert response.content_type == \"text/html; charset=utf-8\"\n\n# Test the raw response function\ndef test_raw_response():\n    response = raw(b\"raw data\")\n    assert response.status == 200\n    assert response.body == b\"raw data\"\n    assert response.content_type == \"application/octet-stream\"\n\n# Test the redirect response function\ndef test_redirect_response():\n    response = redirect(\"/new-location\")\n    assert response.status == 302\n    assert response.headers[\"Location\"] == \"/new-location\"\n\n# Test the file response function\ndef test_file_response(tmp_path: Path):\n    file_path = tmp_path / \"test.txt\"\n    file_path.write_text(\"file content\")\n    response = file(file_path)\n    assert response.status == 200\n    assert response.body == b\"file content\"\n    assert response.content_type == \"text/plain; charset=utf-8\"\n\n# Test the file_stream response function\nasync def test_file_stream_response(tmp_path: Path):\n    file_path = tmp_path / \"test.txt\"\n    file_path.write_text(\"file content\")\n    response = await file_stream(file_path)\n    assert response.status == 200\n    assert response.content_type == \"text/plain; charset=utf-8\"\n    body = b\"\".join([chunk async for chunk in response.stream()])\n    assert body == b\"file content\"\n\n# Test the validate_file function\ndef test_validate_file(tmp_path: Path):\n    file_path = tmp_path / \"test.txt\"\n    file_path.write_text(\"file content\")\n    assert validate_file(file_path) is True\n\n# Test the json_dumps function\ndef test_json_dumps():\n    data = {\"key\": \"value\"}\n    result = json_dumps(data)\n    assert result == '{\"key\":\"value\"}'"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_keep_alive_timeout.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_sync.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6635478734970093,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_sync.py in the donor to test functionality in sanic/app.py\n\nfrom __future__ import annotations\n\nimport threading\nfrom collections.abc import Generator\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\n\n@pytest.fixture(name=\"app\")\ndef _app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def index(request: Request) -> HTTPResponse:\n        return HTTPResponse(request.method)\n\n    @app.route(\"/gen\")\n    async def gen(request: Request) -> HTTPResponse:\n        def _gen() -> Generator[bytes, None, None]:\n            yield b\"%d\" % threading.current_thread().ident\n            for _ in range(2):\n                yield b\"b\"\n\n        return HTTPResponse(body=_gen(), status=200)\n\n    return app\n\n\n@pytest.fixture(name=\"test_client\")\ndef _test_client(app: Sanic) -> SanicTestClient:\n    return app.test_client\n\n\nasync def test_sync_request_context(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/\")\n    assert b\"GET\" in response.body\n    request, response = await test_client.post(\"/\")\n    assert b\"POST\" in response.body\n\n\nasync def test_sync_generator(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/gen\")\n    result = response.body\n    assert result[-2:] == b\"bb\"\n    assert int(result[:-2]) != threading.current_thread().ident"
        },
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by transplanting tests from tests/test_asgi.py to sanic/app.py\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.app import ASGIApp\nfrom sanic.exceptions import SanicException\n\n@pytest.fixture\ndef app():\n    return Sanic(\"test_app\")\n\n@pytest.fixture\ndef asgi_app(app):\n    return ASGIApp(app)\n\n@pytest.mark.asyncio\nasync def test_handle_request(app):\n    # Test that handle_request processes a request correctly\n    request = Request(b\"/\", {}, \"GET\", \"http\", app)\n    response = HTTPResponse(\"Hello, world!\")\n    \n    async def handler(request):\n        return response\n\n    app.router.add(\"/test\", handler, methods=[\"GET\"])\n    request.path = \"/test\"\n    await app.handle_request(request)\n    assert request.stream.response.body == b\"Hello, world!\"\n\n@pytest.mark.asyncio\nasync def test_handle_exception(app):\n    # Test that handle_exception handles exceptions correctly\n    request = Request(b\"/\", {}, \"GET\", \"http\", app)\n    \n    async def handler(request):\n        raise ValueError(\"Test exception\")\n\n    app.router.add(\"/test\", handler, methods=[\"GET\"])\n    request.path = \"/test\"\n    with pytest.raises(ValueError):\n        await app.handle_request(request)\n\n@pytest.mark.asyncio\nasync def test_dispatch_event(app):\n    # Test that dispatch can trigger an event\n    event_triggered = False\n\n    @app.signal(\"test.event\")\n    async def event_handler():\n        nonlocal event_triggered\n        event_triggered = True\n\n    await app.dispatch(\"test.event\")\n    assert event_triggered\n\n@pytest.mark.asyncio\nasync def test_add_task(app):\n    # Test that add_task schedules a task correctly\n    task_completed = False\n\n    async def task():\n        nonlocal task_completed\n        task_completed = True\n\n    app.add_task(task())\n    await asyncio.sleep(0.1)  # Allow the task to complete\n    assert task_completed\n\n@pytest.mark.asyncio\nasync def test_websocket_handler(app):\n    # Test that websocket handler processes messages correctly\n    request = Request(b\"/\", {}, \"GET\", \"http\", app)\n    request.transport = Mock()\n    request.transport.get_websocket_connection = Mock(return_value=AsyncMock())\n\n    async def websocket_handler(request, ws):\n        await ws.send(\"Hello, websocket!\")\n\n    app.router.add(\"/ws\", websocket_handler, methods=[\"GET\"], websocket=True)\n    request.path = \"/ws\"\n    await app.handle_request(request)\n\n    ws = request.transport.get_websocket_connection()\n    ws.send.assert_called_with(\"Hello, websocket!\")\n\n@pytest.mark.asyncio\nasync def test_asgi_lifespan(asgi_app):\n    # Test that ASGI lifespan events are handled correctly\n    receive = AsyncMock()\n    send = AsyncMock()\n\n    receive.side_effect = [\n        {\"type\": \"lifespan.startup\"},\n        {\"type\": \"lifespan.shutdown\"},\n    ]\n\n    await asgi_app({\"type\": \"lifespan\"}, receive, send)\n\n    send.assert_any_call({\"type\": \"lifespan.startup.complete\"})\n    send.assert_any_call({\"type\": \"lifespan.shutdown.complete\"})\n\n@pytest.mark.asyncio\nasync def test_url_for(app):\n    # Test that url_for constructs URLs correctly\n    async def handler(request):\n        return HTTPResponse(\"Hello, world!\")\n\n    app.router.add(\"/test\", handler, methods=[\"GET\"], name=\"test_handler\")\n    url = app.url_for(\"test_handler\")\n    assert url == \"/test\"\n\n    url_with_params = app.url_for(\"test_handler\", _external=True, _scheme=\"https\")\n    assert url_with_params.startswith(\"https://\")"
        },
        {
          "framework": "quart",
          "test": "tests/test_background_tasks.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6877192258834839,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_background_tasks.py in the donor project to sanic/app.py in the host project\n\nimport asyncio\nimport time\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import text\n\n\n@pytest.fixture\ndef app():\n    app = Sanic(\"test_app\")\n    app.config.DATA = \"data\"\n    return app\n\n\n# Test to ensure background tasks are executed correctly\nasync def test_background_task(app):\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n    # Wait for the background task to complete\n    await asyncio.sleep(0.6)\n    assert data == \"data\"\n\n\n# Test to ensure background tasks can be added during server startup\nasync def test_lifespan_background_task(app):\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.main_process_start\n    async def startup(app, loop):\n        app.add_task(background)\n\n    async with app.test_client() as client:\n        pass\n\n    # Wait for the background task to complete\n    await asyncio.sleep(0.6)\n    assert data == \"data\"\n\n\n# Test to ensure synchronous background tasks are executed correctly\nasync def test_sync_background_task(app):\n    data = None\n\n    def background():\n        nonlocal data\n        time.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n    # Wait for the background task to complete\n    await asyncio.sleep(0.6)\n    assert data == \"data\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_late_adds.py",
        "code": "sanic/app.py"
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_sync.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6635478734970093,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_sync.py to test sanic/app.py\n\nfrom __future__ import annotations\n\nimport threading\nfrom collections.abc import Generator\n\nimport pytest\n\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\n\n@pytest.fixture(name=\"app\")\ndef _app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def index(request: Request) -> HTTPResponse:\n        return HTTPResponse(request.method)\n\n    @app.route(\"/gen\")\n    async def gen(request: Request) -> HTTPResponse:\n        def _gen() -> Generator[bytes, None, None]:\n            yield b\"%d\" % threading.current_thread().ident\n            for _ in range(2):\n                yield b\"b\"\n\n        return HTTPResponse(body=_gen(), status=200)\n\n    return app\n\n\n@pytest.fixture(name=\"test_client\")\ndef _test_client(app: Sanic) -> SanicTestClient:\n    return app.test_client\n\n\n@pytest.mark.asyncio\nasync def test_sync_request_context(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/\")\n    assert b\"GET\" in response.body\n    request, response = await test_client.post(\"/\")\n    assert b\"POST\" in response.body\n\n\n@pytest.mark.asyncio\nasync def test_sync_generator(test_client: SanicTestClient) -> None:\n    request, response = await test_client.get(\"/gen\")\n    result = response.body\n    assert result[-2:] == b\"bb\"\n    assert int(result[:-2]) != threading.current_thread().ident"
        },
        {
          "framework": "quart",
          "test": "tests/test_background_tasks.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6877192258834839,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_background_tasks.py to sanic/app.py\n\nimport asyncio\nimport time\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import text\n\n\n@pytest.fixture\ndef app():\n    app = Sanic(\"test_app\")\n    app.config.DATA = \"data\"\n    return app\n\n\n# Test to ensure a background task can be added and executed\nasync def test_background_task(app):\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n    # Allow some time for the background task to complete\n    await asyncio.sleep(0.6)\n    assert data == \"data\"\n\n\n# Test to ensure a background task can be added during the lifespan of the app\nasync def test_lifespan_background_task(app):\n    data = None\n\n    async def background():\n        nonlocal data\n        await asyncio.sleep(0.5)\n        data = app.config.DATA\n\n    @app.main_process_start\n    async def startup(app, loop):\n        app.add_task(background)\n\n    async with app.test_client() as client:\n        pass\n\n    assert data == \"data\"\n\n\n# Test to ensure a synchronous background task can be added and executed\nasync def test_sync_background_task(app):\n    data = None\n\n    def background():\n        nonlocal data\n        time.sleep(0.5)\n        data = app.config.DATA\n\n    @app.route(\"/\")\n    async def index(request):\n        app.add_task(background)\n        return text(\"\")\n\n    request, response = await app.asgi_client.get(\"/\")\n    assert response.status == 200\n\n    # Allow some time for the background task to complete\n    await asyncio.sleep(0.6)\n    assert data == \"data\""
        },
        {
          "framework": "quart",
          "test": "tests/test_app.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6890430450439453,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_app.py in the donor project to sanic/app.py in the host project through test transplantation.\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import NoReturn\nfrom unittest.mock import AsyncMock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.exceptions import SanicException\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.testing import SanicTestClient\n\nTEST_RESPONSE = HTTPResponse(\"\")\n\n\nclass SimpleError(Exception):\n    pass\n\n\ndef test_endpoint_overwrite() -> None:\n    app = Sanic(\"test_app\")\n\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    async def route2(request):\n        return HTTPResponse(\"\")\n\n    app.add_route(route, \"/a\", methods=[\"GET\"])\n    app.add_route(route, \"/a/a\", methods=[\"GET\"])  # Should not assert, as same view func\n    with pytest.raises(SanicException):\n        app.add_route(route2, \"/a/b\", methods=[\"GET\"])\n\n\n@pytest.mark.parametrize(\n    \"methods, expected_methods\",\n    [\n        ([\"GET\"], {\"GET\", \"HEAD\"}),\n        ([\"GET\", \"POST\"], {\"GET\", \"POST\", \"HEAD\"}),\n    ],\n)\ndef test_add_route_methods(methods, expected_methods) -> None:\n    app = Sanic(\"test_app\")\n\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    app.add_route(route, \"/\", methods=methods)\n    route_obj = app.router.routes_all[0]\n    assert set(route_obj.methods) == expected_methods\n\n\nasync def test_host_matching() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\", host=\"quart.com\")\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    test_client = SanicTestClient(app)\n    request, response = await test_client.get(\"/\", headers={\"host\": \"quart.com\"})\n    assert response.status == 200\n\n    request, response = await test_client.get(\"/\", headers={\"host\": \"localhost\"})\n    assert response.status == 404\n\n\n@pytest.mark.parametrize(\n    \"result, expected, raises\",\n    [\n        (None, None, True),\n        (TEST_RESPONSE, TEST_RESPONSE, False),\n        ((\"hello\", 201), HTTPResponse(\"hello\", status=201), False),\n        (int, None, True),\n    ],\n)\nasync def test_make_response(result, expected, raises) -> None:\n    app = Sanic(\"test_app\")\n\n    try:\n        response = await app._run_request_middleware(result, [])\n    except TypeError:\n        if not raises:\n            raise\n    else:\n        assert response.status == expected.status\n        assert response.body == expected.body\n\n\n@pytest.fixture(name=\"basic_app\")\ndef _basic_app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def route(request):\n        return HTTPResponse(\"\")\n\n    @app.route(\"/exception/\")\n    async def exception(request):\n        raise Exception()\n\n    return app\n\n\nasync def test_app_route_exception(basic_app: Sanic) -> None:\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/exception/\")\n    assert response.status == 500\n\n\nasync def test_app_before_request_exception(basic_app: Sanic) -> None:\n    @basic_app.middleware(\"request\")\n    async def before(request):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_after_request_exception(basic_app: Sanic) -> None:\n    @basic_app.middleware(\"response\")\n    async def after(request, response):\n        raise Exception()\n\n    test_client = SanicTestClient(basic_app)\n    request, response = await test_client.get(\"/\")\n    assert response.status == 500\n\n\nasync def test_app_handle_request_asyncio_cancelled_error() -> None:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def index(request):\n        raise asyncio.CancelledError()\n\n    request = Request(b\"\", app, \"GET\", \"/\")\n    with pytest.raises(asyncio.CancelledError):\n        await app.handle_request(request)\n\n\n@pytest.mark.parametrize(\n    \"debug, test_mode, raises\",\n    [\n        (False, False, False),\n        (True, False, True),\n        (False, True, True),\n        (True, True, True),\n    ],\n)\nasync def test_propagation(debug, test_mode, raises) -> None:\n    app = Sanic(\"test_app\")\n    app.config.DEBUG = debug\n    app.test_mode = test_mode\n\n    @app.route(\"/\")\n    async def exception(request):\n        raise SimpleError()\n\n    test_client = SanicTestClient(app)\n\n    if raises:\n        with pytest.raises(SimpleError):\n            request, response = await test_client.get(\"/\")\n    else:\n        request, response = await test_client.get(\"/\")\n        assert response.status == 500"
        },
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_asgi.py to test the functionality in sanic/app.py\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.app import ASGIApp\nfrom sanic.asgi import Lifespan\n\n\n@pytest.mark.asyncio\nasync def test_handle_request():\n    # Create a mock Sanic app\n    app = Sanic(\"test_app\")\n\n    # Define a simple handler\n    @app.route(\"/\")\n    async def handler(request):\n        return HTTPResponse(\"Hello, world!\")\n\n    # Create a mock request\n    request = Request(b\"/\", {}, app)\n\n    # Call the handle_request method\n    await app.handle_request(request)\n\n    # Assert that the response is as expected\n    assert request.stream.response.body == b\"Hello, world!\"\n\n\n@pytest.mark.asyncio\nasync def test_handle_exception():\n    # Create a mock Sanic app\n    app = Sanic(\"test_app\")\n\n    # Define a handler that raises an exception\n    @app.route(\"/\")\n    async def handler(request):\n        raise ValueError(\"An error occurred\")\n\n    # Create a mock request\n    request = Request(b\"/\", {}, app)\n\n    # Call the handle_request method and handle exception\n    await app.handle_request(request)\n\n    # Assert that the response is a 500 error\n    assert request.stream.response.status == 500\n\n\n@pytest.mark.asyncio\nasync def test_asgi_lifespan():\n    # Create a mock Sanic app\n    app = Sanic(\"test_app\")\n\n    # Create a mock scope\n    scope = {\"type\": \"lifespan\"}\n\n    # Create a mock receive and send\n    async def receive():\n        return {\"type\": \"lifespan.startup\"}\n\n    async def send(message):\n        assert message[\"type\"] == \"lifespan.startup.complete\"\n\n    # Create an ASGI Lifespan instance\n    lifespan = Lifespan(app, scope, receive, send)\n\n    # Call the lifespan\n    await lifespan()\n\n\n@pytest.mark.asyncio\nasync def test_asgi_app():\n    # Create a mock Sanic app\n    app = Sanic(\"test_app\")\n\n    # Create a mock scope\n    scope = {\"type\": \"http\"}\n\n    # Create a mock receive and send\n    async def receive():\n        return {\"type\": \"http.request\", \"body\": b\"\", \"more_body\": False}\n\n    async def send(message):\n        assert message[\"type\"] == \"http.response.start\"\n\n    # Create an ASGI App instance\n    asgi_app = await ASGIApp.create(app, scope, receive, send)\n\n    # Call the ASGI app\n    await asgi_app()\n\n\n@pytest.mark.asyncio\nasync def test_dispatch_event():\n    # Create a mock Sanic app\n    app = Sanic(\"test_app\")\n\n    # Define a signal handler\n    @app.signal(\"test.event\")\n    async def handler(**context):\n        assert context[\"data\"] == \"test\"\n\n    # Dispatch the event\n    await app.dispatch(\"test.event\", context={\"data\": \"test\"})\n\n\n@pytest.mark.asyncio\nasync def test_add_task():\n    # Create a mock Sanic app\n    app = Sanic(\"test_app\")\n\n    # Define a simple task\n    async def task():\n        await asyncio.sleep(0.1)\n        return \"task completed\"\n\n    # Add the task to the app\n    app.add_task(task(), name=\"test_task\")\n\n    # Retrieve the task\n    task = app.get_task(\"test_task\")\n\n    # Assert that the task is not None\n    assert task is not None\n\n    # Wait for the task to complete\n    result = await task\n\n    # Assert that the task result is as expected\n    assert result == \"task completed\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_prepare.py",
        "code": [
          "sanic/app.py",
          "sanic/application/state.py"
        ]
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/test_asgi.py to test sanic/app.py through test transplantation.\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.app import ASGIApp\nfrom sanic.application.state import ApplicationState\nfrom sanic.exceptions import SanicException\n\n# Test to ensure that the ASGI application can handle HTTP requests\nasync def test_http_request_handling():\n    app = Sanic(\"test_app\")\n    app.state = ApplicationState(app)\n    \n    @app.route(\"/\")\n    async def handler(request):\n        return HTTPResponse(\"Hello, world!\")\n\n    scope = {\n        \"type\": \"http\",\n        \"asgi\": {},\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"scheme\": \"http\",\n        \"path\": \"/\",\n        \"query_string\": b\"\",\n        \"headers\": [(b\"host\", b\"localhost\")],\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n    }\n    \n    asgi_app = await ASGIApp.create(app, scope, None, None)\n    assert asgi_app is not None\n\n# Test to ensure that the ASGI application can handle WebSocket connections\nasync def test_websocket_handling():\n    app = Sanic(\"test_app\")\n    app.state = ApplicationState(app)\n    \n    @app.websocket(\"/ws\")\n    async def handler(request, ws):\n        await ws.send(\"Hello, world!\")\n    \n    scope = {\n        \"type\": \"websocket\",\n        \"asgi\": {},\n        \"http_version\": \"1.1\",\n        \"scheme\": \"ws\",\n        \"path\": \"/ws\",\n        \"query_string\": b\"\",\n        \"headers\": [(b\"host\", b\"localhost\")],\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n    }\n    \n    asgi_app = await ASGIApp.create(app, scope, None, None)\n    assert asgi_app is not None\n\n# Test to ensure that exceptions are handled correctly\nasync def test_exception_handling():\n    app = Sanic(\"test_app\")\n    app.state = ApplicationState(app)\n    \n    @app.route(\"/error\")\n    async def handler(request):\n        raise SanicException(\"Test exception\")\n    \n    scope = {\n        \"type\": \"http\",\n        \"asgi\": {},\n        \"http_version\": \"1.1\",\n        \"method\": \"GET\",\n        \"scheme\": \"http\",\n        \"path\": \"/error\",\n        \"query_string\": b\"\",\n        \"headers\": [(b\"host\", b\"localhost\")],\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n    }\n    \n    asgi_app = await ASGIApp.create(app, scope, None, None)\n    assert asgi_app is not None\n\n# Test to ensure that the application can handle ASGI lifespan events\nasync def test_lifespan_events():\n    app = Sanic(\"test_app\")\n    app.state = ApplicationState(app)\n    \n    scope = {\n        \"type\": \"lifespan\",\n        \"asgi\": {},\n    }\n    \n    asgi_app = await ASGIApp.create(app, scope, None, None)\n    assert asgi_app is not None"
        },
        {
          "framework": "quart",
          "test": "tests/test_basic.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6785894632339478,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_basic.py (donor) to sanic/app.py (host)\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import json, text\nfrom sanic.exceptions import SanicException\nfrom sanic_testing import TestManager\n\n@pytest.fixture\ndef app():\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def index(request):\n        return text(\"index\")\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    async def json_endpoint(request):\n        data = request.json\n        return json(data)\n\n    @app.route(\"/error\")\n    async def error(request):\n        raise SanicException(\"Something went wrong\", status_code=409)\n\n    @app.route(\"/param/<value>\")\n    async def param(request, value):\n        return text(value)\n\n    @app.websocket(\"/ws\")\n    async def websocket_handler(request, ws):\n        while True:\n            data = await ws.recv()\n            await ws.send(data)\n\n    return app\n\n@pytest.mark.parametrize(\"path\", [\"/\"])\nasync def test_index(app, path):\n    test_client = app.test_client\n    request, response = await test_client.get(path)\n    assert response.status == 200\n    assert response.text == \"index\"\n\nasync def test_json(app):\n    test_client = app.test_client\n    request, response = await test_client.post(\"/json\", json={\"key\": \"value\"})\n    assert response.status == 200\n    assert response.json == {\"key\": \"value\"}\n\nasync def test_error(app):\n    test_client = app.test_client\n    request, response = await test_client.get(\"/error\")\n    assert response.status == 409\n    assert response.text == \"Something went wrong\"\n\nasync def test_param(app):\n    test_client = app.test_client\n    request, response = await test_client.get(\"/param/test_value\")\n    assert response.status == 200\n    assert response.text == \"test_value\"\n\nasync def test_websocket(app):\n    test_client = app.test_client\n    async with test_client.websocket(\"/ws\") as ws:\n        await ws.send(\"hello\")\n        data = await ws.recv()\n        assert data == \"hello\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_response_file.py",
        "code": [
          "sanic/response/convenience.py"
        ]
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/wrappers/test_response.py",
          "code": "src/quart/wrappers/response.py",
          "code_similarity_score": 0.6822955012321472,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated from tests/wrappers/test_response.py to test sanic/response/convenience.py through test transplantation.\n\nimport pytest\nfrom datetime import datetime, timezone\nfrom io import BytesIO\nfrom pathlib import Path\nfrom sanic.response.convenience import (\n    empty,\n    json,\n    text,\n    raw,\n    html,\n    validate_file,\n    file,\n    redirect,\n    file_stream,\n)\nfrom sanic.models.protocol_types import Range\nfrom sanic.compat import Header\nfrom sanic.helpers import Default\n\n# Test the empty response function\ndef test_empty_response():\n    response = empty()\n    assert response.status == 204\n    assert response.body == b\"\"\n\n# Test the JSON response function\ndef test_json_response():\n    response = json({\"key\": \"value\"})\n    assert response.status == 200\n    assert response.content_type == \"application/json\"\n    assert response.body == b'{\"key\": \"value\"}'\n\n# Test the text response function\ndef test_text_response():\n    response = text(\"Hello, World!\")\n    assert response.status == 200\n    assert response.content_type == \"text/plain; charset=utf-8\"\n    assert response.body == \"Hello, World!\"\n\n# Test the raw response function\ndef test_raw_response():\n    response = raw(b\"raw data\")\n    assert response.status == 200\n    assert response.content_type == \"application/octet-stream\"\n    assert response.body == b\"raw data\"\n\n# Test the HTML response function\ndef test_html_response():\n    response = html(\"<h1>Hello</h1>\")\n    assert response.status == 200\n    assert response.content_type == \"text/html; charset=utf-8\"\n    assert response.body == \"<h1>Hello</h1>\"\n\n# Test the redirect function\ndef test_redirect():\n    response = redirect(\"/new-location\")\n    assert response.status == 302\n    assert response.headers[\"Location\"] == \"/new-location\"\n\n# Test the validate_file function\n@pytest.mark.asyncio\nasync def test_validate_file():\n    headers = Header({\"If-Modified-Since\": \"Wed, 21 Oct 2015 07:28:00 GMT\"})\n    last_modified = datetime(2015, 10, 21, 7, 28, tzinfo=timezone.utc)\n    response = await validate_file(headers, last_modified)\n    assert response.status == 304\n\n# Test the file response function\n@pytest.mark.asyncio\nasync def test_file_response(tmp_path: Path):\n    file_path = tmp_path / \"test_file.txt\"\n    file_path.write_text(\"file content\")\n    response = await file(file_path)\n    assert response.status == 200\n    assert response.body == b\"file content\"\n\n# Test the file_stream response function\n@pytest.mark.asyncio\nasync def test_file_stream_response(tmp_path: Path):\n    file_path = tmp_path / \"test_file.txt\"\n    file_path.write_text(\"stream content\")\n    response = await file_stream(file_path)\n    chunks = []\n    async for chunk in response.streaming_fn(response):\n        chunks.append(chunk)\n    assert b\"\".join(chunks) == b\"stream content\""
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_static.py",
        "code": [
          "sanic/app.py",
          "sanic/request/__init__.py",
          "sanic/response/__init__.py",
          "sanic/exceptions.py"
        ]
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_asgi.py",
          "code": "src/quart/asgi.py",
          "code_similarity_score": 0.6668426990509033,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_asgi.py\n# to test the functionality in sanic/app.py through test transplantation.\n\nimport asyncio\nfrom unittest.mock import AsyncMock, Mock\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.request import Request\nfrom sanic.response import HTTPResponse\nfrom sanic.exceptions import SanicException, ServerError\nfrom sanic.app import ASGIApp\n\n@pytest.fixture\ndef app():\n    return Sanic(\"test_app\")\n\n@pytest.mark.asyncio\nasync def test_handle_request(app):\n    # Test that handle_request processes a request and returns a response\n    request = Request(b\"/\", {}, \"GET\", \"http\", \"1.1\", None, None, None, None)\n    response = HTTPResponse(\"Hello, world!\")\n    \n    async def handler(request):\n        return response\n    \n    app.router.add(\"/test\", handler, methods=[\"GET\"])\n    \n    request._match_info = {}\n    request.route = app.router.routes[0]\n    \n    await app.handle_request(request)\n    assert request.stream.response == response\n\n@pytest.mark.asyncio\nasync def test_handle_exception(app):\n    # Test that handle_exception processes an exception and returns an error response\n    request = Request(b\"/\", {}, \"GET\", \"http\", \"1.1\", None, None, None, None)\n    \n    async def handler(request):\n        raise SanicException(\"Test exception\", status_code=500)\n    \n    app.router.add(\"/test\", handler, methods=[\"GET\"])\n    \n    request._match_info = {}\n    request.route = app.router.routes[0]\n    \n    with pytest.raises(SanicException):\n        await app.handle_request(request)\n\n@pytest.mark.asyncio\nasync def test_dispatch_event(app):\n    # Test that dispatch sends an event to the signal router\n    event_name = \"test.event\"\n    mock_handler = AsyncMock()\n    \n    app.signal(event_name)(mock_handler)\n    \n    await app.dispatch(event_name, context={\"key\": \"value\"})\n    mock_handler.assert_awaited_once_with(app, key=\"value\")\n\n@pytest.mark.asyncio\nasync def test_asgi_lifespan(app):\n    # Test that ASGI lifespan events are handled correctly\n    scope = {\"type\": \"lifespan\"}\n    receive = AsyncMock()\n    send = AsyncMock()\n    \n    app.asgi = True\n    asgi_app = ASGIApp(app, scope, receive, send)\n    \n    await asgi_app(scope, receive, send)\n    send.assert_any_call({\"type\": \"lifespan.startup.complete\"})\n    send.assert_any_call({\"type\": \"lifespan.shutdown.complete\"})\n\n@pytest.mark.asyncio\nasync def test_asgi_http_connection(app):\n    # Test that ASGI HTTP connections are handled correctly\n    scope = {\n        \"type\": \"http\",\n        \"method\": \"GET\",\n        \"path\": \"/\",\n        \"headers\": [],\n        \"query_string\": b\"\",\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n    }\n    receive = AsyncMock()\n    send = AsyncMock()\n    \n    asgi_app = ASGIApp(app, scope, receive, send)\n    \n    await asgi_app(scope, receive, send)\n    send.assert_any_call({\"type\": \"http.response.start\", \"status\": 404, \"headers\": []})\n\n@pytest.mark.asyncio\nasync def test_asgi_websocket_connection(app):\n    # Test that ASGI WebSocket connections are handled correctly\n    scope = {\n        \"type\": \"websocket\",\n        \"path\": \"/ws\",\n        \"headers\": [],\n        \"query_string\": b\"\",\n        \"client\": (\"127.0.0.1\", 80),\n        \"server\": None,\n    }\n    receive = AsyncMock()\n    send = AsyncMock()\n    \n    asgi_app = ASGIApp(app, scope, receive, send)\n    \n    await asgi_app(scope, receive, send)\n    send.assert_any_call({\"type\": \"websocket.close\", \"code\": 1000})"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_tasks.py",
        "code": [
          "sanic/app.py",
          "sanic/application/state.py"
        ]
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_app.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6890430450439453,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "```python\n# This test file was generated by adapting tests from tests/test_app.py (donor) to sanic/app.py (host)\n\nimport asyncio\nfrom unittest.mock import AsyncMock\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import text\nfrom sanic.exceptions import SanicException\nfrom sanic.models.futures import FutureRoute\nfrom sanic.request import Request\nfrom sanic.handlers import ErrorHandler\nfrom sanic.models.handler_types import MiddlewareType\nfrom sanic.middleware import Middleware\nfrom sanic.signals import Signal\nfrom sanic.application.state import ApplicationState\nfrom sanic.models.handler_types import ListenerType\nfrom sanic.models.futures import FutureListener\nfrom sanic.models.futures import FutureMiddleware\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures import FutureSignal\nfrom sanic.models.futures import FutureException\nfrom sanic.models.futures import FutureRegistry\nfrom sanic.models.futures import FutureRoute\nfrom sanic.models.futures"
        },
        {
          "framework": "quart",
          "test": "tests/test_basic.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6785894632339478,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# This test file was generated by adapting tests from tests/test_basic.py\n# to test the functionality in sanic/app.py through test transplantation.\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import json, text\nfrom sanic.exceptions import SanicException\nfrom sanic_testing import TestManager\nfrom sanic_testing.testing import SanicTestClient\n\n@pytest.fixture\ndef app() -> Sanic:\n    app = Sanic(\"test_app\")\n\n    @app.route(\"/\")\n    async def index(request):\n        return text(\"index\")\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    async def json_endpoint(request):\n        data = request.json\n        return json(data)\n\n    @app.route(\"/error\")\n    async def error(request):\n        raise SanicException(\"Something went wrong\", status_code=409)\n\n    @app.route(\"/param/<value>\")\n    async def param(request, value):\n        return text(value)\n\n    return app\n\ndef test_index(app: Sanic):\n    test_client = SanicTestClient(app)\n    request, response = test_client.get(\"/\")\n    assert response.status_code == 200\n    assert response.text == \"index\"\n\ndef test_json(app: Sanic):\n    test_client = SanicTestClient(app)\n    request, response = test_client.post(\"/json\", json={\"key\": \"value\"})\n    assert response.status_code == 200\n    assert response.json == {\"key\": \"value\"}\n\ndef test_error(app: Sanic):\n    test_client = SanicTestClient(app)\n    request, response = test_client.get(\"/error\")\n    assert response.status_code == 409\n    assert response.text == \"Something went wrong\"\n\ndef test_param(app: Sanic):\n    test_client = SanicTestClient(app)\n    request, response = test_client.get(\"/param/test_value\")\n    assert response.status_code == 200\n    assert response.text == \"test_value\"\n\ndef test_not_found(app: Sanic):\n    test_client = SanicTestClient(app)\n    request, response = test_client.get(\"/not_found\")\n    assert response.status_code == 404"
        }
      ]
    },
    {
      "host_item": {
        "test": "tests/test_url_for.py",
        "code": [
          "sanic/__init__.py",
          "sanic/app.py",
          "sanic/blueprints.py"
        ]
      },
      "similar_items": [
        {
          "framework": "quart",
          "test": "tests/test_static_hosting.py",
          "code": "src/quart/app.py",
          "code_similarity_score": 0.6516069173812866,
          "transplant_analysis": "None",
          "additional_files_info": {
            "host_files_needed": "None",
            "donor_files_needed": "None"
          },
          "generated_test": "# Transplanted from tests/test_static_hosting.py in Quart to sanic/app.py in Sanic\n\nimport pytest\nfrom sanic import Sanic\nfrom sanic.response import file\nfrom pathlib import Path\n\n# Define a fixture for the Sanic app\n@pytest.fixture\ndef app():\n    app = Sanic(\"test_app\")\n\n    # Define a route to serve static files\n    @app.route(\"/static/<filename:path>\")\n    async def static(request, filename):\n        return await file(Path(__file__).parent / \"assets\" / filename)\n\n    return app\n\n# Test the static file serving functionality\n@pytest.mark.asyncio\nasync def test_static_file_serving(app):\n    test_client = app.test_client\n\n    # Test that a valid static file is served correctly\n    request, response = await test_client.get(\"/static/config.cfg\")\n    assert response.status == 200\n    expected_data = (Path(__file__).parent / \"assets/config.cfg\").read_bytes()\n    assert response.body == expected_data\n\n    # Test that a non-existent file returns 404\n    request, response = await test_client.get(\"/static/foo\")\n    assert response.status == 404\n\n    # Test that path traversal is not allowed\n    request, response = await test_client.get(\"/static/../foo\")\n    assert response.status == 404\n\n    request, response = await test_client.get(\"/static/../assets/config.cfg\")\n    assert response.status == 404\n\n    # Test that non-escaping path with .. is allowed if it resolves within the static folder\n    request, response = await test_client.get(\"/static/foo/../config.cfg\")\n    assert response.status == 200\n    assert response.body == expected_data"
        }
      ]
    }
  ]
}