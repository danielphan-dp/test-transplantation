Running static analysis...

Analyzing tests...

================================================================================
Test: test_index
File: __internal__/_data/flask/examples/javascript/tests/test_js_example.py

Methods Under Test (Static Analysis):
  - template_rendered.connected_to (:0)
  - template_rendered.connected_to (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - template_rendered.connected_to (:0)
    Called by: test_index
  - client.get (:0)
    Called by: test_index

Test Source Code:
  def test_index(app, client, path, template_name):
      def check(sender, template, context):
          assert template.name == template_name
  
      with template_rendered.connected_to(check, app):
          client.get(path)

Assertions:
  - assert template.name == template_name

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_index.json

================================================================================
Test: test_add
File: __internal__/_data/flask/examples/javascript/tests/test_js_example.py

Methods Under Test (Static Analysis):
  - client.post (:0)
  - response.get_json (:0)

Methods Actually Called (Dynamic Analysis):
  - client.post (:0)
    Called by: test_add
  - response.get_json (:0)
    Called by: test_add

Test Source Code:
  def test_add(client, a, b, result):
      response = client.post("/add", data={"a": a, "b": b})
      assert response.get_json()["result"] == result

Assertions:
  - assert response.get_json()['result'] == result

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add.json

================================================================================
Test: test_get_close_db
File: __internal__/_data/flask/examples/tutorial/tests/test_db.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.app_context (:0)
  - get_db (db.py:9)
    Source code:
      def get_db():
          """Connect to the application's configured database. The connection
          is unique for each request and will be reused if this is called
          again.
          """
          if "db" not in g:
              g.db = sqlite3.connect(
                  current_app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES
              )
              g.db.row_factory = sqlite3.Row
      
          return g.db
  - db.execute (:0)
  - str (:0)
  - get_db (db.py:9)
    Source code:
      def get_db():
          """Connect to the application's configured database. The connection
          is unique for each request and will be reused if this is called
          again.
          """
          if "db" not in g:
              g.db = sqlite3.connect(
                  current_app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES
              )
              g.db.row_factory = sqlite3.Row
      
          return g.db

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_get_close_db
  - get_db (db.py:9)
    Called by: test_get_close_db
  - db.execute (:0)
    Called by: test_get_close_db
  - str (:0)
    Called by: test_get_close_db

Test Source Code:
  def test_get_close_db(app):
      with app.app_context():
          db = get_db()
          assert db is get_db()
  
      with pytest.raises(sqlite3.ProgrammingError) as e:
          db.execute("SELECT 1")
  
      assert "closed" in str(e.value)

Assertions:
  - assert 'closed' in str(e.value)
  - assert db is get_db()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_get_close_db.json

================================================================================
Test: test_init_db_command
File: __internal__/_data/flask/examples/tutorial/tests/test_db.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_init_db_command
  - runner.invoke (:0)
    Called by: test_init_db_command

Test Source Code:
  def test_init_db_command(runner, monkeypatch):
      class Recorder:
          called = False
  
      def fake_init_db():
          Recorder.called = True
  
      monkeypatch.setattr("flaskr.db.init_db", fake_init_db)
      result = runner.invoke(args=["init-db"])
      assert "Initialized" in result.output
      assert Recorder.called

Assertions:
  - assert 'Initialized' in result.output
  - assert Recorder.called

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_init_db_command.json

================================================================================
Test: test_register
File: __internal__/_data/flask/examples/tutorial/tests/test_auth.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - client.post (:0)
  - app.app_context (:0)
  - client.get (:0)
  - get_db.execute.fetchone (:0)
  - get_db.execute (:0)
  - get_db (db.py:9)
    Source code:
      def get_db():
          """Connect to the application's configured database. The connection
          is unique for each request and will be reused if this is called
          again.
          """
          if "db" not in g:
              g.db = sqlite3.connect(
                  current_app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES
              )
              g.db.row_factory = sqlite3.Row
      
          return g.db

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_register
  - client.post (:0)
    Called by: test_register
  - client.get (:0)
    Called by: test_register
  - get_db.execute.fetchone (:0)
    Called by: test_register
  - get_db.execute (:0)
    Called by: test_register
  - get_db (db.py:9)
    Called by: test_register

Test Source Code:
  def test_register(client, app):
      # test that viewing the page renders without template errors
      assert client.get("/auth/register").status_code == 200
  
      # test that successful registration redirects to the login page
      response = client.post("/auth/register", data={"username": "a", "password": "a"})
      assert response.headers["Location"] == "/auth/login"
  
      # test that the user was inserted into the database
      with app.app_context():
          assert (
              get_db().execute("SELECT * FROM user WHERE username = 'a'").fetchone()
              is not None
          )

Assertions:
  - assert client.get('/auth/register').status_code == 200
  - assert response.headers['Location'] == '/auth/login'
  - assert get_db().execute("SELECT * FROM user WHERE username = 'a'").fetchone() is not None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_register.json

================================================================================
Test: test_register_validate_input
File: __internal__/_data/flask/examples/tutorial/tests/test_auth.py

Methods Under Test (Static Analysis):
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - client.post (:0)
    Called by: test_register_validate_input

Test Source Code:
  def test_register_validate_input(client, username, password, message):
      response = client.post(
          "/auth/register", data={"username": username, "password": password}
      )
      assert message in response.data

Assertions:
  - assert message in response.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_register_validate_input.json

================================================================================
Test: test_login
File: __internal__/_data/flask/examples/tutorial/tests/test_auth.py

Methods Under Test (Static Analysis):
  - auth.login (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - auth.login (:0)
    Called by: test_login
  - client.get (:0)
    Called by: test_login

Test Source Code:
  def test_login(client, auth):
      # test that viewing the page renders without template errors
      assert client.get("/auth/login").status_code == 200
  
      # test that successful login redirects to the index page
      response = auth.login()
      assert response.headers["Location"] == "/"
  
      # login request set the user_id in the session
      # check that the user is loaded from the session
      with client:
          client.get("/")
          assert session["user_id"] == 1
          assert g.user["username"] == "test"

Assertions:
  - assert client.get('/auth/login').status_code == 200
  - assert response.headers['Location'] == '/'
  - assert session['user_id'] == 1
  - assert g.user['username'] == 'test'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_login.json

================================================================================
Test: test_login_validate_input
File: __internal__/_data/flask/examples/tutorial/tests/test_auth.py

Methods Under Test (Static Analysis):
  - auth.login (:0)

Methods Actually Called (Dynamic Analysis):
  - auth.login (:0)
    Called by: test_login_validate_input

Test Source Code:
  def test_login_validate_input(auth, username, password, message):
      response = auth.login(username, password)
      assert message in response.data

Assertions:
  - assert message in response.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_login_validate_input.json

================================================================================
Test: test_logout
File: __internal__/_data/flask/examples/tutorial/tests/test_auth.py

Methods Under Test (Static Analysis):
  - auth.login (:0)
  - auth.logout (:0)

Methods Actually Called (Dynamic Analysis):
  - auth.login (:0)
    Called by: test_logout
  - auth.logout (:0)
    Called by: test_logout

Test Source Code:
  def test_logout(client, auth):
      auth.login()
  
      with client:
          auth.logout()
          assert "user_id" not in session

Assertions:
  - assert 'user_id' not in session

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_logout.json

================================================================================
Test: test_config
File: __internal__/_data/flask/examples/tutorial/tests/test_factory.py

Methods Under Test (Static Analysis):
  - create_app (__init__.py:6)
    Source code:
      def create_app(test_config=None):
          """Create and configure an instance of the Flask application."""
          app = Flask(__name__, instance_relative_config=True)
          app.config.from_mapping(
              # a default secret that should be overridden by instance config
              SECRET_KEY="dev",
              # store the database in the instance folder
              DATABASE=os.path.join(app.instance_path, "flaskr.sqlite"),
          )
      
          if test_config is None:
              # load the instance config, if it exists, when not testing
              app.config.from_pyfile("config.py", silent=True)
          else:
              # load the test config if passed in
              app.config.update(test_config)
      
          # ensure the instance folder exists
          try:
              os.makedirs(app.instance_path)
          except OSError:
              pass
      
          @app.route("/hello")
          def hello():
              return "Hello, World!"
      
          # register the database commands
          from . import db
      
          db.init_app(app)
      
          # apply the blueprints to the app
          from . import auth
          from . import blog
      
          app.register_blueprint(auth.bp)
          app.register_blueprint(blog.bp)
      
          # make url_for('index') == url_for('blog.index')
          # in another app, you might define a separate main index here with
          # app.route, while giving the blog blueprint a url_prefix, but for
          # the tutorial the blog will be the main index
          app.add_url_rule("/", endpoint="index")
      
          return app
  - create_app (__init__.py:6)
    Source code:
      def create_app(test_config=None):
          """Create and configure an instance of the Flask application."""
          app = Flask(__name__, instance_relative_config=True)
          app.config.from_mapping(
              # a default secret that should be overridden by instance config
              SECRET_KEY="dev",
              # store the database in the instance folder
              DATABASE=os.path.join(app.instance_path, "flaskr.sqlite"),
          )
      
          if test_config is None:
              # load the instance config, if it exists, when not testing
              app.config.from_pyfile("config.py", silent=True)
          else:
              # load the test config if passed in
              app.config.update(test_config)
      
          # ensure the instance folder exists
          try:
              os.makedirs(app.instance_path)
          except OSError:
              pass
      
          @app.route("/hello")
          def hello():
              return "Hello, World!"
      
          # register the database commands
          from . import db
      
          db.init_app(app)
      
          # apply the blueprints to the app
          from . import auth
          from . import blog
      
          app.register_blueprint(auth.bp)
          app.register_blueprint(blog.bp)
      
          # make url_for('index') == url_for('blog.index')
          # in another app, you might define a separate main index here with
          # app.route, while giving the blog blueprint a url_prefix, but for
          # the tutorial the blog will be the main index
          app.add_url_rule("/", endpoint="index")
      
          return app

Methods Actually Called (Dynamic Analysis):
  - create_app (__init__.py:6)
    Called by: test_config

Test Source Code:
  def test_config():
      """Test create_app without passing test config."""
      assert not create_app().testing
      assert create_app({"TESTING": True}).testing

Assertions:
  - assert not create_app().testing
  - assert create_app({'TESTING': True}).testing

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config.json

================================================================================
Test: test_hello
File: __internal__/_data/flask/examples/tutorial/tests/test_factory.py

Methods Under Test (Static Analysis):
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - client.get (:0)
    Called by: test_hello

Test Source Code:
  def test_hello(client):
      response = client.get("/hello")
      assert response.data == b"Hello, World!"

Assertions:
  - assert response.data == b'Hello, World!'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_hello.json

================================================================================
Test: test_index
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - client.get (:0)
  - auth.login (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - client.get (:0)
    Called by: test_index
  - auth.login (:0)
    Called by: test_index

Test Source Code:
  def test_index(client, auth):
      response = client.get("/")
      assert b"Log In" in response.data
      assert b"Register" in response.data
  
      auth.login()
      response = client.get("/")
      assert b"test title" in response.data
      assert b"by test on 2018-01-01" in response.data
      assert b"test\nbody" in response.data
      assert b'href="/1/update"' in response.data

Assertions:
  - assert b'Log In' in response.data
  - assert b'Register' in response.data
  - assert b'test title' in response.data
  - assert b'by test on 2018-01-01' in response.data
  - assert b'test\nbody' in response.data
  - assert b'href="/1/update"' in response.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_index.json

================================================================================
Test: test_login_required
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - client.post (:0)
    Called by: test_login_required

Test Source Code:
  def test_login_required(client, path):
      response = client.post(path)
      assert response.headers["Location"] == "/auth/login"

Assertions:
  - assert response.headers['Location'] == '/auth/login'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_login_required.json

================================================================================
Test: test_author_required
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - auth.login (:0)
  - app.app_context (:0)
  - get_db (db.py:9)
    Source code:
      def get_db():
          """Connect to the application's configured database. The connection
          is unique for each request and will be reused if this is called
          again.
          """
          if "db" not in g:
              g.db = sqlite3.connect(
                  current_app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES
              )
              g.db.row_factory = sqlite3.Row
      
          return g.db
  - db.execute (:0)
  - db.commit (:0)
  - client.post (:0)
  - client.post (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_author_required
  - auth.login (:0)
    Called by: test_author_required
  - get_db (db.py:9)
    Called by: test_author_required
  - db.execute (:0)
    Called by: test_author_required
  - db.commit (:0)
    Called by: test_author_required
  - client.post (:0)
    Called by: test_author_required
  - client.get (:0)
    Called by: test_author_required

Test Source Code:
  def test_author_required(app, client, auth):
      # change the post author to another user
      with app.app_context():
          db = get_db()
          db.execute("UPDATE post SET author_id = 2 WHERE id = 1")
          db.commit()
  
      auth.login()
      # current user can't modify other user's post
      assert client.post("/1/update").status_code == 403
      assert client.post("/1/delete").status_code == 403
      # current user doesn't see edit link
      assert b'href="/1/update"' not in client.get("/").data

Assertions:
  - assert client.post('/1/update').status_code == 403
  - assert client.post('/1/delete').status_code == 403
  - assert b'href="/1/update"' not in client.get('/').data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_author_required.json

================================================================================
Test: test_exists_required
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - auth.login (:0)
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - auth.login (:0)
    Called by: test_exists_required
  - client.post (:0)
    Called by: test_exists_required

Test Source Code:
  def test_exists_required(client, auth, path):
      auth.login()
      assert client.post(path).status_code == 404

Assertions:
  - assert client.post(path).status_code == 404

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_exists_required.json

================================================================================
Test: test_create
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - auth.login (:0)
  - client.post (:0)
  - app.app_context (:0)
  - get_db (db.py:9)
    Source code:
      def get_db():
          """Connect to the application's configured database. The connection
          is unique for each request and will be reused if this is called
          again.
          """
          if "db" not in g:
              g.db = sqlite3.connect(
                  current_app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES
              )
              g.db.row_factory = sqlite3.Row
      
          return g.db
  - client.get (:0)
  - db.execute.fetchone (:0)
  - db.execute (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_create
  - auth.login (:0)
    Called by: test_create
  - client.post (:0)
    Called by: test_create
  - get_db (db.py:9)
    Called by: test_create
  - client.get (:0)
    Called by: test_create
  - db.execute.fetchone (:0)
    Called by: test_create
  - db.execute (:0)
    Called by: test_create

Test Source Code:
  def test_create(client, auth, app):
      auth.login()
      assert client.get("/create").status_code == 200
      client.post("/create", data={"title": "created", "body": ""})
  
      with app.app_context():
          db = get_db()
          count = db.execute("SELECT COUNT(id) FROM post").fetchone()[0]
          assert count == 2

Assertions:
  - assert client.get('/create').status_code == 200
  - assert count == 2

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_create.json

================================================================================
Test: test_update
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - auth.login (:0)
  - client.post (:0)
  - app.app_context (:0)
  - get_db (db.py:9)
    Source code:
      def get_db():
          """Connect to the application's configured database. The connection
          is unique for each request and will be reused if this is called
          again.
          """
          if "db" not in g:
              g.db = sqlite3.connect(
                  current_app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES
              )
              g.db.row_factory = sqlite3.Row
      
          return g.db
  - db.execute.fetchone (:0)
  - client.get (:0)
  - db.execute (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_update
  - auth.login (:0)
    Called by: test_update
  - client.post (:0)
    Called by: test_update
  - get_db (db.py:9)
    Called by: test_update
  - db.execute.fetchone (:0)
    Called by: test_update
  - client.get (:0)
    Called by: test_update
  - db.execute (:0)
    Called by: test_update

Test Source Code:
  def test_update(client, auth, app):
      auth.login()
      assert client.get("/1/update").status_code == 200
      client.post("/1/update", data={"title": "updated", "body": ""})
  
      with app.app_context():
          db = get_db()
          post = db.execute("SELECT * FROM post WHERE id = 1").fetchone()
          assert post["title"] == "updated"

Assertions:
  - assert client.get('/1/update').status_code == 200
  - assert post['title'] == 'updated'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_update.json

================================================================================
Test: test_create_update_validate
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - auth.login (:0)
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - auth.login (:0)
    Called by: test_create_update_validate
  - client.post (:0)
    Called by: test_create_update_validate

Test Source Code:
  def test_create_update_validate(client, auth, path):
      auth.login()
      response = client.post(path, data={"title": "", "body": ""})
      assert b"Title is required." in response.data

Assertions:
  - assert b'Title is required.' in response.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_create_update_validate.json

================================================================================
Test: test_delete
File: __internal__/_data/flask/examples/tutorial/tests/test_blog.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - auth.login (:0)
  - client.post (:0)
  - app.app_context (:0)
  - get_db (db.py:9)
    Source code:
      def get_db():
          """Connect to the application's configured database. The connection
          is unique for each request and will be reused if this is called
          again.
          """
          if "db" not in g:
              g.db = sqlite3.connect(
                  current_app.config["DATABASE"], detect_types=sqlite3.PARSE_DECLTYPES
              )
              g.db.row_factory = sqlite3.Row
      
          return g.db
  - db.execute.fetchone (:0)
  - db.execute (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_delete
  - auth.login (:0)
    Called by: test_delete
  - client.post (:0)
    Called by: test_delete
  - get_db (db.py:9)
    Called by: test_delete
  - db.execute.fetchone (:0)
    Called by: test_delete
  - db.execute (:0)
    Called by: test_delete

Test Source Code:
  def test_delete(client, auth, app):
      auth.login()
      response = client.post("/1/delete")
      assert response.headers["Location"] == "/"
  
      with app.app_context():
          db = get_db()
          post = db.execute("SELECT * FROM post WHERE id = 1").fetchone()
          assert post is None

Assertions:
  - assert response.headers['Location'] == '/'
  - assert post is None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_delete.json

================================================================================
Test: test_dump_load_unchanged
File: __internal__/_data/flask/tests/test_json_tag.py

Methods Under Test (Static Analysis):
  - TaggedJSONSerializer (:0)
  - s.loads (:0)
  - Markup (:0)
  - uuid4 (:0)
  - s.dumps (:0)

Methods Actually Called (Dynamic Analysis):
  - TaggedJSONSerializer (:0)
    Called by: test_dump_load_unchanged
  - s.loads (:0)
    Called by: test_dump_load_unchanged
  - Markup (:0)
    Called by: test_dump_load_unchanged
  - uuid4 (:0)
    Called by: test_dump_load_unchanged
  - s.dumps (:0)
    Called by: test_dump_load_unchanged

Test Source Code:
  def test_dump_load_unchanged(data):
      s = TaggedJSONSerializer()
      assert s.loads(s.dumps(data)) == data

Assertions:
  - assert s.loads(s.dumps(data)) == data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_dump_load_unchanged.json

================================================================================
Test: test_duplicate_tag
File: __internal__/_data/flask/tests/test_json_tag.py

Methods Under Test (Static Analysis):
  - TaggedJSONSerializer (:0)
  - s.register (:0)
  - isinstance (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - TaggedJSONSerializer (:0)
    Called by: test_duplicate_tag
  - s.register (:0)
    Called by: test_duplicate_tag
  - isinstance (:0)
    Called by: test_duplicate_tag

Test Source Code:
  def test_duplicate_tag():
      class TagDict(JSONTag):
          key = " d"
  
      s = TaggedJSONSerializer()
      pytest.raises(KeyError, s.register, TagDict)
      s.register(TagDict, force=True, index=0)
      assert isinstance(s.tags[" d"], TagDict)
      assert isinstance(s.order[0], TagDict)

Assertions:
  - assert isinstance(s.tags[' d'], TagDict)
  - assert isinstance(s.order[0], TagDict)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_duplicate_tag.json

================================================================================
Test: test_custom_tag
File: __internal__/_data/flask/tests/test_json_tag.py

Methods Under Test (Static Analysis):
  - TaggedJSONSerializer (:0)
  - s.register (:0)
  - isinstance (:0)
  - self.serializer.tag (:0)
  - Foo (:0)
  - s.loads (:0)
  - s.dumps (:0)
  - Foo (:0)

Methods Actually Called (Dynamic Analysis):
  - TaggedJSONSerializer (:0)
    Called by: test_custom_tag
  - s.register (:0)
    Called by: test_custom_tag
  - isinstance (:0)
    Called by: test_custom_tag
  - self.serializer.tag (:0)
    Called by: test_custom_tag
  - Foo (:0)
    Called by: test_custom_tag
  - s.loads (:0)
    Called by: test_custom_tag
  - s.dumps (:0)
    Called by: test_custom_tag

Test Source Code:
  def test_custom_tag():
      class Foo:  # noqa: B903, for Python2 compatibility
          def __init__(self, data):
              self.data = data
  
      class TagFoo(JSONTag):
          __slots__ = ()
          key = " f"
  
          def check(self, value):
              return isinstance(value, Foo)
  
          def to_json(self, value):
              return self.serializer.tag(value.data)
  
          def to_python(self, value):
              return Foo(value)
  
      s = TaggedJSONSerializer()
      s.register(TagFoo)
      assert s.loads(s.dumps(Foo("bar"))).data == "bar"

Assertions:
  - assert s.loads(s.dumps(Foo('bar'))).data == 'bar'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_custom_tag.json

================================================================================
Test: test_tag_interface
File: __internal__/_data/flask/tests/test_json_tag.py

Methods Under Test (Static Analysis):
  - JSONTag (:0)

Methods Actually Called (Dynamic Analysis):
  - JSONTag (:0)
    Called by: test_tag_interface

Test Source Code:
  def test_tag_interface():
      t = JSONTag(None)
      pytest.raises(NotImplementedError, t.check, None)
      pytest.raises(NotImplementedError, t.to_json, None)
      pytest.raises(NotImplementedError, t.to_python, None)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_tag_interface.json

================================================================================
Test: test_tag_order
File: __internal__/_data/flask/tests/test_json_tag.py

Methods Under Test (Static Analysis):
  - TaggedJSONSerializer (:0)
  - s.register (:0)
  - isinstance (:0)
  - s.register (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - TaggedJSONSerializer (:0)
    Called by: test_tag_order
  - s.register (:0)
    Called by: test_tag_order
  - isinstance (:0)
    Called by: test_tag_order

Test Source Code:
  def test_tag_order():
      class Tag1(JSONTag):
          key = " 1"
  
      class Tag2(JSONTag):
          key = " 2"
  
      s = TaggedJSONSerializer()
  
      s.register(Tag1, index=-1)
      assert isinstance(s.order[-2], Tag1)
  
      s.register(Tag2, index=None)
      assert isinstance(s.order[-1], Tag2)

Assertions:
  - assert isinstance(s.order[-2], Tag1)
  - assert isinstance(s.order[-1], Tag2)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_tag_order.json

================================================================================
Test: test_environ_defaults_from_config
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.test_request_context (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_environ_defaults_from_config
  - app.test_request_context (:0)
    Called by: test_environ_defaults_from_config
  - client.get (:0)
    Called by: test_environ_defaults_from_config

Test Source Code:
  def test_environ_defaults_from_config(app, client):
      app.config["SERVER_NAME"] = "example.com:1234"
      app.config["APPLICATION_ROOT"] = "/foo"
  
      @app.route("/")
      def index():
          return flask.request.url
  
      ctx = app.test_request_context()
      assert ctx.request.url == "http://example.com:1234/foo/"
  
      rv = client.get("/")
      assert rv.data == b"http://example.com:1234/foo/"

Assertions:
  - assert ctx.request.url == 'http://example.com:1234/foo/'
  - assert rv.data == b'http://example.com:1234/foo/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_environ_defaults_from_config.json

================================================================================
Test: test_environ_defaults
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.test_request_context (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_environ_defaults
  - app.test_request_context (:0)
    Called by: test_environ_defaults
  - client.get (:0)
    Called by: test_environ_defaults

Test Source Code:
  def test_environ_defaults(app, client, app_ctx, req_ctx):
      @app.route("/")
      def index():
          return flask.request.url
  
      ctx = app.test_request_context()
      assert ctx.request.url == "http://localhost/"
      with client:
          rv = client.get("/")
          assert rv.data == b"http://localhost/"

Assertions:
  - assert ctx.request.url == 'http://localhost/'
  - assert rv.data == b'http://localhost/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_environ_defaults.json

================================================================================
Test: test_environ_base_default
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_environ_base_default
  - client.get (:0)
    Called by: test_environ_base_default

Test Source Code:
  def test_environ_base_default(app, client):
      @app.route("/")
      def index():
          flask.g.remote_addr = flask.request.remote_addr
          flask.g.user_agent = flask.request.user_agent.string
          return ""
  
      with client:
          client.get("/")
          assert flask.g.remote_addr == "127.0.0.1"
          assert flask.g.user_agent == (
              f"Werkzeug/{importlib.metadata.version('werkzeug')}"
          )

Assertions:
  - assert flask.g.remote_addr == '127.0.0.1'
  - assert flask.g.user_agent == f"Werkzeug/{importlib.metadata.version('werkzeug')}"

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_environ_base_default.json

================================================================================
Test: test_environ_base_modified
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_environ_base_modified
  - client.get (:0)
    Called by: test_environ_base_modified

Test Source Code:
  def test_environ_base_modified(app, client):
      @app.route("/")
      def index():
          flask.g.remote_addr = flask.request.remote_addr
          flask.g.user_agent = flask.request.user_agent.string
          return ""
  
      client.environ_base["REMOTE_ADDR"] = "192.168.0.22"
      client.environ_base["HTTP_USER_AGENT"] = "Foo"
  
      with client:
          client.get("/")
          assert flask.g.remote_addr == "192.168.0.22"
          assert flask.g.user_agent == "Foo"

Assertions:
  - assert flask.g.remote_addr == '192.168.0.22'
  - assert flask.g.user_agent == 'Foo'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_environ_base_modified.json

================================================================================
Test: test_client_open_environ
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - EnvironBuilder (:0)
  - request.addfinalizer (:0)
  - client.open (:0)
  - builder.get_environ (:0)
  - client.open (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_client_open_environ
  - EnvironBuilder (:0)
    Called by: test_client_open_environ
  - request.addfinalizer (:0)
    Called by: test_client_open_environ
  - client.open (:0)
    Called by: test_client_open_environ
  - builder.get_environ (:0)
    Called by: test_client_open_environ

Test Source Code:
  def test_client_open_environ(app, client, request):
      @app.route("/index")
      def index():
          return flask.request.remote_addr
  
      builder = EnvironBuilder(app, path="/index", method="GET")
      request.addfinalizer(builder.close)
  
      rv = client.open(builder)
      assert rv.data == b"127.0.0.1"
  
      environ = builder.get_environ()
      client.environ_base["REMOTE_ADDR"] = "127.0.0.2"
      rv = client.open(environ)
      assert rv.data == b"127.0.0.2"

Assertions:
  - assert rv.data == b'127.0.0.1'
  - assert rv.data == b'127.0.0.2'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_client_open_environ.json

================================================================================
Test: test_specify_url_scheme
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.test_request_context (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_specify_url_scheme
  - app.test_request_context (:0)
    Called by: test_specify_url_scheme
  - client.get (:0)
    Called by: test_specify_url_scheme

Test Source Code:
  def test_specify_url_scheme(app, client):
      @app.route("/")
      def index():
          return flask.request.url
  
      ctx = app.test_request_context(url_scheme="https")
      assert ctx.request.url == "https://localhost/"
  
      rv = client.get("/", url_scheme="https")
      assert rv.data == b"https://localhost/"

Assertions:
  - assert ctx.request.url == 'https://localhost/'
  - assert rv.data == b'https://localhost/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_specify_url_scheme.json

================================================================================
Test: test_path_is_url
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - EnvironBuilder (:0)

Methods Actually Called (Dynamic Analysis):
  - EnvironBuilder (:0)
    Called by: test_path_is_url

Test Source Code:
  def test_path_is_url(app):
      eb = EnvironBuilder(app, "https://example.com/")
      assert eb.url_scheme == "https"
      assert eb.host == "example.com"
      assert eb.script_root == ""
      assert eb.path == "/"

Assertions:
  - assert eb.url_scheme == 'https'
  - assert eb.host == 'example.com'
  - assert eb.script_root == ''
  - assert eb.path == '/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_path_is_url.json

================================================================================
Test: test_environbuilder_json_dumps
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - EnvironBuilder (:0)
  - eb.input_stream.read.decode (:0)
  - eb.input_stream.read (:0)

Methods Actually Called (Dynamic Analysis):
  - EnvironBuilder (:0)
    Called by: test_environbuilder_json_dumps
  - eb.input_stream.read.decode (:0)
    Called by: test_environbuilder_json_dumps
  - eb.input_stream.read (:0)
    Called by: test_environbuilder_json_dumps

Test Source Code:
  def test_environbuilder_json_dumps(app):
      """EnvironBuilder.json_dumps() takes settings from the app."""
      app.json.ensure_ascii = False
      eb = EnvironBuilder(app, json="\u20ac")
      assert eb.input_stream.read().decode("utf8") == '"\u20ac"'

Assertions:
  - assert eb.input_stream.read().decode('utf8') == '"€"'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_environbuilder_json_dumps.json

================================================================================
Test: test_blueprint_with_subdomain
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - bp.route (:0)
  - app.register_blueprint (:0)
  - app.test_request_context (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_blueprint_with_subdomain
  - bp.route (:0)
    Called by: test_blueprint_with_subdomain
  - app.register_blueprint (:0)
    Called by: test_blueprint_with_subdomain
  - app.test_request_context (:0)
    Called by: test_blueprint_with_subdomain
  - client.get (:0)
    Called by: test_blueprint_with_subdomain

Test Source Code:
  def test_blueprint_with_subdomain():
      app = flask.Flask(__name__, subdomain_matching=True)
      app.config["SERVER_NAME"] = "example.com:1234"
      app.config["APPLICATION_ROOT"] = "/foo"
      client = app.test_client()
  
      bp = flask.Blueprint("company", __name__, subdomain="xxx")
  
      @bp.route("/")
      def index():
          return flask.request.url
  
      app.register_blueprint(bp)
  
      ctx = app.test_request_context("/", subdomain="xxx")
      assert ctx.request.url == "http://xxx.example.com:1234/foo/"
  
      with ctx:
          assert ctx.request.blueprint == bp.name
  
      rv = client.get("/", subdomain="xxx")
      assert rv.data == b"http://xxx.example.com:1234/foo/"

Assertions:
  - assert ctx.request.url == 'http://xxx.example.com:1234/foo/'
  - assert rv.data == b'http://xxx.example.com:1234/foo/'
  - assert ctx.request.blueprint == bp.name

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_with_subdomain.json

================================================================================
Test: test_redirect_keep_session
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)
  - client.post (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_redirect_keep_session
  - client.get (:0)
    Called by: test_redirect_keep_session
  - client.post (:0)
    Called by: test_redirect_keep_session

Test Source Code:
  def test_redirect_keep_session(app, client, app_ctx):
      @app.route("/", methods=["GET", "POST"])
      def index():
          if flask.request.method == "POST":
              return flask.redirect("/getsession")
          flask.session["data"] = "foo"
          return "index"
  
      @app.route("/getsession")
      def get_session():
          return flask.session.get("data", "<missing>")
  
      with client:
          rv = client.get("/getsession")
          assert rv.data == b"<missing>"
  
          rv = client.get("/")
          assert rv.data == b"index"
          assert flask.session.get("data") == "foo"
  
          rv = client.post("/", data={}, follow_redirects=True)
          assert rv.data == b"foo"
          assert flask.session.get("data") == "foo"
  
          rv = client.get("/getsession")
          assert rv.data == b"foo"

Assertions:
  - assert rv.data == b'<missing>'
  - assert rv.data == b'index'
  - assert flask.session.get('data') == 'foo'
  - assert rv.data == b'foo'
  - assert flask.session.get('data') == 'foo'
  - assert rv.data == b'foo'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_redirect_keep_session.json

================================================================================
Test: test_session_transactions
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.session_transaction (:0)
  - client.session_transaction (:0)
  - str (:0)
  - client.get (:0)
  - client.session_transaction (:0)
  - client.session_transaction (:0)
  - len (:0)
  - len (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session_transactions
  - client.session_transaction (:0)
    Called by: test_session_transactions
  - str (:0)
    Called by: test_session_transactions
  - client.get (:0)
    Called by: test_session_transactions
  - len (:0)
    Called by: test_session_transactions

Test Source Code:
  def test_session_transactions(app, client):
      @app.route("/")
      def index():
          return str(flask.session["foo"])
  
      with client:
          with client.session_transaction() as sess:
              assert len(sess) == 0
              sess["foo"] = [42]
              assert len(sess) == 1
          rv = client.get("/")
          assert rv.data == b"[42]"
          with client.session_transaction() as sess:
              assert len(sess) == 1
              assert sess["foo"] == [42]

Assertions:
  - assert rv.data == b'[42]'
  - assert len(sess) == 0
  - assert len(sess) == 1
  - assert len(sess) == 1
  - assert sess['foo'] == [42]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_transactions.json

================================================================================
Test: test_session_transactions_no_null_sessions
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.test_client (:0)
  - c.session_transaction (:0)
  - str (:0)
  - c.session_transaction (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_session_transactions_no_null_sessions
  - c.session_transaction (:0)
    Called by: test_session_transactions_no_null_sessions
  - str (:0)
    Called by: test_session_transactions_no_null_sessions

Test Source Code:
  def test_session_transactions_no_null_sessions():
      app = flask.Flask(__name__)
  
      with app.test_client() as c:
          with pytest.raises(RuntimeError) as e:
              with c.session_transaction():
                  pass
          assert "Session backend did not open a session" in str(e.value)

Assertions:
  - assert 'Session backend did not open a session' in str(e.value)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_transactions_no_null_sessions.json

================================================================================
Test: test_session_transactions_keep_context
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - client.session_transaction (:0)
  - client.get (:0)
  - client.session_transaction (:0)

Methods Actually Called (Dynamic Analysis):
  - client.session_transaction (:0)
    Called by: test_session_transactions_keep_context
  - client.get (:0)
    Called by: test_session_transactions_keep_context

Test Source Code:
  def test_session_transactions_keep_context(app, client, req_ctx):
      client.get("/")
      req = flask.request._get_current_object()
      assert req is not None
      with client.session_transaction():
          assert req is flask.request._get_current_object()

Assertions:
  - assert req is not None
  - assert req is flask.request._get_current_object()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_transactions_keep_context.json

================================================================================
Test: test_session_transaction_needs_cookies
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - c.session_transaction (:0)
  - c.session_transaction (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_session_transaction_needs_cookies
  - c.session_transaction (:0)
    Called by: test_session_transaction_needs_cookies

Test Source Code:
  def test_session_transaction_needs_cookies(app):
      c = app.test_client(use_cookies=False)
  
      with pytest.raises(TypeError, match="Cookies are disabled."):
          with c.session_transaction():
              pass

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_transaction_needs_cookies.json

================================================================================
Test: test_test_client_context_binding
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)
  - hasattr (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_test_client_context_binding
  - client.get (:0)
    Called by: test_test_client_context_binding
  - hasattr (:0)
    Called by: test_test_client_context_binding

Test Source Code:
  def test_test_client_context_binding(app, client):
      app.testing = False
  
      @app.route("/")
      def index():
          flask.g.value = 42
          return "Hello World!"
  
      @app.route("/other")
      def other():
          raise ZeroDivisionError
  
      with client:
          resp = client.get("/")
          assert flask.g.value == 42
          assert resp.data == b"Hello World!"
          assert resp.status_code == 200
  
      with client:
          resp = client.get("/other")
          assert not hasattr(flask.g, "value")
          assert b"Internal Server Error" in resp.data
          assert resp.status_code == 500
          flask.g.value = 23
  
      with pytest.raises(RuntimeError):
          flask.g.value

Assertions:
  - assert flask.g.value == 42
  - assert resp.data == b'Hello World!'
  - assert resp.status_code == 200
  - assert not hasattr(flask.g, 'value')
  - assert b'Internal Server Error' in resp.data
  - assert resp.status_code == 500

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_test_client_context_binding.json

================================================================================
Test: test_reuse_client
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - client.get (:0)
    Called by: test_reuse_client

Test Source Code:
  def test_reuse_client(client):
      c = client
  
      with c:
          assert client.get("/").status_code == 404
  
      with c:
          assert client.get("/").status_code == 404

Assertions:
  - assert client.get('/').status_code == 404
  - assert client.get('/').status_code == 404

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_reuse_client.json

================================================================================
Test: test_full_url_request
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_full_url_request
  - client.post (:0)
    Called by: test_full_url_request

Test Source Code:
  def test_full_url_request(app, client):
      @app.route("/action", methods=["POST"])
      def action():
          return "x"
  
      with client:
          rv = client.post("http://domain.com/action?vodka=42", data={"gin": 43})
          assert rv.status_code == 200
          assert "gin" in flask.request.form
          assert "vodka" in flask.request.args

Assertions:
  - assert rv.status_code == 200
  - assert 'gin' in flask.request.form
  - assert 'vodka' in flask.request.args

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_full_url_request.json

================================================================================
Test: test_json_request_and_response
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - jsonify (__init__.py:138)
    Source code:
      def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:
          """Serialize the given arguments as JSON, and return a
          :class:`~flask.Response` object with the ``application/json``
          mimetype. A dict or list returned from a view will be converted to a
          JSON response automatically without needing to call this.
      
          This requires an active request or application context, and calls
          :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.
      
          In debug mode, the output is formatted with indentation to make it
          easier to read. This may also be controlled by the provider.
      
          Either positional or keyword arguments can be given, not both.
          If no arguments are given, ``None`` is serialized.
      
          :param args: A single value to serialize, or multiple values to
              treat as a list to serialize.
          :param kwargs: Treat as a dict to serialize.
      
          .. versionchanged:: 2.2
              Calls ``current_app.json.response``, allowing an app to override
              the behavior.
      
          .. versionchanged:: 2.0.2
              :class:`decimal.Decimal` is supported by converting to a string.
      
          .. versionchanged:: 0.11
              Added support for serializing top-level arrays. This was a
              security risk in ancient browsers. See :ref:`security-json`.
      
          .. versionadded:: 0.2
          """
          return current_app.json.response(*args, **kwargs)
  - client.post (:0)
  - rv.get_json (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_json_request_and_response
  - jsonify (__init__.py:138)
    Called by: test_json_request_and_response
  - client.post (:0)
    Called by: test_json_request_and_response
  - rv.get_json (:0)
    Called by: test_json_request_and_response

Test Source Code:
  def test_json_request_and_response(app, client):
      @app.route("/echo", methods=["POST"])
      def echo():
          return jsonify(flask.request.get_json())
  
      with client:
          json_data = {"drink": {"gin": 1, "tonic": True}, "price": 10}
          rv = client.post("/echo", json=json_data)
  
          # Request should be in JSON
          assert flask.request.is_json
          assert flask.request.get_json() == json_data
  
          # Response should be in JSON
          assert rv.status_code == 200
          assert rv.is_json
          assert rv.get_json() == json_data

Assertions:
  - assert flask.request.is_json
  - assert flask.request.get_json() == json_data
  - assert rv.status_code == 200
  - assert rv.is_json
  - assert rv.get_json() == json_data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_request_and_response.json

================================================================================
Test: test_client_json_no_app_context
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - appcontext_popped.connected_to (:0)
  - app.route (:0)
  - Namespace (:0)
  - appcontext_popped.connected_to (:0)
  - client.post (:0)
  - rv.get_data (:0)

Methods Actually Called (Dynamic Analysis):
  - appcontext_popped.connected_to (:0)
    Called by: test_client_json_no_app_context
  - app.route (:0)
    Called by: test_client_json_no_app_context
  - Namespace (:0)
    Called by: test_client_json_no_app_context
  - client.post (:0)
    Called by: test_client_json_no_app_context
  - rv.get_data (:0)
    Called by: test_client_json_no_app_context

Test Source Code:
  def test_client_json_no_app_context(app, client):
      @app.route("/hello", methods=["POST"])
      def hello():
          return f"Hello, {flask.request.json['name']}!"
  
      class Namespace:
          count = 0
  
          def add(self, app):
              self.count += 1
  
      ns = Namespace()
  
      with appcontext_popped.connected_to(ns.add, app):
          rv = client.post("/hello", json={"name": "Flask"})
  
      assert rv.get_data(as_text=True) == "Hello, Flask!"
      assert ns.count == 1

Assertions:
  - assert rv.get_data(as_text=True) == 'Hello, Flask!'
  - assert ns.count == 1

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_client_json_no_app_context.json

================================================================================
Test: test_subdomain
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_client (:0)
  - app.route (:0)
  - app.test_request_context (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_subdomain
  - app.test_client (:0)
    Called by: test_subdomain
  - app.route (:0)
    Called by: test_subdomain
  - client.get (:0)
    Called by: test_subdomain

Test Source Code:
  def test_subdomain():
      app = flask.Flask(__name__, subdomain_matching=True)
      app.config["SERVER_NAME"] = "example.com"
      client = app.test_client()
  
      @app.route("/", subdomain="<company_id>")
      def view(company_id):
          return company_id
  
      with app.test_request_context():
          url = flask.url_for("view", company_id="xxx")
  
      with client:
          response = client.get(url)
  
      assert 200 == response.status_code
      assert b"xxx" == response.data

Assertions:
  - assert 200 == response.status_code
  - assert b'xxx' == response.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_subdomain.json

================================================================================
Test: test_nosubdomain
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.route (:0)
  - app.test_request_context (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_nosubdomain
  - app.route (:0)
    Called by: test_nosubdomain
  - client.get (:0)
    Called by: test_nosubdomain

Test Source Code:
  def test_nosubdomain(app, client):
      app.config["SERVER_NAME"] = "example.com"
  
      @app.route("/<company_id>")
      def view(company_id):
          return company_id
  
      with app.test_request_context():
          url = flask.url_for("view", company_id="xxx")
  
      with client:
          response = client.get(url)
  
      assert 200 == response.status_code
      assert b"xxx" == response.data

Assertions:
  - assert 200 == response.status_code
  - assert b'xxx' == response.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_nosubdomain.json

================================================================================
Test: test_cli_runner_class
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.test_cli_runner (:0)
  - isinstance (:0)
  - app.test_cli_runner (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_cli_runner (:0)
    Called by: test_cli_runner_class
  - isinstance (:0)
    Called by: test_cli_runner_class

Test Source Code:
  def test_cli_runner_class(app):
      runner = app.test_cli_runner()
      assert isinstance(runner, FlaskCliRunner)
  
      class SubRunner(FlaskCliRunner):
          pass
  
      app.test_cli_runner_class = SubRunner
      runner = app.test_cli_runner()
      assert isinstance(runner, SubRunner)

Assertions:
  - assert isinstance(runner, FlaskCliRunner)
  - assert isinstance(runner, SubRunner)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_cli_runner_class.json

================================================================================
Test: test_cli_invoke
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.cli.command (:0)
  - app.test_cli_runner (:0)
  - runner.invoke (:0)
  - runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - app.cli.command (:0)
    Called by: test_cli_invoke
  - app.test_cli_runner (:0)
    Called by: test_cli_invoke
  - runner.invoke (:0)
    Called by: test_cli_invoke

Test Source Code:
  def test_cli_invoke(app):
      @app.cli.command("hello")
      def hello_command():
          click.echo("Hello, World!")
  
      runner = app.test_cli_runner()
      # invoke with command name
      result = runner.invoke(args=["hello"])
      assert "Hello" in result.output
      # invoke with command object
      result = runner.invoke(hello_command)
      assert "Hello" in result.output

Assertions:
  - assert 'Hello' in result.output
  - assert 'Hello' in result.output

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_cli_invoke.json

================================================================================
Test: test_cli_custom_obj
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.cli.command (:0)
  - ScriptInfo (:0)
  - app.test_cli_runner (:0)
  - runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - app.cli.command (:0)
    Called by: test_cli_custom_obj
  - ScriptInfo (:0)
    Called by: test_cli_custom_obj
  - app.test_cli_runner (:0)
    Called by: test_cli_custom_obj
  - runner.invoke (:0)
    Called by: test_cli_custom_obj

Test Source Code:
  def test_cli_custom_obj(app):
      class NS:
          called = False
  
      def create_app():
          NS.called = True
          return app
  
      @app.cli.command("hello")
      def hello_command():
          click.echo("Hello, World!")
  
      script_info = ScriptInfo(create_app=create_app)
      runner = app.test_cli_runner()
      runner.invoke(hello_command, obj=script_info)
      assert NS.called

Assertions:
  - assert NS.called

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_cli_custom_obj.json

================================================================================
Test: test_client_pop_all_preserved
File: __internal__/_data/flask/tests/test_testing.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - rv.close (:0)
  - client.get (:0)
  - _cv_request.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_client_pop_all_preserved
  - rv.close (:0)
    Called by: test_client_pop_all_preserved
  - client.get (:0)
    Called by: test_client_pop_all_preserved
  - _cv_request.get (:0)
    Called by: test_client_pop_all_preserved

Test Source Code:
  def test_client_pop_all_preserved(app, req_ctx, client):
      @app.route("/")
      def index():
          # stream_with_context pushes a third context, preserved by response
          return flask.stream_with_context("hello")
  
      # req_ctx fixture pushed an initial context
      with client:
          # request pushes a second request context, preserved by client
          rv = client.get("/")
  
      # close the response, releasing the context held by stream_with_context
      rv.close()
      # only req_ctx fixture should still be pushed
      assert _cv_request.get(None) is req_ctx

Assertions:
  - assert _cv_request.get(None) is req_ctx

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_client_pop_all_preserved.json

================================================================================
Test: test_explicit_instance_paths
File: __internal__/_data/flask/tests/test_instance_config.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_explicit_instance_paths(modules_tmp_path):
      with pytest.raises(ValueError, match=".*must be absolute"):
          flask.Flask(__name__, instance_path="instance")
  
      app = flask.Flask(__name__, instance_path=os.fspath(modules_tmp_path))
      assert app.instance_path == os.fspath(modules_tmp_path)

Assertions:
  - assert app.instance_path == os.fspath(modules_tmp_path)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_explicit_instance_paths.json

================================================================================
Test: test_uninstalled_module_paths
File: __internal__/_data/flask/tests/test_instance_config.py

Methods Under Test (Static Analysis):
  - write_text (:0)
  - purge_module (conftest.py:156)
    Source code:
      def purge_module(request):
          def inner(name):
              request.addfinalizer(lambda: sys.modules.pop(name, None))
      
          return inner

Methods Actually Called (Dynamic Analysis):
  - write_text (:0)
    Called by: test_uninstalled_module_paths
  - purge_module (conftest.py:156)
    Called by: test_uninstalled_module_paths

Test Source Code:
  def test_uninstalled_module_paths(modules_tmp_path, purge_module):
      (modules_tmp_path / "config_module_app.py").write_text(
          "import os\n"
          "import flask\n"
          "here = os.path.abspath(os.path.dirname(__file__))\n"
          "app = flask.Flask(__name__)\n"
      )
      purge_module("config_module_app")
  
      from config_module_app import app
  
      assert app.instance_path == os.fspath(modules_tmp_path / "instance")

Assertions:
  - assert app.instance_path == os.fspath(modules_tmp_path / 'instance')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_uninstalled_module_paths.json

================================================================================
Test: test_uninstalled_package_paths
File: __internal__/_data/flask/tests/test_instance_config.py

Methods Under Test (Static Analysis):
  - app.mkdir (:0)
  - write_text (:0)
  - purge_module (conftest.py:156)
    Source code:
      def purge_module(request):
          def inner(name):
              request.addfinalizer(lambda: sys.modules.pop(name, None))
      
          return inner

Methods Actually Called (Dynamic Analysis):
  - app.mkdir (:0)
    Called by: test_uninstalled_package_paths
  - write_text (:0)
    Called by: test_uninstalled_package_paths
  - purge_module (conftest.py:156)
    Called by: test_uninstalled_package_paths

Test Source Code:
  def test_uninstalled_package_paths(modules_tmp_path, purge_module):
      app = modules_tmp_path / "config_package_app"
      app.mkdir()
      (app / "__init__.py").write_text(
          "import os\n"
          "import flask\n"
          "here = os.path.abspath(os.path.dirname(__file__))\n"
          "app = flask.Flask(__name__)\n"
      )
      purge_module("config_package_app")
  
      from config_package_app import app
  
      assert app.instance_path == os.fspath(modules_tmp_path / "instance")

Assertions:
  - assert app.instance_path == os.fspath(modules_tmp_path / 'instance')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_uninstalled_package_paths.json

================================================================================
Test: test_uninstalled_namespace_paths
File: __internal__/_data/flask/tests/test_instance_config.py

Methods Under Test (Static Analysis):
  - create_namespace (test_instance_config.py:47)
    Source code:
      def create_namespace(package):
              project = tmp_path / f"project-{package}"
              monkeypatch.syspath_prepend(os.fspath(project))
              ns = project / "namespace" / package
              ns.mkdir(parents=True)
              (ns / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
              return project
  - create_namespace (test_instance_config.py:47)
    Source code:
      def create_namespace(package):
              project = tmp_path / f"project-{package}"
              monkeypatch.syspath_prepend(os.fspath(project))
              ns = project / "namespace" / package
              ns.mkdir(parents=True)
              (ns / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
              return project
  - purge_module (conftest.py:156)
    Source code:
      def purge_module(request):
          def inner(name):
              request.addfinalizer(lambda: sys.modules.pop(name, None))
      
          return inner
  - purge_module (conftest.py:156)
    Source code:
      def purge_module(request):
          def inner(name):
              request.addfinalizer(lambda: sys.modules.pop(name, None))
      
          return inner
  - monkeypatch.syspath_prepend (:0)
  - ns.mkdir (:0)
  - write_text (:0)

Methods Actually Called (Dynamic Analysis):
  - create_namespace (test_instance_config.py:47)
    Called by: test_uninstalled_namespace_paths
  - purge_module (conftest.py:156)
    Called by: test_uninstalled_namespace_paths
  - monkeypatch.syspath_prepend (:0)
    Called by: test_uninstalled_namespace_paths
  - ns.mkdir (:0)
    Called by: test_uninstalled_namespace_paths
  - write_text (:0)
    Called by: test_uninstalled_namespace_paths

Test Source Code:
  def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):
      def create_namespace(package):
          project = tmp_path / f"project-{package}"
          monkeypatch.syspath_prepend(os.fspath(project))
          ns = project / "namespace" / package
          ns.mkdir(parents=True)
          (ns / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
          return project
  
      _ = create_namespace("package1")
      project2 = create_namespace("package2")
      purge_module("namespace.package2")
      purge_module("namespace")
  
      from namespace.package2 import app
  
      assert app.instance_path == os.fspath(project2 / "instance")

Assertions:
  - assert app.instance_path == os.fspath(project2 / 'instance')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_uninstalled_namespace_paths.json

================================================================================
Test: test_installed_module_paths
File: __internal__/_data/flask/tests/test_instance_config.py

Methods Under Test (Static Analysis):
  - write_text (:0)
  - purge_module (conftest.py:156)
    Source code:
      def purge_module(request):
          def inner(name):
              request.addfinalizer(lambda: sys.modules.pop(name, None))
      
          return inner

Methods Actually Called (Dynamic Analysis):
  - write_text (:0)
    Called by: test_installed_module_paths
  - purge_module (conftest.py:156)
    Called by: test_installed_module_paths

Test Source Code:
  def test_installed_module_paths(
      modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages, limit_loader
  ):
      (site_packages / "site_app.py").write_text(
          "import flask\napp = flask.Flask(__name__)\n"
      )
      purge_module("site_app")
  
      from site_app import app
  
      assert app.instance_path == os.fspath(
          modules_tmp_path / "var" / "site_app-instance"
      )

Assertions:
  - assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_app-instance')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_installed_module_paths.json

================================================================================
Test: test_installed_package_paths
File: __internal__/_data/flask/tests/test_instance_config.py

Methods Under Test (Static Analysis):
  - installed_path.mkdir (:0)
  - monkeypatch.syspath_prepend (:0)
  - app.mkdir (:0)
  - write_text (:0)
  - purge_module (conftest.py:156)
    Source code:
      def purge_module(request):
          def inner(name):
              request.addfinalizer(lambda: sys.modules.pop(name, None))
      
          return inner

Methods Actually Called (Dynamic Analysis):
  - installed_path.mkdir (:0)
    Called by: test_installed_package_paths
  - monkeypatch.syspath_prepend (:0)
    Called by: test_installed_package_paths
  - app.mkdir (:0)
    Called by: test_installed_package_paths
  - write_text (:0)
    Called by: test_installed_package_paths
  - purge_module (conftest.py:156)
    Called by: test_installed_package_paths

Test Source Code:
  def test_installed_package_paths(
      limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch
  ):
      installed_path = modules_tmp_path / "path"
      installed_path.mkdir()
      monkeypatch.syspath_prepend(installed_path)
  
      app = installed_path / "installed_package"
      app.mkdir()
      (app / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
      purge_module("installed_package")
  
      from installed_package import app
  
      assert app.instance_path == os.fspath(
          modules_tmp_path / "var" / "installed_package-instance"
      )

Assertions:
  - assert app.instance_path == os.fspath(modules_tmp_path / 'var' / 'installed_package-instance')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_installed_package_paths.json

================================================================================
Test: test_prefix_package_paths
File: __internal__/_data/flask/tests/test_instance_config.py

Methods Under Test (Static Analysis):
  - app.mkdir (:0)
  - write_text (:0)
  - purge_module (conftest.py:156)
    Source code:
      def purge_module(request):
          def inner(name):
              request.addfinalizer(lambda: sys.modules.pop(name, None))
      
          return inner

Methods Actually Called (Dynamic Analysis):
  - app.mkdir (:0)
    Called by: test_prefix_package_paths
  - write_text (:0)
    Called by: test_prefix_package_paths
  - purge_module (conftest.py:156)
    Called by: test_prefix_package_paths

Test Source Code:
  def test_prefix_package_paths(
      limit_loader, modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages
  ):
      app = site_packages / "site_package"
      app.mkdir()
      (app / "__init__.py").write_text("import flask\napp = flask.Flask(__name__)\n")
      purge_module("site_package")
  
      import site_package
  
      assert site_package.app.instance_path == os.fspath(
          modules_tmp_path / "var" / "site_package-instance"
      )

Assertions:
  - assert site_package.app.instance_path == os.fspath(modules_tmp_path / 'var' / 'site_package-instance')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_prefix_package_paths.json

================================================================================
Test: test_teardown_on_pop
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - ctx.push (:0)
  - ctx.pop (:0)
  - buffer.append (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_teardown_on_pop
  - ctx.push (:0)
    Called by: test_teardown_on_pop
  - ctx.pop (:0)
    Called by: test_teardown_on_pop
  - buffer.append (:0)
    Called by: test_teardown_on_pop

Test Source Code:
  def test_teardown_on_pop(app):
      buffer = []
  
      @app.teardown_request
      def end_of_request(exception):
          buffer.append(exception)
  
      ctx = app.test_request_context()
      ctx.push()
      assert buffer == []
      ctx.pop()
      assert buffer == [None]

Assertions:
  - assert buffer == []
  - assert buffer == [None]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_teardown_on_pop.json

================================================================================
Test: test_teardown_with_previous_exception
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - buffer.append (:0)
  - Exception (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_teardown_with_previous_exception
  - buffer.append (:0)
    Called by: test_teardown_with_previous_exception
  - Exception (:0)
    Called by: test_teardown_with_previous_exception

Test Source Code:
  def test_teardown_with_previous_exception(app):
      buffer = []
  
      @app.teardown_request
      def end_of_request(exception):
          buffer.append(exception)
  
      try:
          raise Exception("dummy")
      except Exception:
          pass
  
      with app.test_request_context():
          assert buffer == []
      assert buffer == [None]

Assertions:
  - assert buffer == [None]
  - assert buffer == []

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_teardown_with_previous_exception.json

================================================================================
Test: test_teardown_with_handled_exception
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - buffer.append (:0)
  - app.test_request_context (:0)
  - Exception (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_teardown_with_handled_exception
  - buffer.append (:0)
    Called by: test_teardown_with_handled_exception
  - Exception (:0)
    Called by: test_teardown_with_handled_exception

Test Source Code:
  def test_teardown_with_handled_exception(app):
      buffer = []
  
      @app.teardown_request
      def end_of_request(exception):
          buffer.append(exception)
  
      with app.test_request_context():
          assert buffer == []
          try:
              raise Exception("dummy")
          except Exception:
              pass
      assert buffer == [None]

Assertions:
  - assert buffer == [None]
  - assert buffer == []

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_teardown_with_handled_exception.json

================================================================================
Test: test_proper_test_request_context
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.config.update (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_request_context (:0)
  - app.config.update (:0)
  - app.config.update (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_proper_test_request_context
  - app.config.update (:0)
    Called by: test_proper_test_request_context
  - app.route (:0)
    Called by: test_proper_test_request_context

Test Source Code:
  def test_proper_test_request_context(app):
      app.config.update(SERVER_NAME="localhost.localdomain:5000")
  
      @app.route("/")
      def index():
          return None
  
      @app.route("/", subdomain="foo")
      def sub():
          return None
  
      with app.test_request_context("/"):
          assert (
              flask.url_for("index", _external=True)
              == "http://localhost.localdomain:5000/"
          )
  
      with app.test_request_context("/"):
          assert (
              flask.url_for("sub", _external=True)
              == "http://foo.localhost.localdomain:5000/"
          )
  
      # suppress Werkzeug 0.15 warning about name mismatch
      with warnings.catch_warnings():
          warnings.filterwarnings(
              "ignore", "Current server name", UserWarning, "flask.app"
          )
          with app.test_request_context(
              "/", environ_overrides={"HTTP_HOST": "localhost"}
          ):
              pass
  
      app.config.update(SERVER_NAME="localhost")
      with app.test_request_context("/", environ_overrides={"SERVER_NAME": "localhost"}):
          pass
  
      app.config.update(SERVER_NAME="localhost:80")
      with app.test_request_context(
          "/", environ_overrides={"SERVER_NAME": "localhost:80"}
      ):
          pass

Assertions:
  - assert flask.url_for('index', _external=True) == 'http://localhost.localdomain:5000/'
  - assert flask.url_for('sub', _external=True) == 'http://foo.localhost.localdomain:5000/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_proper_test_request_context.json

================================================================================
Test: test_context_binding
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - index (views.py:10)
    Source code:
      def index(js):
          return render_template(f"{js}.html", js=js)
  - meh (test_reqctx.py:113)
    Source code:
      def meh():
              return flask.request.url

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_context_binding
  - app.route (:0)
    Called by: test_context_binding
  - index (views.py:10)
    Called by: test_context_binding
  - meh (test_reqctx.py:113)
    Called by: test_context_binding

Test Source Code:
  def test_context_binding(app):
      @app.route("/")
      def index():
          return f"Hello {flask.request.args['name']}!"
  
      @app.route("/meh")
      def meh():
          return flask.request.url
  
      with app.test_request_context("/?name=World"):
          assert index() == "Hello World!"
      with app.test_request_context("/meh"):
          assert meh() == "http://localhost/meh"
      assert not flask.request

Assertions:
  - assert not flask.request
  - assert index() == 'Hello World!'
  - assert meh() == 'http://localhost/meh'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_context_binding.json

================================================================================
Test: test_context_test
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - ctx.push (:0)
  - ctx.pop (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_context_test
  - ctx.push (:0)
    Called by: test_context_test
  - ctx.pop (:0)
    Called by: test_context_test

Test Source Code:
  def test_context_test(app):
      assert not flask.request
      assert not flask.has_request_context()
      ctx = app.test_request_context()
      ctx.push()
      try:
          assert flask.request
          assert flask.has_request_context()
      finally:
          ctx.pop()

Assertions:
  - assert not flask.request
  - assert not flask.has_request_context()
  - assert flask.request
  - assert flask.has_request_context()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_context_test.json

================================================================================
Test: test_manual_context_binding
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.test_request_context (:0)
  - ctx.push (:0)
  - ctx.pop (:0)
  - index (views.py:10)
    Source code:
      def index(js):
          return render_template(f"{js}.html", js=js)
  - index (views.py:10)
    Source code:
      def index(js):
          return render_template(f"{js}.html", js=js)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_manual_context_binding
  - app.test_request_context (:0)
    Called by: test_manual_context_binding
  - ctx.push (:0)
    Called by: test_manual_context_binding
  - ctx.pop (:0)
    Called by: test_manual_context_binding
  - index (views.py:10)
    Called by: test_manual_context_binding

Test Source Code:
  def test_manual_context_binding(app):
      @app.route("/")
      def index():
          return f"Hello {flask.request.args['name']}!"
  
      ctx = app.test_request_context("/?name=World")
      ctx.push()
      assert index() == "Hello World!"
      ctx.pop()
      with pytest.raises(RuntimeError):
          index()

Assertions:
  - assert index() == 'Hello World!'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_manual_context_binding.json

================================================================================
Test: test_greenlet_context_copying
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - greenlets.run (:0)
  - request_ctx.copy (:0)
  - greenlets.append (:0)
  - greenlet (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_greenlet_context_copying
  - client.get (:0)
    Called by: test_greenlet_context_copying
  - greenlets.run (:0)
    Called by: test_greenlet_context_copying
  - request_ctx.copy (:0)
    Called by: test_greenlet_context_copying
  - greenlets.append (:0)
    Called by: test_greenlet_context_copying
  - greenlet (:0)
    Called by: test_greenlet_context_copying

Test Source Code:
  def test_greenlet_context_copying(self, app, client):
          greenlets = []
  
          @app.route("/")
          def index():
              flask.session["fizz"] = "buzz"
              reqctx = request_ctx.copy()
  
              def g():
                  assert not flask.request
                  assert not flask.current_app
                  with reqctx:
                      assert flask.request
                      assert flask.current_app == app
                      assert flask.request.path == "/"
                      assert flask.request.args["foo"] == "bar"
                      assert flask.session.get("fizz") == "buzz"
                  assert not flask.request
                  return 42
  
              greenlets.append(greenlet(g))
              return "Hello World!"
  
          rv = client.get("/?foo=bar")
          assert rv.data == b"Hello World!"
  
          result = greenlets[0].run()
          assert result == 42

Assertions:
  - assert rv.data == b'Hello World!'
  - assert result == 42
  - assert not flask.request
  - assert not flask.current_app
  - assert not flask.request
  - assert flask.request
  - assert flask.current_app == app
  - assert flask.request.path == '/'
  - assert flask.request.args['foo'] == 'bar'
  - assert flask.session.get('fizz') == 'buzz'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_greenlet_context_copying.json

================================================================================
Test: test_greenlet_context_copying_api
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - greenlets.run (:0)
  - greenlets.append (:0)
  - greenlet (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_greenlet_context_copying_api
  - client.get (:0)
    Called by: test_greenlet_context_copying_api
  - greenlets.run (:0)
    Called by: test_greenlet_context_copying_api
  - greenlets.append (:0)
    Called by: test_greenlet_context_copying_api
  - greenlet (:0)
    Called by: test_greenlet_context_copying_api

Test Source Code:
  def test_greenlet_context_copying_api(self, app, client):
          greenlets = []
  
          @app.route("/")
          def index():
              flask.session["fizz"] = "buzz"
  
              @flask.copy_current_request_context
              def g():
                  assert flask.request
                  assert flask.current_app == app
                  assert flask.request.path == "/"
                  assert flask.request.args["foo"] == "bar"
                  assert flask.session.get("fizz") == "buzz"
                  return 42
  
              greenlets.append(greenlet(g))
              return "Hello World!"
  
          rv = client.get("/?foo=bar")
          assert rv.data == b"Hello World!"
  
          result = greenlets[0].run()
          assert result == 42

Assertions:
  - assert rv.data == b'Hello World!'
  - assert result == 42
  - assert flask.request
  - assert flask.current_app == app
  - assert flask.request.path == '/'
  - assert flask.request.args['foo'] == 'bar'
  - assert flask.session.get('fizz') == 'buzz'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_greenlet_context_copying_api.json

================================================================================
Test: test_session_error_pops_context
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - CustomFlask (:0)
  - app.route (:0)
  - app.test_client.get (:0)
  - FailingSessionInterface (:0)
  - AssertionError (:0)
  - SessionError (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - CustomFlask (:0)
    Called by: test_session_error_pops_context
  - app.route (:0)
    Called by: test_session_error_pops_context
  - app.test_client.get (:0)
    Called by: test_session_error_pops_context
  - FailingSessionInterface (:0)
    Called by: test_session_error_pops_context
  - AssertionError (:0)
    Called by: test_session_error_pops_context
  - SessionError (:0)
    Called by: test_session_error_pops_context
  - app.test_client (:0)
    Called by: test_session_error_pops_context

Test Source Code:
  def test_session_error_pops_context():
      class SessionError(Exception):
          pass
  
      class FailingSessionInterface(SessionInterface):
          def open_session(self, app, request):
              raise SessionError()
  
      class CustomFlask(flask.Flask):
          session_interface = FailingSessionInterface()
  
      app = CustomFlask(__name__)
  
      @app.route("/")
      def index():
          # shouldn't get here
          AssertionError()
  
      response = app.test_client().get("/")
      assert response.status_code == 500
      assert not flask.request
      assert not flask.current_app

Assertions:
  - assert response.status_code == 500
  - assert not flask.request
  - assert not flask.current_app

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_error_pops_context.json

================================================================================
Test: test_session_dynamic_cookie_name
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - CustomFlask (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_client (:0)
  - PathAwareSessionInterface (:0)
  - test_client.post (:0)
  - test_client.post (:0)
  - test_client.get (:0)
  - test_client.get (:0)
  - super.get_cookie_name (:0)
  - super (:0)

Methods Actually Called (Dynamic Analysis):
  - CustomFlask (:0)
    Called by: test_session_dynamic_cookie_name
  - app.route (:0)
    Called by: test_session_dynamic_cookie_name
  - app.test_client (:0)
    Called by: test_session_dynamic_cookie_name
  - PathAwareSessionInterface (:0)
    Called by: test_session_dynamic_cookie_name
  - test_client.post (:0)
    Called by: test_session_dynamic_cookie_name
  - test_client.get (:0)
    Called by: test_session_dynamic_cookie_name
  - super.get_cookie_name (:0)
    Called by: test_session_dynamic_cookie_name
  - super (:0)
    Called by: test_session_dynamic_cookie_name

Test Source Code:
  def test_session_dynamic_cookie_name():
      # This session interface will use a cookie with a different name if the
      # requested url ends with the string "dynamic_cookie"
      class PathAwareSessionInterface(SecureCookieSessionInterface):
          def get_cookie_name(self, app):
              if flask.request.url.endswith("dynamic_cookie"):
                  return "dynamic_cookie_name"
              else:
                  return super().get_cookie_name(app)
  
      class CustomFlask(flask.Flask):
          session_interface = PathAwareSessionInterface()
  
      app = CustomFlask(__name__)
      app.secret_key = "secret_key"
  
      @app.route("/set", methods=["POST"])
      def set():
          flask.session["value"] = flask.request.form["value"]
          return "value set"
  
      @app.route("/get")
      def get():
          v = flask.session.get("value", "None")
          return v
  
      @app.route("/set_dynamic_cookie", methods=["POST"])
      def set_dynamic_cookie():
          flask.session["value"] = flask.request.form["value"]
          return "value set"
  
      @app.route("/get_dynamic_cookie")
      def get_dynamic_cookie():
          v = flask.session.get("value", "None")
          return v
  
      test_client = app.test_client()
  
      # first set the cookie in both /set urls but each with a different value
      assert test_client.post("/set", data={"value": "42"}).data == b"value set"
      assert (
          test_client.post("/set_dynamic_cookie", data={"value": "616"}).data
          == b"value set"
      )
  
      # now check that the relevant values come back - meaning that different
      # cookies are being used for the urls that end with "dynamic cookie"
      assert test_client.get("/get").data == b"42"
      assert test_client.get("/get_dynamic_cookie").data == b"616"

Assertions:
  - assert test_client.post('/set', data={'value': '42'}).data == b'value set'
  - assert test_client.post('/set_dynamic_cookie', data={'value': '616'}).data == b'value set'
  - assert test_client.get('/get').data == b'42'
  - assert test_client.get('/get_dynamic_cookie').data == b'616'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_dynamic_cookie_name.json

================================================================================
Test: test_bad_environ_raises_bad_request
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.request_context (:0)
  - EnvironBuilder (:0)
  - builder.get_environ (:0)
  - app.request_context (:0)
  - app.full_dispatch_request (:0)

Methods Actually Called (Dynamic Analysis):
  - app.request_context (:0)
    Called by: test_bad_environ_raises_bad_request
  - EnvironBuilder (:0)
    Called by: test_bad_environ_raises_bad_request
  - builder.get_environ (:0)
    Called by: test_bad_environ_raises_bad_request
  - app.full_dispatch_request (:0)
    Called by: test_bad_environ_raises_bad_request

Test Source Code:
  def test_bad_environ_raises_bad_request():
      app = flask.Flask(__name__)
  
      from flask.testing import EnvironBuilder
  
      builder = EnvironBuilder(app)
      environ = builder.get_environ()
  
      # use a non-printable character in the Host - this is key to this test
      environ["HTTP_HOST"] = "\x8a"
  
      with app.request_context(environ):
          response = app.full_dispatch_request()
      assert response.status_code == 400

Assertions:
  - assert response.status_code == 400

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_bad_environ_raises_bad_request.json

================================================================================
Test: test_environ_for_valid_idna_completes
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.request_context (:0)
  - app.route (:0)
  - EnvironBuilder (:0)
  - builder.get_environ (:0)
  - app.request_context (:0)
  - app.full_dispatch_request (:0)

Methods Actually Called (Dynamic Analysis):
  - app.request_context (:0)
    Called by: test_environ_for_valid_idna_completes
  - app.route (:0)
    Called by: test_environ_for_valid_idna_completes
  - EnvironBuilder (:0)
    Called by: test_environ_for_valid_idna_completes
  - builder.get_environ (:0)
    Called by: test_environ_for_valid_idna_completes
  - app.full_dispatch_request (:0)
    Called by: test_environ_for_valid_idna_completes

Test Source Code:
  def test_environ_for_valid_idna_completes():
      app = flask.Flask(__name__)
  
      @app.route("/")
      def index():
          return "Hello World!"
  
      from flask.testing import EnvironBuilder
  
      builder = EnvironBuilder(app)
      environ = builder.get_environ()
  
      # these characters are all IDNA-compatible
      environ["HTTP_HOST"] = "ąśźäüжŠßя.com"
  
      with app.request_context(environ):
          response = app.full_dispatch_request()
  
      assert response.status_code == 200

Assertions:
  - assert response.status_code == 200

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_environ_for_valid_idna_completes.json

================================================================================
Test: test_normal_environ_completes
File: __internal__/_data/flask/tests/test_reqctx.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.test_client.get (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_normal_environ_completes
  - app.test_client.get (:0)
    Called by: test_normal_environ_completes
  - app.test_client (:0)
    Called by: test_normal_environ_completes

Test Source Code:
  def test_normal_environ_completes():
      app = flask.Flask(__name__)
  
      @app.route("/")
      def index():
          return "Hello World!"
  
      response = app.test_client().get("/", headers={"host": "xn--on-0ia.com"})
      assert response.status_code == 200

Assertions:
  - assert response.status_code == 200

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_normal_environ_completes.json

================================================================================
Test: test_template_rendered
File: __internal__/_data/flask/tests/test_signals.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - recorded.append (:0)
  - client.get (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_template_rendered
  - recorded.append (:0)
    Called by: test_template_rendered
  - client.get (:0)
    Called by: test_template_rendered
  - len (:0)
    Called by: test_template_rendered

Test Source Code:
  def test_template_rendered(app, client):
      @app.route("/")
      def index():
          return flask.render_template("simple_template.html", whiskey=42)
  
      recorded = []
  
      def record(sender, template, context):
          recorded.append((template, context))
  
      flask.template_rendered.connect(record, app)
      try:
          client.get("/")
          assert len(recorded) == 1
          template, context = recorded[0]
          assert template.name == "simple_template.html"
          assert context["whiskey"] == 42
      finally:
          flask.template_rendered.disconnect(record, app)

Assertions:
  - assert len(recorded) == 1
  - assert template.name == 'simple_template.html'
  - assert context['whiskey'] == 42

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_rendered.json

================================================================================
Test: test_before_render_template
File: __internal__/_data/flask/tests/test_signals.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - recorded.append (:0)
  - app.test_client.get (:0)
  - len (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_before_render_template
  - recorded.append (:0)
    Called by: test_before_render_template
  - app.test_client.get (:0)
    Called by: test_before_render_template
  - len (:0)
    Called by: test_before_render_template
  - app.test_client (:0)
    Called by: test_before_render_template

Test Source Code:
  def test_before_render_template():
      app = flask.Flask(__name__)
  
      @app.route("/")
      def index():
          return flask.render_template("simple_template.html", whiskey=42)
  
      recorded = []
  
      def record(sender, template, context):
          context["whiskey"] = 43
          recorded.append((template, context))
  
      flask.before_render_template.connect(record, app)
      try:
          rv = app.test_client().get("/")
          assert len(recorded) == 1
          template, context = recorded[0]
          assert template.name == "simple_template.html"
          assert context["whiskey"] == 43
          assert rv.data == b"<h1>43</h1>"
      finally:
          flask.before_render_template.disconnect(record, app)

Assertions:
  - assert len(recorded) == 1
  - assert template.name == 'simple_template.html'
  - assert context['whiskey'] == 43
  - assert rv.data == b'<h1>43</h1>'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_before_render_template.json

================================================================================
Test: test_request_signals
File: __internal__/_data/flask/tests/test_signals.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - calls.append (:0)
  - calls.append (:0)
  - calls.append (:0)
  - calls.append (:0)
  - calls.append (:0)
  - app.test_client.get (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_request_signals
  - calls.append (:0)
    Called by: test_request_signals
  - app.test_client.get (:0)
    Called by: test_request_signals
  - app.test_client (:0)
    Called by: test_request_signals

Test Source Code:
  def test_request_signals():
      app = flask.Flask(__name__)
      calls = []
  
      def before_request_signal(sender):
          calls.append("before-signal")
  
      def after_request_signal(sender, response):
          assert response.data == b"stuff"
          calls.append("after-signal")
  
      @app.before_request
      def before_request_handler():
          calls.append("before-handler")
  
      @app.after_request
      def after_request_handler(response):
          calls.append("after-handler")
          response.data = "stuff"
          return response
  
      @app.route("/")
      def index():
          calls.append("handler")
          return "ignored anyway"
  
      flask.request_started.connect(before_request_signal, app)
      flask.request_finished.connect(after_request_signal, app)
  
      try:
          rv = app.test_client().get("/")
          assert rv.data == b"stuff"
  
          assert calls == [
              "before-signal",
              "before-handler",
              "handler",
              "after-handler",
              "after-signal",
          ]
      finally:
          flask.request_started.disconnect(before_request_signal, app)
          flask.request_finished.disconnect(after_request_signal, app)

Assertions:
  - assert response.data == b'stuff'
  - assert rv.data == b'stuff'
  - assert calls == ['before-signal', 'before-handler', 'handler', 'after-handler', 'after-signal']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_signals.json

================================================================================
Test: test_request_exception_signal
File: __internal__/_data/flask/tests/test_signals.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - recorded.append (:0)
  - isinstance (:0)
  - len (:0)
  - app.test_client.get (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_request_exception_signal
  - recorded.append (:0)
    Called by: test_request_exception_signal
  - isinstance (:0)
    Called by: test_request_exception_signal
  - len (:0)
    Called by: test_request_exception_signal
  - app.test_client.get (:0)
    Called by: test_request_exception_signal
  - app.test_client (:0)
    Called by: test_request_exception_signal

Test Source Code:
  def test_request_exception_signal():
      app = flask.Flask(__name__)
      recorded = []
  
      @app.route("/")
      def index():
          raise ZeroDivisionError
  
      def record(sender, exception):
          recorded.append(exception)
  
      flask.got_request_exception.connect(record, app)
      try:
          assert app.test_client().get("/").status_code == 500
          assert len(recorded) == 1
          assert isinstance(recorded[0], ZeroDivisionError)
      finally:
          flask.got_request_exception.disconnect(record, app)

Assertions:
  - assert app.test_client().get('/').status_code == 500
  - assert len(recorded) == 1
  - assert isinstance(recorded[0], ZeroDivisionError)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_exception_signal.json

================================================================================
Test: test_appcontext_signals
File: __internal__/_data/flask/tests/test_signals.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - recorded.append (:0)
  - recorded.append (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_appcontext_signals
  - recorded.append (:0)
    Called by: test_appcontext_signals
  - client.get (:0)
    Called by: test_appcontext_signals

Test Source Code:
  def test_appcontext_signals(app, client):
      recorded = []
  
      def record_push(sender, **kwargs):
          recorded.append("push")
  
      def record_pop(sender, **kwargs):
          recorded.append("pop")
  
      @app.route("/")
      def index():
          return "Hello"
  
      flask.appcontext_pushed.connect(record_push, app)
      flask.appcontext_popped.connect(record_pop, app)
      try:
          rv = client.get("/")
          assert rv.data == b"Hello"
          assert recorded == ["push", "pop"]
      finally:
          flask.appcontext_pushed.disconnect(record_push, app)
          flask.appcontext_popped.disconnect(record_pop, app)

Assertions:
  - assert rv.data == b'Hello'
  - assert recorded == ['push', 'pop']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_appcontext_signals.json

================================================================================
Test: test_flash_signal
File: __internal__/_data/flask/tests/test_signals.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.session_transaction (:0)
  - recorded.append (:0)
  - app.test_client (:0)
  - client.session_transaction (:0)
  - client.get (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_flash_signal
  - client.session_transaction (:0)
    Called by: test_flash_signal
  - recorded.append (:0)
    Called by: test_flash_signal
  - app.test_client (:0)
    Called by: test_flash_signal
  - client.get (:0)
    Called by: test_flash_signal
  - len (:0)
    Called by: test_flash_signal

Test Source Code:
  def test_flash_signal(app):
      @app.route("/")
      def index():
          flask.flash("This is a flash message", category="notice")
          return flask.redirect("/other")
  
      recorded = []
  
      def record(sender, message, category):
          recorded.append((message, category))
  
      flask.message_flashed.connect(record, app)
      try:
          client = app.test_client()
          with client.session_transaction():
              client.get("/")
              assert len(recorded) == 1
              message, category = recorded[0]
              assert message == "This is a flash message"
              assert category == "notice"
      finally:
          flask.message_flashed.disconnect(record, app)

Assertions:
  - assert len(recorded) == 1
  - assert message == 'This is a flash message'
  - assert category == 'notice'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_flash_signal.json

================================================================================
Test: test_appcontext_tearing_down_signal
File: __internal__/_data/flask/tests/test_signals.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - recorded.append (:0)
  - client.get (:0)
  - isinstance (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_appcontext_tearing_down_signal
  - recorded.append (:0)
    Called by: test_appcontext_tearing_down_signal
  - client.get (:0)
    Called by: test_appcontext_tearing_down_signal
  - isinstance (:0)
    Called by: test_appcontext_tearing_down_signal
  - len (:0)
    Called by: test_appcontext_tearing_down_signal

Test Source Code:
  def test_appcontext_tearing_down_signal(app, client):
      app.testing = False
      recorded = []
  
      def record_teardown(sender, exc):
          recorded.append(exc)
  
      @app.route("/")
      def index():
          raise ZeroDivisionError
  
      flask.appcontext_tearing_down.connect(record_teardown, app)
      try:
          rv = client.get("/")
          assert rv.status_code == 500
          assert len(recorded) == 1
          assert isinstance(recorded[0], ZeroDivisionError)
      finally:
          flask.appcontext_tearing_down.disconnect(record_teardown, app)

Assertions:
  - assert rv.status_code == 500
  - assert len(recorded) == 1
  - assert isinstance(recorded[0], ZeroDivisionError)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_appcontext_tearing_down_signal.json

================================================================================
Test: test_send_file
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.open_resource (:0)
  - rv.close (:0)
  - app.open_resource (:0)
  - f.read (:0)

Methods Actually Called (Dynamic Analysis):
  - app.open_resource (:0)
    Called by: test_send_file
  - rv.close (:0)
    Called by: test_send_file
  - f.read (:0)
    Called by: test_send_file

Test Source Code:
  def test_send_file(self, app, req_ctx):
          rv = flask.send_file("static/index.html")
          assert rv.direct_passthrough
          assert rv.mimetype == "text/html"
  
          with app.open_resource("static/index.html") as f:
              rv.direct_passthrough = False
              assert rv.data == f.read()
  
          rv.close()

Assertions:
  - assert rv.direct_passthrough
  - assert rv.mimetype == 'text/html'
  - assert rv.data == f.read()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_send_file.json

================================================================================
Test: test_static_file
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.send_static_file (:0)
  - rv.close (:0)
  - rv.close (:0)
  - app.send_static_file (:0)
  - rv.close (:0)
  - rv.close (:0)
  - app.send_static_file (:0)
  - rv.close (:0)
  - StaticFileApp (:0)
  - FakePath (:0)
  - app.test_request_context (:0)
  - app.send_static_file (:0)
  - rv.close (:0)
  - rv.close (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_static_file
  - app.send_static_file (:0)
    Called by: test_static_file
  - rv.close (:0)
    Called by: test_static_file
  - StaticFileApp (:0)
    Called by: test_static_file
  - FakePath (:0)
    Called by: test_static_file

Test Source Code:
  def test_static_file(self, app, req_ctx):
          # Default max_age is None.
  
          # Test with static file handler.
          rv = app.send_static_file("index.html")
          assert rv.cache_control.max_age is None
          rv.close()
  
          # Test with direct use of send_file.
          rv = flask.send_file("static/index.html")
          assert rv.cache_control.max_age is None
          rv.close()
  
          app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 3600
  
          # Test with static file handler.
          rv = app.send_static_file("index.html")
          assert rv.cache_control.max_age == 3600
          rv.close()
  
          # Test with direct use of send_file.
          rv = flask.send_file("static/index.html")
          assert rv.cache_control.max_age == 3600
          rv.close()
  
          # Test with pathlib.Path.
          rv = app.send_static_file(FakePath("index.html"))
          assert rv.cache_control.max_age == 3600
          rv.close()
  
          class StaticFileApp(flask.Flask):
              def get_send_file_max_age(self, filename):
                  return 10
  
          app = StaticFileApp(__name__)
  
          with app.test_request_context():
              # Test with static file handler.
              rv = app.send_static_file("index.html")
              assert rv.cache_control.max_age == 10
              rv.close()
  
              # Test with direct use of send_file.
              rv = flask.send_file("static/index.html")
              assert rv.cache_control.max_age == 10
              rv.close()

Assertions:
  - assert rv.cache_control.max_age is None
  - assert rv.cache_control.max_age is None
  - assert rv.cache_control.max_age == 3600
  - assert rv.cache_control.max_age == 3600
  - assert rv.cache_control.max_age == 3600
  - assert rv.cache_control.max_age == 10
  - assert rv.cache_control.max_age == 10

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_file.json

================================================================================
Test: test_send_from_directory
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - rv.close (:0)
  - rv.data.strip (:0)

Methods Actually Called (Dynamic Analysis):
  - rv.close (:0)
    Called by: test_send_from_directory
  - rv.data.strip (:0)
    Called by: test_send_from_directory

Test Source Code:
  def test_send_from_directory(self, app, req_ctx):
          app.root_path = os.path.join(
              os.path.dirname(__file__), "test_apps", "subdomaintestmodule"
          )
          rv = flask.send_from_directory("static", "hello.txt")
          rv.direct_passthrough = False
          assert rv.data.strip() == b"Hello Subdomain"
          rv.close()

Assertions:
  - assert rv.data.strip() == b'Hello Subdomain'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_send_from_directory.json

================================================================================
Test: test_url_for_with_anchor
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_url_for_with_anchor

Test Source Code:
  def test_url_for_with_anchor(self, app, req_ctx):
          @app.route("/")
          def index():
              return "42"
  
          assert flask.url_for("index", _anchor="x y") == "/#x%20y"

Assertions:
  - assert flask.url_for('index', _anchor='x y') == '/#x%20y'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_for_with_anchor.json

================================================================================
Test: test_url_for_with_scheme
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_url_for_with_scheme

Test Source Code:
  def test_url_for_with_scheme(self, app, req_ctx):
          @app.route("/")
          def index():
              return "42"
  
          assert (
              flask.url_for("index", _external=True, _scheme="https")
              == "https://localhost/"
          )

Assertions:
  - assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_for_with_scheme.json

================================================================================
Test: test_url_for_with_scheme_not_external
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_url_for_with_scheme_not_external

Test Source Code:
  def test_url_for_with_scheme_not_external(self, app, req_ctx):
          app.add_url_rule("/", endpoint="index")
  
          # Implicit external with scheme.
          url = flask.url_for("index", _scheme="https")
          assert url == "https://localhost/"
  
          # Error when external=False with scheme
          with pytest.raises(ValueError):
              flask.url_for("index", _scheme="https", _external=False)

Assertions:
  - assert url == 'https://localhost/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_for_with_scheme_not_external.json

================================================================================
Test: test_url_for_with_alternating_schemes
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_url_for_with_alternating_schemes

Test Source Code:
  def test_url_for_with_alternating_schemes(self, app, req_ctx):
          @app.route("/")
          def index():
              return "42"
  
          assert flask.url_for("index", _external=True) == "http://localhost/"
          assert (
              flask.url_for("index", _external=True, _scheme="https")
              == "https://localhost/"
          )
          assert flask.url_for("index", _external=True) == "http://localhost/"

Assertions:
  - assert flask.url_for('index', _external=True) == 'http://localhost/'
  - assert flask.url_for('index', _external=True, _scheme='https') == 'https://localhost/'
  - assert flask.url_for('index', _external=True) == 'http://localhost/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_for_with_alternating_schemes.json

================================================================================
Test: test_url_with_method
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - MyView.as_view (:0)
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)

Methods Actually Called (Dynamic Analysis):
  - MyView.as_view (:0)
    Called by: test_url_with_method
  - app.add_url_rule (:0)
    Called by: test_url_with_method

Test Source Code:
  def test_url_with_method(self, app, req_ctx):
          from flask.views import MethodView
  
          class MyView(MethodView):
              def get(self, id=None):
                  if id is None:
                      return "List"
                  return f"Get {id:d}"
  
              def post(self):
                  return "Create"
  
          myview = MyView.as_view("myview")
          app.add_url_rule("/myview/", methods=["GET"], view_func=myview)
          app.add_url_rule("/myview/<int:id>", methods=["GET"], view_func=myview)
          app.add_url_rule("/myview/create", methods=["POST"], view_func=myview)
  
          assert flask.url_for("myview", _method="GET") == "/myview/"
          assert flask.url_for("myview", id=42, _method="GET") == "/myview/42"
          assert flask.url_for("myview", _method="POST") == "/myview/create"

Assertions:
  - assert flask.url_for('myview', _method='GET') == '/myview/'
  - assert flask.url_for('myview', id=42, _method='GET') == '/myview/42'
  - assert flask.url_for('myview', _method='POST') == '/myview/create'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_with_method.json

================================================================================
Test: test_url_for_with_self
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_url_for_with_self

Test Source Code:
  def test_url_for_with_self(self, app, req_ctx):
          @app.route("/<self>")
          def index(self):
              return "42"
  
          assert flask.url_for("index", self="2") == "/2"

Assertions:
  - assert flask.url_for('index', self='2') == '/2'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_for_with_self.json

================================================================================
Test: test_redirect_no_app
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_redirect_no_app():
      response = flask.redirect("https://localhost", 307)
      assert response.location == "https://localhost"
      assert response.status_code == 307

Assertions:
  - assert response.location == 'https://localhost'
  - assert response.status_code == 307

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_redirect_no_app.json

================================================================================
Test: test_redirect_with_app
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_redirect_with_app

Test Source Code:
  def test_redirect_with_app(app):
      def redirect(location, code=302):
          raise ValueError
  
      app.redirect = redirect
  
      with app.app_context(), pytest.raises(ValueError):
          flask.redirect("other")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_redirect_with_app.json

================================================================================
Test: test_abort_no_app
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_abort_no_app():
      with pytest.raises(werkzeug.exceptions.Unauthorized):
          flask.abort(401)
  
      with pytest.raises(LookupError):
          flask.abort(900)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_abort_no_app.json

================================================================================
Test: test_app_aborter_class
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - MyFlask (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - MyFlask (:0)
    Called by: test_app_aborter_class
  - isinstance (:0)
    Called by: test_app_aborter_class

Test Source Code:
  def test_app_aborter_class():
      class MyAborter(werkzeug.exceptions.Aborter):
          pass
  
      class MyFlask(flask.Flask):
          aborter_class = MyAborter
  
      app = MyFlask(__name__)
      assert isinstance(app.aborter, MyAborter)

Assertions:
  - assert isinstance(app.aborter, MyAborter)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_aborter_class.json

================================================================================
Test: test_abort_with_app
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_abort_with_app

Test Source Code:
  def test_abort_with_app(app):
      class My900Error(werkzeug.exceptions.HTTPException):
          code = 900
  
      app.aborter.mapping[900] = My900Error
  
      with app.app_context(), pytest.raises(My900Error):
          flask.abort(900)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_abort_with_app.json

================================================================================
Test: test_name_with_import_error
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - write_text (:0)
  - AssertionError (:0)

Methods Actually Called (Dynamic Analysis):
  - write_text (:0)
    Called by: test_name_with_import_error
  - AssertionError (:0)
    Called by: test_name_with_import_error

Test Source Code:
  def test_name_with_import_error(self, modules_tmp_path):
          (modules_tmp_path / "importerror.py").write_text("raise NotImplementedError()")
          try:
              flask.Flask("importerror")
          except NotImplementedError:
              AssertionError("Flask(import_name) is importing import_name.")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_name_with_import_error.json

================================================================================
Test: test_streaming_with_context
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - generate (templating.py:173)
    Source code:
      def generate() -> t.Iterator[str]:
              yield from template.generate(context)
              template_rendered.send(
                  app, _async_wrapper=app.ensure_sync, template=template, context=context
              )

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_streaming_with_context
  - client.get (:0)
    Called by: test_streaming_with_context
  - generate (templating.py:173)
    Called by: test_streaming_with_context

Test Source Code:
  def test_streaming_with_context(self, app, client):
          @app.route("/")
          def index():
              def generate():
                  yield "Hello "
                  yield flask.request.args["name"]
                  yield "!"
  
              return flask.Response(flask.stream_with_context(generate()))
  
          rv = client.get("/?name=World")
          assert rv.data == b"Hello World!"

Assertions:
  - assert rv.data == b'Hello World!'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_streaming_with_context.json

================================================================================
Test: test_streaming_with_context_as_decorator
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - generate (templating.py:173)
    Source code:
      def generate() -> t.Iterator[str]:
              yield from template.generate(context)
              template_rendered.send(
                  app, _async_wrapper=app.ensure_sync, template=template, context=context
              )

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_streaming_with_context_as_decorator
  - client.get (:0)
    Called by: test_streaming_with_context_as_decorator
  - generate (templating.py:173)
    Called by: test_streaming_with_context_as_decorator

Test Source Code:
  def test_streaming_with_context_as_decorator(self, app, client):
          @app.route("/")
          def index():
              @flask.stream_with_context
              def generate(hello):
                  yield hello
                  yield flask.request.args["name"]
                  yield "!"
  
              return flask.Response(generate("Hello "))
  
          rv = client.get("/?name=World")
          assert rv.data == b"Hello World!"

Assertions:
  - assert rv.data == b'Hello World!'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_streaming_with_context_as_decorator.json

================================================================================
Test: test_streaming_with_context_and_custom_close
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - called.append (:0)
  - next (:0)
  - Wrapper (:0)
  - generate (templating.py:173)
    Source code:
      def generate() -> t.Iterator[str]:
              yield from template.generate(context)
              template_rendered.send(
                  app, _async_wrapper=app.ensure_sync, template=template, context=context
              )

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_streaming_with_context_and_custom_close
  - client.get (:0)
    Called by: test_streaming_with_context_and_custom_close
  - called.append (:0)
    Called by: test_streaming_with_context_and_custom_close
  - next (:0)
    Called by: test_streaming_with_context_and_custom_close
  - Wrapper (:0)
    Called by: test_streaming_with_context_and_custom_close
  - generate (templating.py:173)
    Called by: test_streaming_with_context_and_custom_close

Test Source Code:
  def test_streaming_with_context_and_custom_close(self, app, client):
          called = []
  
          class Wrapper:
              def __init__(self, gen):
                  self._gen = gen
  
              def __iter__(self):
                  return self
  
              def close(self):
                  called.append(42)
  
              def __next__(self):
                  return next(self._gen)
  
              next = __next__
  
          @app.route("/")
          def index():
              def generate():
                  yield "Hello "
                  yield flask.request.args["name"]
                  yield "!"
  
              return flask.Response(flask.stream_with_context(Wrapper(generate())))
  
          rv = client.get("/?name=World")
          assert rv.data == b"Hello World!"
          assert called == [42]

Assertions:
  - assert rv.data == b'Hello World!'
  - assert called == [42]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_streaming_with_context_and_custom_close.json

================================================================================
Test: test_stream_keeps_session
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - gen (test_helpers.py:301)
    Source code:
      def gen():
                      yield flask.session["test"]

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_stream_keeps_session
  - client.get (:0)
    Called by: test_stream_keeps_session
  - gen (test_helpers.py:301)
    Called by: test_stream_keeps_session

Test Source Code:
  def test_stream_keeps_session(self, app, client):
          @app.route("/")
          def index():
              flask.session["test"] = "flask"
  
              @flask.stream_with_context
              def gen():
                  yield flask.session["test"]
  
              return flask.Response(gen())
  
          rv = client.get("/")
          assert rv.data == b"flask"

Assertions:
  - assert rv.data == b'flask'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_stream_keeps_session.json

================================================================================
Test: test_get_debug_flag
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - monkeypatch.setenv (:0)
  - get_debug_flag (helpers.py:27)
    Source code:
      def get_debug_flag() -> bool:
          """Get whether debug mode should be enabled for the app, indicated by the
          :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.
          """
          val = os.environ.get("FLASK_DEBUG")
          return bool(val and val.lower() not in {"0", "false", "no"})

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setenv (:0)
    Called by: test_get_debug_flag
  - get_debug_flag (helpers.py:27)
    Called by: test_get_debug_flag

Test Source Code:
  def test_get_debug_flag(self, monkeypatch, debug, expect):
          monkeypatch.setenv("FLASK_DEBUG", debug)
          assert get_debug_flag() == expect

Assertions:
  - assert get_debug_flag() == expect

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_get_debug_flag.json

================================================================================
Test: test_make_response
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_make_response

Test Source Code:
  def test_make_response(self):
          app = flask.Flask(__name__)
          with app.test_request_context():
              rv = flask.helpers.make_response()
              assert rv.status_code == 200
              assert rv.mimetype == "text/html"
  
              rv = flask.helpers.make_response("Hello")
              assert rv.status_code == 200
              assert rv.data == b"Hello"
              assert rv.mimetype == "text/html"

Assertions:
  - assert rv.status_code == 200
  - assert rv.mimetype == 'text/html'
  - assert rv.status_code == 200
  - assert rv.data == b'Hello'
  - assert rv.mimetype == 'text/html'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_make_response.json

================================================================================
Test: test_open_resource
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.open_resource (:0)
  - app.open_resource (:0)
  - str (:0)
  - f.read (:0)

Methods Actually Called (Dynamic Analysis):
  - app.open_resource (:0)
    Called by: test_open_resource
  - str (:0)
    Called by: test_open_resource
  - f.read (:0)
    Called by: test_open_resource

Test Source Code:
  def test_open_resource(mode):
      app = flask.Flask(__name__)
  
      with app.open_resource("static/index.html", mode) as f:
          assert "<h1>Hello World!</h1>" in str(f.read())

Assertions:
  - assert '<h1>Hello World!</h1>' in str(f.read())

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_open_resource.json

================================================================================
Test: test_open_resource_exceptions
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.open_resource (:0)

Methods Actually Called (Dynamic Analysis):
  - app.open_resource (:0)
    Called by: test_open_resource_exceptions

Test Source Code:
  def test_open_resource_exceptions(mode):
      app = flask.Flask(__name__)
  
      with pytest.raises(ValueError):
          app.open_resource("static/index.html", mode)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_open_resource_exceptions.json

================================================================================
Test: test_open_resource_with_encoding
File: __internal__/_data/flask/tests/test_helpers.py

Methods Under Test (Static Analysis):
  - app.open_resource (:0)
  - write_text (:0)
  - app.open_resource (:0)
  - f.read (:0)

Methods Actually Called (Dynamic Analysis):
  - app.open_resource (:0)
    Called by: test_open_resource_with_encoding
  - write_text (:0)
    Called by: test_open_resource_with_encoding
  - f.read (:0)
    Called by: test_open_resource_with_encoding

Test Source Code:
  def test_open_resource_with_encoding(tmp_path, encoding):
      app = flask.Flask(__name__, root_path=os.fspath(tmp_path))
      (tmp_path / "test").write_text("test", encoding=encoding)
  
      with app.open_resource("test", mode="rt", encoding=encoding) as f:
          assert f.read() == "test"

Assertions:
  - assert f.read() == 'test'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_open_resource_with_encoding.json

================================================================================
Test: test_async_route
File: __internal__/_data/flask/tests/test_async.py

Methods Under Test (Static Analysis):
  - async_app.test_client (:0)
  - test_client.get (:0)
  - test_client.post (:0)
  - response.get_data (:0)
  - response.get_data (:0)

Methods Actually Called (Dynamic Analysis):
  - async_app.test_client (:0)
    Called by: test_async_route
  - test_client.get (:0)
    Called by: test_async_route
  - test_client.post (:0)
    Called by: test_async_route
  - response.get_data (:0)
    Called by: test_async_route

Test Source Code:
  def test_async_route(path, async_app):
      test_client = async_app.test_client()
      response = test_client.get(path)
      assert b"GET" in response.get_data()
      response = test_client.post(path)
      assert b"POST" in response.get_data()

Assertions:
  - assert b'GET' in response.get_data()
  - assert b'POST' in response.get_data()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_async_route.json

================================================================================
Test: test_async_error_handler
File: __internal__/_data/flask/tests/test_async.py

Methods Under Test (Static Analysis):
  - async_app.test_client (:0)
  - test_client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - async_app.test_client (:0)
    Called by: test_async_error_handler
  - test_client.get (:0)
    Called by: test_async_error_handler

Test Source Code:
  def test_async_error_handler(path, async_app):
      test_client = async_app.test_client()
      response = test_client.get(path)
      assert response.status_code == 412

Assertions:
  - assert response.status_code == 412

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_async_error_handler.json

================================================================================
Test: test_async_before_after_request
File: __internal__/_data/flask/tests/test_async.py

Methods Under Test (Static Analysis):
  - Flask (:0)
  - app.route (:0)
  - Blueprint (:0)
  - blueprint.route (:0)
  - app.register_blueprint (:0)
  - app.test_client (:0)
  - test_client.get (:0)
  - test_client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - Flask (:0)
    Called by: test_async_before_after_request
  - app.route (:0)
    Called by: test_async_before_after_request
  - Blueprint (:0)
    Called by: test_async_before_after_request
  - blueprint.route (:0)
    Called by: test_async_before_after_request
  - app.register_blueprint (:0)
    Called by: test_async_before_after_request
  - app.test_client (:0)
    Called by: test_async_before_after_request
  - test_client.get (:0)
    Called by: test_async_before_after_request

Test Source Code:
  def test_async_before_after_request():
      app_before_called = False
      app_after_called = False
      bp_before_called = False
      bp_after_called = False
  
      app = Flask(__name__)
  
      @app.route("/")
      def index():
          return ""
  
      @app.before_request
      async def before():
          nonlocal app_before_called
          app_before_called = True
  
      @app.after_request
      async def after(response):
          nonlocal app_after_called
          app_after_called = True
          return response
  
      blueprint = Blueprint("bp", __name__)
  
      @blueprint.route("/")
      def bp_index():
          return ""
  
      @blueprint.before_request
      async def bp_before():
          nonlocal bp_before_called
          bp_before_called = True
  
      @blueprint.after_request
      async def bp_after(response):
          nonlocal bp_after_called
          bp_after_called = True
          return response
  
      app.register_blueprint(blueprint, url_prefix="/bp")
  
      test_client = app.test_client()
      test_client.get("/")
      assert app_before_called
      assert app_after_called
      test_client.get("/bp/")
      assert bp_before_called
      assert bp_after_called

Assertions:
  - assert app_before_called
  - assert app_after_called
  - assert bp_before_called
  - assert bp_after_called

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_async_before_after_request.json

================================================================================
Test: test_suppressed_exception_logging
File: __internal__/_data/flask/tests/test_subclassing.py

Methods Under Test (Static Analysis):
  - StringIO (:0)
  - SuppressedFlask (:0)
  - app.route (:0)
  - app.test_client.get (:0)
  - Exception (:0)
  - out.getvalue (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - StringIO (:0)
    Called by: test_suppressed_exception_logging
  - SuppressedFlask (:0)
    Called by: test_suppressed_exception_logging
  - app.route (:0)
    Called by: test_suppressed_exception_logging
  - app.test_client.get (:0)
    Called by: test_suppressed_exception_logging
  - Exception (:0)
    Called by: test_suppressed_exception_logging
  - out.getvalue (:0)
    Called by: test_suppressed_exception_logging
  - app.test_client (:0)
    Called by: test_suppressed_exception_logging

Test Source Code:
  def test_suppressed_exception_logging():
      class SuppressedFlask(flask.Flask):
          def log_exception(self, exc_info):
              pass
  
      out = StringIO()
      app = SuppressedFlask(__name__)
  
      @app.route("/")
      def index():
          raise Exception("test")
  
      rv = app.test_client().get("/", errors_stream=out)
      assert rv.status_code == 500
      assert b"Internal Server Error" in rv.data
      assert not out.getvalue()

Assertions:
  - assert rv.status_code == 500
  - assert b'Internal Server Error' in rv.data
  - assert not out.getvalue()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_suppressed_exception_logging.json

================================================================================
Test: test_options_work
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.open (:0)
  - sorted (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_options_work
  - client.open (:0)
    Called by: test_options_work
  - sorted (:0)
    Called by: test_options_work

Test Source Code:
  def test_options_work(app, client):
      @app.route("/", methods=["GET", "POST"])
      def index():
          return "Hello World"
  
      rv = client.open("/", method="OPTIONS")
      assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST"]
      assert rv.data == b""

Assertions:
  - assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']
  - assert rv.data == b''

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_options_work.json

================================================================================
Test: test_options_on_multiple_rules
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.open (:0)
  - sorted (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_options_on_multiple_rules
  - client.open (:0)
    Called by: test_options_on_multiple_rules
  - sorted (:0)
    Called by: test_options_on_multiple_rules

Test Source Code:
  def test_options_on_multiple_rules(app, client):
      @app.route("/", methods=["GET", "POST"])
      def index():
          return "Hello World"
  
      @app.route("/", methods=["PUT"])
      def index_put():
          return "Aha!"
  
      rv = client.open("/", method="OPTIONS")
      assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST", "PUT"]

Assertions:
  - assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_options_on_multiple_rules.json

================================================================================
Test: test_method_route
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - getattr (:0)
  - getattr (:0)
  - method_route (:0)
  - client_method (:0)

Methods Actually Called (Dynamic Analysis):
  - getattr (:0)
    Called by: test_method_route
  - method_route (:0)
    Called by: test_method_route
  - client_method (:0)
    Called by: test_method_route

Test Source Code:
  def test_method_route(app, client, method):
      method_route = getattr(app, method)
      client_method = getattr(client, method)
  
      @method_route("/")
      def hello():
          return "Hello"
  
      assert client_method("/").data == b"Hello"

Assertions:
  - assert client_method('/').data == b'Hello'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_method_route.json

================================================================================
Test: test_method_route_no_methods
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.get (:0)
    Called by: test_method_route_no_methods

Test Source Code:
  def test_method_route_no_methods(app):
      with pytest.raises(TypeError):
          app.get("/", methods=["GET", "POST"])

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_method_route_no_methods.json

================================================================================
Test: test_provide_automatic_options_attr
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.test_client.open (:0)
  - app.route (:0)
  - app.test_client.open (:0)
  - app.route (:0)
  - app.route (:0)
  - sorted (:0)
  - app.test_client (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_provide_automatic_options_attr
  - app.test_client.open (:0)
    Called by: test_provide_automatic_options_attr
  - sorted (:0)
    Called by: test_provide_automatic_options_attr
  - app.test_client (:0)
    Called by: test_provide_automatic_options_attr

Test Source Code:
  def test_provide_automatic_options_attr():
      app = flask.Flask(__name__)
  
      def index():
          return "Hello World!"
  
      index.provide_automatic_options = False
      app.route("/")(index)
      rv = app.test_client().open("/", method="OPTIONS")
      assert rv.status_code == 405
  
      app = flask.Flask(__name__)
  
      def index2():
          return "Hello World!"
  
      index2.provide_automatic_options = True
      app.route("/", methods=["OPTIONS"])(index2)
      rv = app.test_client().open("/", method="OPTIONS")
      assert sorted(rv.allow) == ["OPTIONS"]

Assertions:
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['OPTIONS']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_provide_automatic_options_attr.json

================================================================================
Test: test_provide_automatic_options_kwarg
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)
  - client.post (:0)
  - client.open (:0)
  - client.head (:0)
  - client.delete (:0)
  - client.open (:0)
  - sorted (:0)
  - sorted (:0)
  - client.get (:0)
  - client.post (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_provide_automatic_options_kwarg
  - client.post (:0)
    Called by: test_provide_automatic_options_kwarg
  - client.open (:0)
    Called by: test_provide_automatic_options_kwarg
  - client.head (:0)
    Called by: test_provide_automatic_options_kwarg
  - client.delete (:0)
    Called by: test_provide_automatic_options_kwarg
  - sorted (:0)
    Called by: test_provide_automatic_options_kwarg
  - client.get (:0)
    Called by: test_provide_automatic_options_kwarg

Test Source Code:
  def test_provide_automatic_options_kwarg(app, client):
      def index():
          return flask.request.method
  
      def more():
          return flask.request.method
  
      app.add_url_rule("/", view_func=index, provide_automatic_options=False)
      app.add_url_rule(
          "/more",
          view_func=more,
          methods=["GET", "POST"],
          provide_automatic_options=False,
      )
      assert client.get("/").data == b"GET"
  
      rv = client.post("/")
      assert rv.status_code == 405
      assert sorted(rv.allow) == ["GET", "HEAD"]
  
      rv = client.open("/", method="OPTIONS")
      assert rv.status_code == 405
  
      rv = client.head("/")
      assert rv.status_code == 200
      assert not rv.data  # head truncates
      assert client.post("/more").data == b"POST"
      assert client.get("/more").data == b"GET"
  
      rv = client.delete("/more")
      assert rv.status_code == 405
      assert sorted(rv.allow) == ["GET", "HEAD", "POST"]
  
      rv = client.open("/more", method="OPTIONS")
      assert rv.status_code == 405

Assertions:
  - assert client.get('/').data == b'GET'
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['GET', 'HEAD']
  - assert rv.status_code == 405
  - assert rv.status_code == 200
  - assert not rv.data
  - assert client.post('/more').data == b'POST'
  - assert client.get('/more').data == b'GET'
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['GET', 'HEAD', 'POST']
  - assert rv.status_code == 405

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_provide_automatic_options_kwarg.json

================================================================================
Test: test_request_dispatching
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.post (:0)
  - client.head (:0)
  - client.delete (:0)
  - sorted (:0)
  - sorted (:0)
  - client.get (:0)
  - client.post (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_request_dispatching
  - client.post (:0)
    Called by: test_request_dispatching
  - client.head (:0)
    Called by: test_request_dispatching
  - client.delete (:0)
    Called by: test_request_dispatching
  - sorted (:0)
    Called by: test_request_dispatching
  - client.get (:0)
    Called by: test_request_dispatching

Test Source Code:
  def test_request_dispatching(app, client):
      @app.route("/")
      def index():
          return flask.request.method
  
      @app.route("/more", methods=["GET", "POST"])
      def more():
          return flask.request.method
  
      assert client.get("/").data == b"GET"
      rv = client.post("/")
      assert rv.status_code == 405
      assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS"]
      rv = client.head("/")
      assert rv.status_code == 200
      assert not rv.data  # head truncates
      assert client.post("/more").data == b"POST"
      assert client.get("/more").data == b"GET"
      rv = client.delete("/more")
      assert rv.status_code == 405
      assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST"]

Assertions:
  - assert client.get('/').data == b'GET'
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']
  - assert rv.status_code == 200
  - assert not rv.data
  - assert client.post('/more').data == b'POST'
  - assert client.get('/more').data == b'GET'
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_dispatching.json

================================================================================
Test: test_disallow_string_for_allowed_methods
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_disallow_string_for_allowed_methods

Test Source Code:
  def test_disallow_string_for_allowed_methods(app):
      with pytest.raises(TypeError):
          app.add_url_rule("/", methods="GET POST", endpoint="test")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_disallow_string_for_allowed_methods.json

================================================================================
Test: test_url_mapping
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)
  - client.post (:0)
  - client.head (:0)
  - client.delete (:0)
  - client.open (:0)
  - sorted (:0)
  - sorted (:0)
  - rv.data.decode (:0)
  - client.get (:0)
  - client.post (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_url_mapping
  - client.post (:0)
    Called by: test_url_mapping
  - client.head (:0)
    Called by: test_url_mapping
  - client.delete (:0)
    Called by: test_url_mapping
  - client.open (:0)
    Called by: test_url_mapping
  - sorted (:0)
    Called by: test_url_mapping
  - rv.data.decode (:0)
    Called by: test_url_mapping
  - client.get (:0)
    Called by: test_url_mapping

Test Source Code:
  def test_url_mapping(app, client):
      random_uuid4 = "7eb41166-9ebf-4d26-b771-ea3f54f8b383"
  
      def index():
          return flask.request.method
  
      def more():
          return flask.request.method
  
      def options():
          return random_uuid4
  
      app.add_url_rule("/", "index", index)
      app.add_url_rule("/more", "more", more, methods=["GET", "POST"])
  
      # Issue 1288: Test that automatic options are not added
      #             when non-uppercase 'options' in methods
      app.add_url_rule("/options", "options", options, methods=["options"])
  
      assert client.get("/").data == b"GET"
      rv = client.post("/")
      assert rv.status_code == 405
      assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS"]
      rv = client.head("/")
      assert rv.status_code == 200
      assert not rv.data  # head truncates
      assert client.post("/more").data == b"POST"
      assert client.get("/more").data == b"GET"
      rv = client.delete("/more")
      assert rv.status_code == 405
      assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST"]
      rv = client.open("/options", method="OPTIONS")
      assert rv.status_code == 200
      assert random_uuid4 in rv.data.decode("utf-8")

Assertions:
  - assert client.get('/').data == b'GET'
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS']
  - assert rv.status_code == 200
  - assert not rv.data
  - assert client.post('/more').data == b'POST'
  - assert client.get('/more').data == b'GET'
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['GET', 'HEAD', 'OPTIONS', 'POST']
  - assert rv.status_code == 200
  - assert random_uuid4 in rv.data.decode('utf-8')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_mapping.json

================================================================================
Test: test_werkzeug_routing
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.url_map.add (:0)
  - Submount (:0)
  - client.get (:0)
  - client.get (:0)
  - Rule (:0)
  - Rule (:0)

Methods Actually Called (Dynamic Analysis):
  - app.url_map.add (:0)
    Called by: test_werkzeug_routing
  - Submount (:0)
    Called by: test_werkzeug_routing
  - client.get (:0)
    Called by: test_werkzeug_routing
  - Rule (:0)
    Called by: test_werkzeug_routing

Test Source Code:
  def test_werkzeug_routing(app, client):
      from werkzeug.routing import Rule
      from werkzeug.routing import Submount
  
      app.url_map.add(
          Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
      )
  
      def bar():
          return "bar"
  
      def index():
          return "index"
  
      app.view_functions["bar"] = bar
      app.view_functions["index"] = index
  
      assert client.get("/foo/").data == b"index"
      assert client.get("/foo/bar").data == b"bar"

Assertions:
  - assert client.get('/foo/').data == b'index'
  - assert client.get('/foo/bar').data == b'bar'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_werkzeug_routing.json

================================================================================
Test: test_endpoint_decorator
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.url_map.add (:0)
  - app.endpoint (:0)
  - app.endpoint (:0)
  - Submount (:0)
  - client.get (:0)
  - client.get (:0)
  - Rule (:0)
  - Rule (:0)

Methods Actually Called (Dynamic Analysis):
  - app.url_map.add (:0)
    Called by: test_endpoint_decorator
  - app.endpoint (:0)
    Called by: test_endpoint_decorator
  - Submount (:0)
    Called by: test_endpoint_decorator
  - client.get (:0)
    Called by: test_endpoint_decorator
  - Rule (:0)
    Called by: test_endpoint_decorator

Test Source Code:
  def test_endpoint_decorator(app, client):
      from werkzeug.routing import Rule
      from werkzeug.routing import Submount
  
      app.url_map.add(
          Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
      )
  
      @app.endpoint("bar")
      def bar():
          return "bar"
  
      @app.endpoint("index")
      def index():
          return "index"
  
      assert client.get("/foo/").data == b"index"
      assert client.get("/foo/bar").data == b"bar"

Assertions:
  - assert client.get('/foo/').data == b'index'
  - assert client.get('/foo/bar').data == b'bar'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_endpoint_decorator.json

================================================================================
Test: test_session
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.post (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session
  - client.post (:0)
    Called by: test_session
  - client.get (:0)
    Called by: test_session

Test Source Code:
  def test_session(app, client):
      @app.route("/set", methods=["POST"])
      def set():
          assert not flask.session.accessed
          assert not flask.session.modified
          flask.session["value"] = flask.request.form["value"]
          assert flask.session.accessed
          assert flask.session.modified
          return "value set"
  
      @app.route("/get")
      def get():
          assert not flask.session.accessed
          assert not flask.session.modified
          v = flask.session.get("value", "None")
          assert flask.session.accessed
          assert not flask.session.modified
          return v
  
      assert client.post("/set", data={"value": "42"}).data == b"value set"
      assert client.get("/get").data == b"42"

Assertions:
  - assert client.post('/set', data={'value': '42'}).data == b'value set'
  - assert client.get('/get').data == b'42'
  - assert not flask.session.accessed
  - assert not flask.session.modified
  - assert flask.session.accessed
  - assert flask.session.modified
  - assert not flask.session.accessed
  - assert not flask.session.modified
  - assert flask.session.accessed
  - assert not flask.session.modified

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session.json

================================================================================
Test: test_session_path
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.config.update (:0)
  - app.route (:0)
  - client.get (:0)
  - rv.headers.lower (:0)

Methods Actually Called (Dynamic Analysis):
  - app.config.update (:0)
    Called by: test_session_path
  - app.route (:0)
    Called by: test_session_path
  - client.get (:0)
    Called by: test_session_path
  - rv.headers.lower (:0)
    Called by: test_session_path

Test Source Code:
  def test_session_path(app, client):
      app.config.update(APPLICATION_ROOT="/foo")
  
      @app.route("/")
      def index():
          flask.session["testing"] = 42
          return "Hello World"
  
      rv = client.get("/", "http://example.com:8080/foo")
      assert "path=/foo" in rv.headers["set-cookie"].lower()

Assertions:
  - assert 'path=/foo' in rv.headers['set-cookie'].lower()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_path.json

================================================================================
Test: test_session_using_application_root
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - PrefixPathMiddleware (:0)
  - app.config.update (:0)
  - app.route (:0)
  - client.get (:0)
  - rv.headers.lower (:0)
  - self.app (:0)

Methods Actually Called (Dynamic Analysis):
  - PrefixPathMiddleware (:0)
    Called by: test_session_using_application_root
  - app.config.update (:0)
    Called by: test_session_using_application_root
  - app.route (:0)
    Called by: test_session_using_application_root
  - client.get (:0)
    Called by: test_session_using_application_root
  - rv.headers.lower (:0)
    Called by: test_session_using_application_root
  - self.app (:0)
    Called by: test_session_using_application_root

Test Source Code:
  def test_session_using_application_root(app, client):
      class PrefixPathMiddleware:
          def __init__(self, app, prefix):
              self.app = app
              self.prefix = prefix
  
          def __call__(self, environ, start_response):
              environ["SCRIPT_NAME"] = self.prefix
              return self.app(environ, start_response)
  
      app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, "/bar")
      app.config.update(APPLICATION_ROOT="/bar")
  
      @app.route("/")
      def index():
          flask.session["testing"] = 42
          return "Hello World"
  
      rv = client.get("/", "http://example.com:8080/")
      assert "path=/bar" in rv.headers["set-cookie"].lower()

Assertions:
  - assert 'path=/bar' in rv.headers['set-cookie'].lower()

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_using_application_root.json

================================================================================
Test: test_session_using_session_settings
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.config.update (:0)
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - rv.headers.lower (:0)
  - client.get (:0)
  - rv.headers.lower (:0)

Methods Actually Called (Dynamic Analysis):
  - app.config.update (:0)
    Called by: test_session_using_session_settings
  - app.route (:0)
    Called by: test_session_using_session_settings
  - client.get (:0)
    Called by: test_session_using_session_settings
  - rv.headers.lower (:0)
    Called by: test_session_using_session_settings

Test Source Code:
  def test_session_using_session_settings(app, client):
      app.config.update(
          SERVER_NAME="www.example.com:8080",
          APPLICATION_ROOT="/test",
          SESSION_COOKIE_DOMAIN=".example.com",
          SESSION_COOKIE_HTTPONLY=False,
          SESSION_COOKIE_SECURE=True,
          SESSION_COOKIE_PARTITIONED=True,
          SESSION_COOKIE_SAMESITE="Lax",
          SESSION_COOKIE_PATH="/",
      )
  
      @app.route("/")
      def index():
          flask.session["testing"] = 42
          return "Hello World"
  
      @app.route("/clear")
      def clear():
          flask.session.pop("testing", None)
          return "Goodbye World"
  
      rv = client.get("/", "http://www.example.com:8080/test/")
      cookie = rv.headers["set-cookie"].lower()
      # or condition for Werkzeug < 2.3
      assert "domain=example.com" in cookie or "domain=.example.com" in cookie
      assert "path=/" in cookie
      assert "secure" in cookie
      assert "httponly" not in cookie
      assert "samesite" in cookie
      assert "partitioned" in cookie
  
      rv = client.get("/clear", "http://www.example.com:8080/test/")
      cookie = rv.headers["set-cookie"].lower()
      assert "session=;" in cookie
      # or condition for Werkzeug < 2.3
      assert "domain=example.com" in cookie or "domain=.example.com" in cookie
      assert "path=/" in cookie
      assert "secure" in cookie
      assert "samesite" in cookie
      assert "partitioned" in cookie

Assertions:
  - assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie
  - assert 'path=/' in cookie
  - assert 'secure' in cookie
  - assert 'httponly' not in cookie
  - assert 'samesite' in cookie
  - assert 'partitioned' in cookie
  - assert 'session=;' in cookie
  - assert 'domain=example.com' in cookie or 'domain=.example.com' in cookie
  - assert 'path=/' in cookie
  - assert 'secure' in cookie
  - assert 'samesite' in cookie
  - assert 'partitioned' in cookie

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_using_session_settings.json

================================================================================
Test: test_session_using_samesite_attribute
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.config.update (:0)
  - app.config.update (:0)
  - client.get (:0)
  - rv.headers.lower (:0)
  - app.config.update (:0)
  - client.get (:0)
  - rv.headers.lower (:0)
  - app.config.update (:0)
  - client.get (:0)
  - rv.headers.lower (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session_using_samesite_attribute
  - app.config.update (:0)
    Called by: test_session_using_samesite_attribute
  - client.get (:0)
    Called by: test_session_using_samesite_attribute
  - rv.headers.lower (:0)
    Called by: test_session_using_samesite_attribute

Test Source Code:
  def test_session_using_samesite_attribute(app, client):
      @app.route("/")
      def index():
          flask.session["testing"] = 42
          return "Hello World"
  
      app.config.update(SESSION_COOKIE_SAMESITE="invalid")
  
      with pytest.raises(ValueError):
          client.get("/")
  
      app.config.update(SESSION_COOKIE_SAMESITE=None)
      rv = client.get("/")
      cookie = rv.headers["set-cookie"].lower()
      assert "samesite" not in cookie
  
      app.config.update(SESSION_COOKIE_SAMESITE="Strict")
      rv = client.get("/")
      cookie = rv.headers["set-cookie"].lower()
      assert "samesite=strict" in cookie
  
      app.config.update(SESSION_COOKIE_SAMESITE="Lax")
      rv = client.get("/")
      cookie = rv.headers["set-cookie"].lower()
      assert "samesite=lax" in cookie

Assertions:
  - assert 'samesite' not in cookie
  - assert 'samesite=strict' in cookie
  - assert 'samesite=lax' in cookie

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_using_samesite_attribute.json

================================================================================
Test: test_missing_session
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - expect_exception (test_basic.py:364)
    Source code:
      def expect_exception(f, *args, **kwargs):
              e = pytest.raises(RuntimeError, f, *args, **kwargs)
              assert e.value.args and "session is unavailable" in e.value.args[0]
  - expect_exception (test_basic.py:364)
    Source code:
      def expect_exception(f, *args, **kwargs):
              e = pytest.raises(RuntimeError, f, *args, **kwargs)
              assert e.value.args and "session is unavailable" in e.value.args[0]

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_missing_session
  - expect_exception (test_basic.py:364)
    Called by: test_missing_session

Test Source Code:
  def test_missing_session(app):
      app.secret_key = None
  
      def expect_exception(f, *args, **kwargs):
          e = pytest.raises(RuntimeError, f, *args, **kwargs)
          assert e.value.args and "session is unavailable" in e.value.args[0]
  
      with app.test_request_context():
          assert flask.session.get("missing_key") is None
          expect_exception(flask.session.__setitem__, "foo", 42)
          expect_exception(flask.session.pop, "foo")

Assertions:
  - assert e.value.args and 'session is unavailable' in e.value.args[0]
  - assert flask.session.get('missing_key') is None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_missing_session.json

================================================================================
Test: test_session_secret_key_fallbacks
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.post (:0)
  - app.get (:0)
  - client.post (:0)
  - dict (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.post (:0)
    Called by: test_session_secret_key_fallbacks
  - app.get (:0)
    Called by: test_session_secret_key_fallbacks
  - client.post (:0)
    Called by: test_session_secret_key_fallbacks
  - dict (:0)
    Called by: test_session_secret_key_fallbacks
  - client.get (:0)
    Called by: test_session_secret_key_fallbacks

Test Source Code:
  def test_session_secret_key_fallbacks(app, client) -> None:
      @app.post("/")
      def set_session() -> str:
          flask.session["a"] = 1
          return ""
  
      @app.get("/")
      def get_session() -> dict[str, t.Any]:
          return dict(flask.session)
  
      # Set session with initial secret key
      client.post()
      assert client.get().json == {"a": 1}
      # Change secret key, session can't be loaded and appears empty
      app.secret_key = "new test key"
      assert client.get().json == {}
      # Add initial secret key as fallback, session can be loaded
      app.config["SECRET_KEY_FALLBACKS"] = ["test key"]
      assert client.get().json == {"a": 1}

Assertions:
  - assert client.get().json == {'a': 1}
  - assert client.get().json == {}
  - assert client.get().json == {'a': 1}

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_secret_key_fallbacks.json

================================================================================
Test: test_session_expiration
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - parse_date (:0)
  - client.get (:0)
  - client.get (:0)
  - str (:0)
  - match.group (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session_expiration
  - client.get (:0)
    Called by: test_session_expiration
  - parse_date (:0)
    Called by: test_session_expiration
  - str (:0)
    Called by: test_session_expiration
  - match.group (:0)
    Called by: test_session_expiration

Test Source Code:
  def test_session_expiration(app, client):
      permanent = True
  
      @app.route("/")
      def index():
          flask.session["test"] = 42
          flask.session.permanent = permanent
          return ""
  
      @app.route("/test")
      def test():
          return str(flask.session.permanent)
  
      rv = client.get("/")
      assert "set-cookie" in rv.headers
      match = re.search(r"(?i)\bexpires=([^;]+)", rv.headers["set-cookie"])
      expires = parse_date(match.group())
      expected = datetime.now(timezone.utc) + app.permanent_session_lifetime
      assert expires.year == expected.year
      assert expires.month == expected.month
      assert expires.day == expected.day
  
      rv = client.get("/test")
      assert rv.data == b"True"
  
      permanent = False
      rv = client.get("/")
      assert "set-cookie" in rv.headers
      match = re.search(r"\bexpires=([^;]+)", rv.headers["set-cookie"])
      assert match is None

Assertions:
  - assert 'set-cookie' in rv.headers
  - assert expires.year == expected.year
  - assert expires.month == expected.month
  - assert expires.day == expected.day
  - assert rv.data == b'True'
  - assert 'set-cookie' in rv.headers
  - assert match is None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_expiration.json

================================================================================
Test: test_session_stored_last
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - repr (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session_stored_last
  - repr (:0)
    Called by: test_session_stored_last
  - client.get (:0)
    Called by: test_session_stored_last

Test Source Code:
  def test_session_stored_last(app, client):
      @app.after_request
      def modify_session(response):
          flask.session["foo"] = 42
          return response
  
      @app.route("/")
      def dump_session_contents():
          return repr(flask.session.get("foo"))
  
      assert client.get("/").data == b"None"
      assert client.get("/").data == b"42"

Assertions:
  - assert client.get('/').data == b'None'
  - assert client.get('/').data == b'42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_stored_last.json

================================================================================
Test: test_session_special_types
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - Markup (:0)
  - client.get (:0)
  - type (:0)
  - type (:0)
  - Markup (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session_special_types
  - Markup (:0)
    Called by: test_session_special_types
  - client.get (:0)
    Called by: test_session_special_types
  - type (:0)
    Called by: test_session_special_types

Test Source Code:
  def test_session_special_types(app, client):
      now = datetime.now(timezone.utc).replace(microsecond=0)
      the_uuid = uuid.uuid4()
  
      @app.route("/")
      def dump_session_contents():
          flask.session["t"] = (1, 2, 3)
          flask.session["b"] = b"\xff"
          flask.session["m"] = Markup("<html>")
          flask.session["u"] = the_uuid
          flask.session["d"] = now
          flask.session["t_tag"] = {" t": "not-a-tuple"}
          flask.session["di_t_tag"] = {" t__": "not-a-tuple"}
          flask.session["di_tag"] = {" di": "not-a-dict"}
          return "", 204
  
      with client:
          client.get("/")
          s = flask.session
          assert s["t"] == (1, 2, 3)
          assert type(s["b"]) is bytes  # noqa: E721
          assert s["b"] == b"\xff"
          assert type(s["m"]) is Markup  # noqa: E721
          assert s["m"] == Markup("<html>")
          assert s["u"] == the_uuid
          assert s["d"] == now
          assert s["t_tag"] == {" t": "not-a-tuple"}
          assert s["di_t_tag"] == {" t__": "not-a-tuple"}
          assert s["di_tag"] == {" di": "not-a-dict"}

Assertions:
  - assert s['t'] == (1, 2, 3)
  - assert type(s['b']) is bytes
  - assert s['b'] == b'\xff'
  - assert type(s['m']) is Markup
  - assert s['m'] == Markup('<html>')
  - assert s['u'] == the_uuid
  - assert s['d'] == now
  - assert s['t_tag'] == {' t': 'not-a-tuple'}
  - assert s['di_t_tag'] == {' t__': 'not-a-tuple'}
  - assert s['di_tag'] == {' di': 'not-a-dict'}

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_special_types.json

================================================================================
Test: test_session_cookie_setting
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.test_client (:0)
  - run_test (test_basic.py:485)
    Source code:
      def run_test(expect_header):
              with app.test_client() as c:
                  assert c.get("/bump").data == b"1"
                  assert c.get("/bump").data == b"2"
                  assert c.get("/bump").data == b"3"
      
                  rv = c.get("/read")
                  set_cookie = rv.headers.get("set-cookie")
                  assert (set_cookie is not None) == expect_header
                  assert rv.data == b"3"
  - run_test (test_basic.py:485)
    Source code:
      def run_test(expect_header):
              with app.test_client() as c:
                  assert c.get("/bump").data == b"1"
                  assert c.get("/bump").data == b"2"
                  assert c.get("/bump").data == b"3"
      
                  rv = c.get("/read")
                  set_cookie = rv.headers.get("set-cookie")
                  assert (set_cookie is not None) == expect_header
                  assert rv.data == b"3"
  - run_test (test_basic.py:485)
    Source code:
      def run_test(expect_header):
              with app.test_client() as c:
                  assert c.get("/bump").data == b"1"
                  assert c.get("/bump").data == b"2"
                  assert c.get("/bump").data == b"3"
      
                  rv = c.get("/read")
                  set_cookie = rv.headers.get("set-cookie")
                  assert (set_cookie is not None) == expect_header
                  assert rv.data == b"3"
  - run_test (test_basic.py:485)
    Source code:
      def run_test(expect_header):
              with app.test_client() as c:
                  assert c.get("/bump").data == b"1"
                  assert c.get("/bump").data == b"2"
                  assert c.get("/bump").data == b"3"
      
                  rv = c.get("/read")
                  set_cookie = rv.headers.get("set-cookie")
                  assert (set_cookie is not None) == expect_header
                  assert rv.data == b"3"
  - str (:0)
  - str (:0)
  - app.test_client (:0)
  - c.get (:0)
  - rv.headers.get (:0)
  - c.get (:0)
  - c.get (:0)
  - c.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session_cookie_setting
  - app.test_client (:0)
    Called by: test_session_cookie_setting
  - run_test (test_basic.py:485)
    Called by: test_session_cookie_setting
  - str (:0)
    Called by: test_session_cookie_setting
  - c.get (:0)
    Called by: test_session_cookie_setting
  - rv.headers.get (:0)
    Called by: test_session_cookie_setting

Test Source Code:
  def test_session_cookie_setting(app):
      is_permanent = True
  
      @app.route("/bump")
      def bump():
          rv = flask.session["foo"] = flask.session.get("foo", 0) + 1
          flask.session.permanent = is_permanent
          return str(rv)
  
      @app.route("/read")
      def read():
          return str(flask.session.get("foo", 0))
  
      def run_test(expect_header):
          with app.test_client() as c:
              assert c.get("/bump").data == b"1"
              assert c.get("/bump").data == b"2"
              assert c.get("/bump").data == b"3"
  
              rv = c.get("/read")
              set_cookie = rv.headers.get("set-cookie")
              assert (set_cookie is not None) == expect_header
              assert rv.data == b"3"
  
      is_permanent = True
      app.config["SESSION_REFRESH_EACH_REQUEST"] = True
      run_test(expect_header=True)
  
      is_permanent = True
      app.config["SESSION_REFRESH_EACH_REQUEST"] = False
      run_test(expect_header=False)
  
      is_permanent = False
      app.config["SESSION_REFRESH_EACH_REQUEST"] = True
      run_test(expect_header=False)
  
      is_permanent = False
      app.config["SESSION_REFRESH_EACH_REQUEST"] = False
      run_test(expect_header=False)

Assertions:
  - assert c.get('/bump').data == b'1'
  - assert c.get('/bump').data == b'2'
  - assert c.get('/bump').data == b'3'
  - assert (set_cookie is not None) == expect_header
  - assert rv.data == b'3'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_cookie_setting.json

================================================================================
Test: test_session_vary_cookie
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - expect (test_basic.py:554)
    Source code:
      def expect(path, header_value="Cookie"):
              rv = client.get(path)
      
              if header_value:
                  # The 'Vary' key should exist in the headers only once.
                  assert len(rv.headers.get_all("Vary")) == 1
                  assert rv.headers["Vary"] == header_value
              else:
                  assert "Vary" not in rv.headers
  - response.vary.add (:0)
  - response.vary.update (:0)
  - client.get (:0)
  - len (:0)
  - rv.headers.get_all (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_session_vary_cookie
  - expect (test_basic.py:554)
    Called by: test_session_vary_cookie
  - response.vary.add (:0)
    Called by: test_session_vary_cookie
  - response.vary.update (:0)
    Called by: test_session_vary_cookie
  - client.get (:0)
    Called by: test_session_vary_cookie
  - len (:0)
    Called by: test_session_vary_cookie
  - rv.headers.get_all (:0)
    Called by: test_session_vary_cookie

Test Source Code:
  def test_session_vary_cookie(app, client):
      @app.route("/set")
      def set_session():
          flask.session["test"] = "test"
          return ""
  
      @app.route("/get")
      def get():
          return flask.session.get("test")
  
      @app.route("/getitem")
      def getitem():
          return flask.session["test"]
  
      @app.route("/setdefault")
      def setdefault():
          return flask.session.setdefault("test", "default")
  
      @app.route("/clear")
      def clear():
          flask.session.clear()
          return ""
  
      @app.route("/vary-cookie-header-set")
      def vary_cookie_header_set():
          response = flask.Response()
          response.vary.add("Cookie")
          flask.session["test"] = "test"
          return response
  
      @app.route("/vary-header-set")
      def vary_header_set():
          response = flask.Response()
          response.vary.update(("Accept-Encoding", "Accept-Language"))
          flask.session["test"] = "test"
          return response
  
      @app.route("/no-vary-header")
      def no_vary_header():
          return ""
  
      def expect(path, header_value="Cookie"):
          rv = client.get(path)
  
          if header_value:
              # The 'Vary' key should exist in the headers only once.
              assert len(rv.headers.get_all("Vary")) == 1
              assert rv.headers["Vary"] == header_value
          else:
              assert "Vary" not in rv.headers
  
      expect("/set")
      expect("/get")
      expect("/getitem")
      expect("/setdefault")
      expect("/clear")
      expect("/vary-cookie-header-set")
      expect("/vary-header-set", "Accept-Encoding, Accept-Language, Cookie")
      expect("/no-vary-header", None)

Assertions:
  - assert len(rv.headers.get_all('Vary')) == 1
  - assert rv.headers['Vary'] == header_value
  - assert 'Vary' not in rv.headers

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_vary_cookie.json

================================================================================
Test: test_session_refresh_vary
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.get (:0)
  - app.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.get (:0)
    Called by: test_session_refresh_vary
  - client.get (:0)
    Called by: test_session_refresh_vary

Test Source Code:
  def test_session_refresh_vary(app, client):
      @app.get("/login")
      def login():
          flask.session["user_id"] = 1
          flask.session.permanent = True
          return ""
  
      @app.get("/ignored")
      def ignored():
          return ""
  
      rv = client.get("/login")
      assert rv.headers["Vary"] == "Cookie"
      rv = client.get("/ignored")
      assert rv.headers["Vary"] == "Cookie"

Assertions:
  - assert rv.headers['Vary'] == 'Cookie'
  - assert rv.headers['Vary'] == 'Cookie'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_refresh_vary.json

================================================================================
Test: test_flashes
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - list (:0)

Methods Actually Called (Dynamic Analysis):
  - list (:0)
    Called by: test_flashes

Test Source Code:
  def test_flashes(app, req_ctx):
      assert not flask.session.modified
      flask.flash("Zap")
      flask.session.modified = False
      flask.flash("Zip")
      assert flask.session.modified
      assert list(flask.get_flashed_messages()) == ["Zap", "Zip"]

Assertions:
  - assert not flask.session.modified
  - assert flask.session.modified
  - assert list(flask.get_flashed_messages()) == ['Zap', 'Zip']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_flashes.json

================================================================================
Test: test_extended_flashing
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_client (:0)
  - client.get (:0)
  - client.get (:0)
  - app.test_client (:0)
  - client.get (:0)
  - client.get (:0)
  - app.test_client (:0)
  - client.get (:0)
  - client.get (:0)
  - app.test_client (:0)
  - client.get (:0)
  - client.get (:0)
  - Markup (:0)
  - list (:0)
  - len (:0)
  - list (:0)
  - list (:0)
  - list (:0)
  - len (:0)
  - Markup (:0)
  - Markup (:0)
  - Markup (:0)
  - Markup (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_extended_flashing
  - app.test_client (:0)
    Called by: test_extended_flashing
  - client.get (:0)
    Called by: test_extended_flashing
  - Markup (:0)
    Called by: test_extended_flashing
  - list (:0)
    Called by: test_extended_flashing
  - len (:0)
    Called by: test_extended_flashing

Test Source Code:
  def test_extended_flashing(app):
      # Be sure app.testing=True below, else tests can fail silently.
      #
      # Specifically, if app.testing is not set to True, the AssertionErrors
      # in the view functions will cause a 500 response to the test client
      # instead of propagating exceptions.
  
      @app.route("/")
      def index():
          flask.flash("Hello World")
          flask.flash("Hello World", "error")
          flask.flash(Markup("<em>Testing</em>"), "warning")
          return ""
  
      @app.route("/test/")
      def test():
          messages = flask.get_flashed_messages()
          assert list(messages) == [
              "Hello World",
              "Hello World",
              Markup("<em>Testing</em>"),
          ]
          return ""
  
      @app.route("/test_with_categories/")
      def test_with_categories():
          messages = flask.get_flashed_messages(with_categories=True)
          assert len(messages) == 3
          assert list(messages) == [
              ("message", "Hello World"),
              ("error", "Hello World"),
              ("warning", Markup("<em>Testing</em>")),
          ]
          return ""
  
      @app.route("/test_filter/")
      def test_filter():
          messages = flask.get_flashed_messages(
              category_filter=["message"], with_categories=True
          )
          assert list(messages) == [("message", "Hello World")]
          return ""
  
      @app.route("/test_filters/")
      def test_filters():
          messages = flask.get_flashed_messages(
              category_filter=["message", "warning"], with_categories=True
          )
          assert list(messages) == [
              ("message", "Hello World"),
              ("warning", Markup("<em>Testing</em>")),
          ]
          return ""
  
      @app.route("/test_filters_without_returning_categories/")
      def test_filters2():
          messages = flask.get_flashed_messages(category_filter=["message", "warning"])
          assert len(messages) == 2
          assert messages[0] == "Hello World"
          assert messages[1] == Markup("<em>Testing</em>")
          return ""
  
      # Create new test client on each test to clean flashed messages.
  
      client = app.test_client()
      client.get("/")
      client.get("/test_with_categories/")
  
      client = app.test_client()
      client.get("/")
      client.get("/test_filter/")
  
      client = app.test_client()
      client.get("/")
      client.get("/test_filters/")
  
      client = app.test_client()
      client.get("/")
      client.get("/test_filters_without_returning_categories/")

Assertions:
  - assert list(messages) == ['Hello World', 'Hello World', Markup('<em>Testing</em>')]
  - assert len(messages) == 3
  - assert list(messages) == [('message', 'Hello World'), ('error', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]
  - assert list(messages) == [('message', 'Hello World')]
  - assert list(messages) == [('message', 'Hello World'), ('warning', Markup('<em>Testing</em>'))]
  - assert len(messages) == 2
  - assert messages[0] == 'Hello World'
  - assert messages[1] == Markup('<em>Testing</em>')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_extended_flashing.json

================================================================================
Test: test_request_processing
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - evts.append (:0)
  - evts.append (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_request_processing
  - evts.append (:0)
    Called by: test_request_processing
  - client.get (:0)
    Called by: test_request_processing

Test Source Code:
  def test_request_processing(app, client):
      evts = []
  
      @app.before_request
      def before_request():
          evts.append("before")
  
      @app.after_request
      def after_request(response):
          response.data += b"|after"
          evts.append("after")
          return response
  
      @app.route("/")
      def index():
          assert "before" in evts
          assert "after" not in evts
          return "request"
  
      assert "after" not in evts
      rv = client.get("/").data
      assert "after" in evts
      assert rv == b"request|after"

Assertions:
  - assert 'after' not in evts
  - assert 'after' in evts
  - assert rv == b'request|after'
  - assert 'before' in evts
  - assert 'after' not in evts

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_processing.json

================================================================================
Test: test_request_preprocessing_early_return
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get.data.strip (:0)
  - evts.append (:0)
  - evts.append (:0)
  - evts.append (:0)
  - evts.append (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_request_preprocessing_early_return
  - client.get.data.strip (:0)
    Called by: test_request_preprocessing_early_return
  - evts.append (:0)
    Called by: test_request_preprocessing_early_return
  - client.get (:0)
    Called by: test_request_preprocessing_early_return

Test Source Code:
  def test_request_preprocessing_early_return(app, client):
      evts = []
  
      @app.before_request
      def before_request1():
          evts.append(1)
  
      @app.before_request
      def before_request2():
          evts.append(2)
          return "hello"
  
      @app.before_request
      def before_request3():
          evts.append(3)
          return "bye"
  
      @app.route("/")
      def index():
          evts.append("index")
          return "damnit"
  
      rv = client.get("/").data.strip()
      assert rv == b"hello"
      assert evts == [1, 2]

Assertions:
  - assert rv == b'hello'
  - assert evts == [1, 2]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_preprocessing_early_return.json

================================================================================
Test: test_after_request_processing
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_after_request_processing
  - client.get (:0)
    Called by: test_after_request_processing

Test Source Code:
  def test_after_request_processing(app, client):
      @app.route("/")
      def index():
          @flask.after_this_request
          def foo(response):
              response.headers["X-Foo"] = "a header"
              return response
  
          return "Test"
  
      resp = client.get("/")
      assert resp.status_code == 200
      assert resp.headers["X-Foo"] == "a header"

Assertions:
  - assert resp.status_code == 200
  - assert resp.headers['X-Foo'] == 'a header'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_after_request_processing.json

================================================================================
Test: test_teardown_request_handler
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - called.append (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_teardown_request_handler
  - client.get (:0)
    Called by: test_teardown_request_handler
  - called.append (:0)
    Called by: test_teardown_request_handler
  - len (:0)
    Called by: test_teardown_request_handler

Test Source Code:
  def test_teardown_request_handler(app, client):
      called = []
  
      @app.teardown_request
      def teardown_request(exc):
          called.append(True)
          return "Ignored"
  
      @app.route("/")
      def root():
          return "Response"
  
      rv = client.get("/")
      assert rv.status_code == 200
      assert b"Response" in rv.data
      assert len(called) == 1

Assertions:
  - assert rv.status_code == 200
  - assert b'Response' in rv.data
  - assert len(called) == 1

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_teardown_request_handler.json

================================================================================
Test: test_teardown_request_handler_debug_mode
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - called.append (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_teardown_request_handler_debug_mode
  - client.get (:0)
    Called by: test_teardown_request_handler_debug_mode
  - called.append (:0)
    Called by: test_teardown_request_handler_debug_mode
  - len (:0)
    Called by: test_teardown_request_handler_debug_mode

Test Source Code:
  def test_teardown_request_handler_debug_mode(app, client):
      called = []
  
      @app.teardown_request
      def teardown_request(exc):
          called.append(True)
          return "Ignored"
  
      @app.route("/")
      def root():
          return "Response"
  
      rv = client.get("/")
      assert rv.status_code == 200
      assert b"Response" in rv.data
      assert len(called) == 1

Assertions:
  - assert rv.status_code == 200
  - assert b'Response' in rv.data
  - assert len(called) == 1

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_teardown_request_handler_debug_mode.json

================================================================================
Test: test_teardown_request_handler_error
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - called.append (:0)
  - called.append (:0)
  - len (:0)
  - type (:0)
  - TypeError (:0)
  - type (:0)
  - TypeError (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_teardown_request_handler_error
  - client.get (:0)
    Called by: test_teardown_request_handler_error
  - called.append (:0)
    Called by: test_teardown_request_handler_error
  - len (:0)
    Called by: test_teardown_request_handler_error
  - type (:0)
    Called by: test_teardown_request_handler_error
  - TypeError (:0)
    Called by: test_teardown_request_handler_error

Test Source Code:
  def test_teardown_request_handler_error(app, client):
      called = []
      app.testing = False
  
      @app.teardown_request
      def teardown_request1(exc):
          assert type(exc) is ZeroDivisionError
          called.append(True)
          # This raises a new error and blows away sys.exc_info(), so we can
          # test that all teardown_requests get passed the same original
          # exception.
          try:
              raise TypeError()
          except Exception:
              pass
  
      @app.teardown_request
      def teardown_request2(exc):
          assert type(exc) is ZeroDivisionError
          called.append(True)
          # This raises a new error and blows away sys.exc_info(), so we can
          # test that all teardown_requests get passed the same original
          # exception.
          try:
              raise TypeError()
          except Exception:
              pass
  
      @app.route("/")
      def fails():
          raise ZeroDivisionError
  
      rv = client.get("/")
      assert rv.status_code == 500
      assert b"Internal Server Error" in rv.data
      assert len(called) == 2

Assertions:
  - assert rv.status_code == 500
  - assert b'Internal Server Error' in rv.data
  - assert len(called) == 2
  - assert type(exc) is ZeroDivisionError
  - assert type(exc) is ZeroDivisionError

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_teardown_request_handler_error.json

================================================================================
Test: test_before_after_request_order
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - called.append (:0)
  - called.append (:0)
  - called.append (:0)
  - called.append (:0)
  - called.append (:0)
  - called.append (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_before_after_request_order
  - client.get (:0)
    Called by: test_before_after_request_order
  - called.append (:0)
    Called by: test_before_after_request_order

Test Source Code:
  def test_before_after_request_order(app, client):
      called = []
  
      @app.before_request
      def before1():
          called.append(1)
  
      @app.before_request
      def before2():
          called.append(2)
  
      @app.after_request
      def after1(response):
          called.append(4)
          return response
  
      @app.after_request
      def after2(response):
          called.append(3)
          return response
  
      @app.teardown_request
      def finish1(exc):
          called.append(6)
  
      @app.teardown_request
      def finish2(exc):
          called.append(5)
  
      @app.route("/")
      def index():
          return "42"
  
      rv = client.get("/")
      assert rv.data == b"42"
      assert called == [1, 2, 3, 4, 5, 6]

Assertions:
  - assert rv.data == b'42'
  - assert called == [1, 2, 3, 4, 5, 6]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_before_after_request_order.json

================================================================================
Test: test_error_handling
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_error_handling
  - app.route (:0)
    Called by: test_error_handling
  - client.get (:0)
    Called by: test_error_handling

Test Source Code:
  def test_error_handling(app, client):
      app.testing = False
  
      @app.errorhandler(404)
      def not_found(e):
          return "not found", 404
  
      @app.errorhandler(500)
      def internal_server_error(e):
          return "internal server error", 500
  
      @app.errorhandler(Forbidden)
      def forbidden(e):
          return "forbidden", 403
  
      @app.route("/")
      def index():
          flask.abort(404)
  
      @app.route("/error")
      def error():
          raise ZeroDivisionError
  
      @app.route("/forbidden")
      def error2():
          flask.abort(403)
  
      rv = client.get("/")
      assert rv.status_code == 404
      assert rv.data == b"not found"
      rv = client.get("/error")
      assert rv.status_code == 500
      assert b"internal server error" == rv.data
      rv = client.get("/forbidden")
      assert rv.status_code == 403
      assert b"forbidden" == rv.data

Assertions:
  - assert rv.status_code == 404
  - assert rv.data == b'not found'
  - assert rv.status_code == 500
  - assert b'internal server error' == rv.data
  - assert rv.status_code == 403
  - assert b'forbidden' == rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_error_handling.json

================================================================================
Test: test_error_handling_processing
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_error_handling_processing
  - app.route (:0)
    Called by: test_error_handling_processing
  - client.get (:0)
    Called by: test_error_handling_processing

Test Source Code:
  def test_error_handling_processing(app, client):
      app.testing = False
  
      @app.errorhandler(500)
      def internal_server_error(e):
          return "internal server error", 500
  
      @app.route("/")
      def broken_func():
          raise ZeroDivisionError
  
      @app.after_request
      def after_request(resp):
          resp.mimetype = "text/x-special"
          return resp
  
      resp = client.get("/")
      assert resp.mimetype == "text/x-special"
      assert resp.data == b"internal server error"

Assertions:
  - assert resp.mimetype == 'text/x-special'
  - assert resp.data == b'internal server error'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_error_handling_processing.json

================================================================================
Test: test_baseexception_error_handling
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - KeyboardInterrupt (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_baseexception_error_handling
  - KeyboardInterrupt (:0)
    Called by: test_baseexception_error_handling
  - client.get (:0)
    Called by: test_baseexception_error_handling

Test Source Code:
  def test_baseexception_error_handling(app, client):
      app.testing = False
  
      @app.route("/")
      def broken_func():
          raise KeyboardInterrupt()
  
      with pytest.raises(KeyboardInterrupt):
          client.get("/")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_baseexception_error_handling.json

================================================================================
Test: test_before_request_and_routing_errors
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_before_request_and_routing_errors
  - client.get (:0)
    Called by: test_before_request_and_routing_errors

Test Source Code:
  def test_before_request_and_routing_errors(app, client):
      @app.before_request
      def attach_something():
          flask.g.something = "value"
  
      @app.errorhandler(404)
      def return_something(error):
          return flask.g.something, 404
  
      rv = client.get("/")
      assert rv.status_code == 404
      assert rv.data == b"value"

Assertions:
  - assert rv.status_code == 404
  - assert rv.data == b'value'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_before_request_and_routing_errors.json

================================================================================
Test: test_user_error_handling
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.route (:0)
  - isinstance (:0)
  - MyException (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_user_error_handling
  - app.route (:0)
    Called by: test_user_error_handling
  - isinstance (:0)
    Called by: test_user_error_handling
  - MyException (:0)
    Called by: test_user_error_handling
  - client.get (:0)
    Called by: test_user_error_handling

Test Source Code:
  def test_user_error_handling(app, client):
      class MyException(Exception):
          pass
  
      @app.errorhandler(MyException)
      def handle_my_exception(e):
          assert isinstance(e, MyException)
          return "42"
  
      @app.route("/")
      def index():
          raise MyException()
  
      assert client.get("/").data == b"42"

Assertions:
  - assert client.get('/').data == b'42'
  - assert isinstance(e, MyException)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_user_error_handling.json

================================================================================
Test: test_http_error_subclass_handling
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - isinstance (:0)
  - isinstance (:0)
  - ForbiddenSubclass (:0)
  - Forbidden (:0)
  - isinstance (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_http_error_subclass_handling
  - app.route (:0)
    Called by: test_http_error_subclass_handling
  - isinstance (:0)
    Called by: test_http_error_subclass_handling
  - ForbiddenSubclass (:0)
    Called by: test_http_error_subclass_handling
  - Forbidden (:0)
    Called by: test_http_error_subclass_handling
  - client.get (:0)
    Called by: test_http_error_subclass_handling

Test Source Code:
  def test_http_error_subclass_handling(app, client):
      class ForbiddenSubclass(Forbidden):
          pass
  
      @app.errorhandler(ForbiddenSubclass)
      def handle_forbidden_subclass(e):
          assert isinstance(e, ForbiddenSubclass)
          return "banana"
  
      @app.errorhandler(403)
      def handle_403(e):
          assert not isinstance(e, ForbiddenSubclass)
          assert isinstance(e, Forbidden)
          return "apple"
  
      @app.route("/1")
      def index1():
          raise ForbiddenSubclass()
  
      @app.route("/2")
      def index2():
          flask.abort(403)
  
      @app.route("/3")
      def index3():
          raise Forbidden()
  
      assert client.get("/1").data == b"banana"
      assert client.get("/2").data == b"apple"
      assert client.get("/3").data == b"apple"

Assertions:
  - assert client.get('/1').data == b'banana'
  - assert client.get('/2').data == b'apple'
  - assert client.get('/3').data == b'apple'
  - assert isinstance(e, ForbiddenSubclass)
  - assert not isinstance(e, ForbiddenSubclass)
  - assert isinstance(e, Forbidden)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_http_error_subclass_handling.json

================================================================================
Test: test_errorhandler_precedence
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_errorhandler_precedence
  - app.route (:0)
    Called by: test_errorhandler_precedence
  - client.get (:0)
    Called by: test_errorhandler_precedence

Test Source Code:
  def test_errorhandler_precedence(app, client):
      class E1(Exception):
          pass
  
      class E2(Exception):
          pass
  
      class E3(E1, E2):
          pass
  
      @app.errorhandler(E2)
      def handle_e2(e):
          return "E2"
  
      @app.errorhandler(Exception)
      def handle_exception(e):
          return "Exception"
  
      @app.route("/E1")
      def raise_e1():
          raise E1
  
      @app.route("/E3")
      def raise_e3():
          raise E3
  
      rv = client.get("/E1")
      assert rv.data == b"Exception"
  
      rv = client.get("/E3")
      assert rv.data == b"E2"

Assertions:
  - assert rv.data == b'Exception'
  - assert rv.data == b'E2'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_errorhandler_precedence.json

================================================================================
Test: test_trap_bad_request_key_error
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - exc_info.errisinstance (:0)
  - client.get (:0)
  - client.get (:0)
  - exc_info.value.get_description (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_trap_bad_request_key_error
  - client.get (:0)
    Called by: test_trap_bad_request_key_error
  - exc_info.errisinstance (:0)
    Called by: test_trap_bad_request_key_error
  - exc_info.value.get_description (:0)
    Called by: test_trap_bad_request_key_error

Test Source Code:
  def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):
      app.config["DEBUG"] = debug
      app.config["TRAP_BAD_REQUEST_ERRORS"] = trap
  
      @app.route("/key")
      def fail():
          flask.request.form["missing_key"]
  
      @app.route("/abort")
      def allow_abort():
          flask.abort(400)
  
      if expect_key:
          rv = client.get("/key")
          assert rv.status_code == 400
          assert b"missing_key" not in rv.data
      else:
          with pytest.raises(KeyError) as exc_info:
              client.get("/key")
  
          assert exc_info.errisinstance(BadRequest)
          assert "missing_key" in exc_info.value.get_description()
  
      if expect_abort:
          rv = client.get("/abort")
          assert rv.status_code == 400
      else:
          with pytest.raises(BadRequest):
              client.get("/abort")

Assertions:
  - assert rv.status_code == 400
  - assert b'missing_key' not in rv.data
  - assert exc_info.errisinstance(BadRequest)
  - assert 'missing_key' in exc_info.value.get_description()
  - assert rv.status_code == 400

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_trap_bad_request_key_error.json

================================================================================
Test: test_trapping_of_all_http_exceptions
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_trapping_of_all_http_exceptions
  - client.get (:0)
    Called by: test_trapping_of_all_http_exceptions

Test Source Code:
  def test_trapping_of_all_http_exceptions(app, client):
      app.config["TRAP_HTTP_EXCEPTIONS"] = True
  
      @app.route("/fail")
      def fail():
          flask.abort(404)
  
      with pytest.raises(NotFound):
          client.get("/fail")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_trapping_of_all_http_exceptions.json

================================================================================
Test: test_error_handler_after_processor_error
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.errorhandler (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_error_handler_after_processor_error
  - app.errorhandler (:0)
    Called by: test_error_handler_after_processor_error
  - client.get (:0)
    Called by: test_error_handler_after_processor_error

Test Source Code:
  def test_error_handler_after_processor_error(app, client):
      app.testing = False
  
      @app.before_request
      def before_request():
          if _trigger == "before":
              raise ZeroDivisionError
  
      @app.after_request
      def after_request(response):
          if _trigger == "after":
              raise ZeroDivisionError
  
          return response
  
      @app.route("/")
      def index():
          return "Foo"
  
      @app.errorhandler(500)
      def internal_server_error(e):
          return "Hello Server Error", 500
  
      for _trigger in "before", "after":
          rv = client.get("/")
          assert rv.status_code == 500
          assert rv.data == b"Hello Server Error"

Assertions:
  - assert rv.status_code == 500
  - assert rv.data == b'Hello Server Error'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_error_handler_after_processor_error.json

================================================================================
Test: test_enctype_debug_helper
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.post (:0)
  - str (:0)
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_enctype_debug_helper
  - client.post (:0)
    Called by: test_enctype_debug_helper
  - str (:0)
    Called by: test_enctype_debug_helper

Test Source Code:
  def test_enctype_debug_helper(app, client):
      from flask.debughelpers import DebugFilesKeyError
  
      app.debug = True
  
      @app.route("/fail", methods=["POST"])
      def index():
          return flask.request.files["foo"].filename
  
      with pytest.raises(DebugFilesKeyError) as e:
          client.post("/fail", data={"foo": "index.txt"})
      assert "no file contents were transmitted" in str(e.value)
      assert "This was submitted: 'index.txt'" in str(e.value)

Assertions:
  - assert 'no file contents were transmitted' in str(e.value)
  - assert "This was submitted: 'index.txt'" in str(e.value)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_enctype_debug_helper.json

================================================================================
Test: test_response_types
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - encode (:0)
  - NotFound (:0)
  - encode (:0)
  - encode (:0)
  - rv.headers.getlist (:0)
  - app.response_class (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_response_types
  - client.get (:0)
    Called by: test_response_types
  - encode (:0)
    Called by: test_response_types
  - NotFound (:0)
    Called by: test_response_types
  - rv.headers.getlist (:0)
    Called by: test_response_types
  - app.response_class (:0)
    Called by: test_response_types

Test Source Code:
  def test_response_types(app, client):
      @app.route("/text")
      def from_text():
          return "Hällo Wörld"
  
      @app.route("/bytes")
      def from_bytes():
          return "Hällo Wörld".encode()
  
      @app.route("/full_tuple")
      def from_full_tuple():
          return (
              "Meh",
              400,
              {"X-Foo": "Testing", "Content-Type": "text/plain; charset=utf-8"},
          )
  
      @app.route("/text_headers")
      def from_text_headers():
          return "Hello", {"X-Foo": "Test", "Content-Type": "text/plain; charset=utf-8"}
  
      @app.route("/text_status")
      def from_text_status():
          return "Hi, status!", 400
  
      @app.route("/response_headers")
      def from_response_headers():
          return (
              flask.Response(
                  "Hello world", 404, {"Content-Type": "text/html", "X-Foo": "Baz"}
              ),
              {"Content-Type": "text/plain", "X-Foo": "Bar", "X-Bar": "Foo"},
          )
  
      @app.route("/response_status")
      def from_response_status():
          return app.response_class("Hello world", 400), 500
  
      @app.route("/wsgi")
      def from_wsgi():
          return NotFound()
  
      @app.route("/dict")
      def from_dict():
          return {"foo": "bar"}, 201
  
      @app.route("/list")
      def from_list():
          return ["foo", "bar"], 201
  
      assert client.get("/text").data == "Hällo Wörld".encode()
      assert client.get("/bytes").data == "Hällo Wörld".encode()
  
      rv = client.get("/full_tuple")
      assert rv.data == b"Meh"
      assert rv.headers["X-Foo"] == "Testing"
      assert rv.status_code == 400
      assert rv.mimetype == "text/plain"
  
      rv = client.get("/text_headers")
      assert rv.data == b"Hello"
      assert rv.headers["X-Foo"] == "Test"
      assert rv.status_code == 200
      assert rv.mimetype == "text/plain"
  
      rv = client.get("/text_status")
      assert rv.data == b"Hi, status!"
      assert rv.status_code == 400
      assert rv.mimetype == "text/html"
  
      rv = client.get("/response_headers")
      assert rv.data == b"Hello world"
      assert rv.content_type == "text/plain"
      assert rv.headers.getlist("X-Foo") == ["Bar"]
      assert rv.headers["X-Bar"] == "Foo"
      assert rv.status_code == 404
  
      rv = client.get("/response_status")
      assert rv.data == b"Hello world"
      assert rv.status_code == 500
  
      rv = client.get("/wsgi")
      assert b"Not Found" in rv.data
      assert rv.status_code == 404
  
      rv = client.get("/dict")
      assert rv.json == {"foo": "bar"}
      assert rv.status_code == 201
  
      rv = client.get("/list")
      assert rv.json == ["foo", "bar"]
      assert rv.status_code == 201

Assertions:
  - assert client.get('/text').data == 'Hällo Wörld'.encode()
  - assert client.get('/bytes').data == 'Hällo Wörld'.encode()
  - assert rv.data == b'Meh'
  - assert rv.headers['X-Foo'] == 'Testing'
  - assert rv.status_code == 400
  - assert rv.mimetype == 'text/plain'
  - assert rv.data == b'Hello'
  - assert rv.headers['X-Foo'] == 'Test'
  - assert rv.status_code == 200
  - assert rv.mimetype == 'text/plain'
  - assert rv.data == b'Hi, status!'
  - assert rv.status_code == 400
  - assert rv.mimetype == 'text/html'
  - assert rv.data == b'Hello world'
  - assert rv.content_type == 'text/plain'
  - assert rv.headers.getlist('X-Foo') == ['Bar']
  - assert rv.headers['X-Bar'] == 'Foo'
  - assert rv.status_code == 404
  - assert rv.data == b'Hello world'
  - assert rv.status_code == 500
  - assert b'Not Found' in rv.data
  - assert rv.status_code == 404
  - assert rv.json == {'foo': 'bar'}
  - assert rv.status_code == 201
  - assert rv.json == ['foo', 'bar']
  - assert rv.status_code == 201

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_response_types.json

================================================================================
Test: test_response_type_errors
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_client (:0)
  - c.get (:0)
  - str (:0)
  - str (:0)
  - c.get (:0)
  - str (:0)
  - c.get (:0)
  - c.get (:0)
  - str (:0)
  - c.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_response_type_errors
  - app.test_client (:0)
    Called by: test_response_type_errors
  - c.get (:0)
    Called by: test_response_type_errors
  - str (:0)
    Called by: test_response_type_errors

Test Source Code:
  def test_response_type_errors():
      app = flask.Flask(__name__)
      app.testing = True
  
      @app.route("/none")
      def from_none():
          pass
  
      @app.route("/small_tuple")
      def from_small_tuple():
          return ("Hello",)
  
      @app.route("/large_tuple")
      def from_large_tuple():
          return "Hello", 234, {"X-Foo": "Bar"}, "???"
  
      @app.route("/bad_type")
      def from_bad_type():
          return True
  
      @app.route("/bad_wsgi")
      def from_bad_wsgi():
          return lambda: None
  
      c = app.test_client()
  
      with pytest.raises(TypeError) as e:
          c.get("/none")
  
      assert "returned None" in str(e.value)
      assert "from_none" in str(e.value)
  
      with pytest.raises(TypeError) as e:
          c.get("/small_tuple")
  
      assert "tuple must have the form" in str(e.value)
  
      with pytest.raises(TypeError):
          c.get("/large_tuple")
  
      with pytest.raises(TypeError) as e:
          c.get("/bad_type")
  
      assert "it was a bool" in str(e.value)
  
      with pytest.raises(TypeError):
          c.get("/bad_wsgi")

Assertions:
  - assert 'returned None' in str(e.value)
  - assert 'from_none' in str(e.value)
  - assert 'tuple must have the form' in str(e.value)
  - assert 'it was a bool' in str(e.value)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_response_type_errors.json

================================================================================
Test: test_make_response
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_make_response(app, req_ctx):
      rv = flask.make_response()
      assert rv.status_code == 200
      assert rv.data == b""
      assert rv.mimetype == "text/html"
  
      rv = flask.make_response("Awesome")
      assert rv.status_code == 200
      assert rv.data == b"Awesome"
      assert rv.mimetype == "text/html"
  
      rv = flask.make_response("W00t", 404)
      assert rv.status_code == 404
      assert rv.data == b"W00t"
      assert rv.mimetype == "text/html"
  
      rv = flask.make_response(c for c in "Hello")
      assert rv.status_code == 200
      assert rv.data == b"Hello"
      assert rv.mimetype == "text/html"

Assertions:
  - assert rv.status_code == 200
  - assert rv.data == b''
  - assert rv.mimetype == 'text/html'
  - assert rv.status_code == 200
  - assert rv.data == b'Awesome'
  - assert rv.mimetype == 'text/html'
  - assert rv.status_code == 404
  - assert rv.data == b'W00t'
  - assert rv.mimetype == 'text/html'
  - assert rv.status_code == 200
  - assert rv.data == b'Hello'
  - assert rv.mimetype == 'text/html'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_make_response.json

================================================================================
Test: test_make_response_with_response_instance
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_make_response_with_response_instance(app, req_ctx):
      rv = flask.make_response(flask.jsonify({"msg": "W00t"}), 400)
      assert rv.status_code == 400
      assert rv.data == b'{"msg":"W00t"}\n'
      assert rv.mimetype == "application/json"
  
      rv = flask.make_response(flask.Response(""), 400)
      assert rv.status_code == 400
      assert rv.data == b""
      assert rv.mimetype == "text/html"
  
      rv = flask.make_response(
          flask.Response("", headers={"Content-Type": "text/html"}),
          400,
          [("X-Foo", "bar")],
      )
      assert rv.status_code == 400
      assert rv.headers["Content-Type"] == "text/html"
      assert rv.headers["X-Foo"] == "bar"

Assertions:
  - assert rv.status_code == 400
  - assert rv.data == b'{"msg":"W00t"}\n'
  - assert rv.mimetype == 'application/json'
  - assert rv.status_code == 400
  - assert rv.data == b''
  - assert rv.mimetype == 'text/html'
  - assert rv.status_code == 400
  - assert rv.headers['Content-Type'] == 'text/html'
  - assert rv.headers['X-Foo'] == 'bar'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_make_response_with_response_instance.json

================================================================================
Test: test_jsonify_no_prettyprint
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.json.response (:0)
  - rv.data.strip (:0)

Methods Actually Called (Dynamic Analysis):
  - app.json.response (:0)
    Called by: test_jsonify_no_prettyprint
  - rv.data.strip (:0)
    Called by: test_jsonify_no_prettyprint

Test Source Code:
  def test_jsonify_no_prettyprint(app, compact):
      app.json.compact = compact
      rv = app.json.response({"msg": {"submsg": "W00t"}, "msg2": "foobar"})
      data = rv.data.strip()
      assert (b" " not in data) is compact
      assert (b"\n" not in data) is compact

Assertions:
  - assert (b' ' not in data) is compact
  - assert (b'\n' not in data) is compact

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_no_prettyprint.json

================================================================================
Test: test_jsonify_mimetype
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_jsonify_mimetype(app, req_ctx):
      app.json.mimetype = "application/vnd.api+json"
      msg = {"msg": {"submsg": "W00t"}}
      rv = flask.make_response(flask.jsonify(msg), 200)
      assert rv.mimetype == "application/vnd.api+json"

Assertions:
  - assert rv.mimetype == 'application/vnd.api+json'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_mimetype.json

================================================================================
Test: test_json_dump_dataclass
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - make_dataclass (:0)
  - app.json.dumps (:0)
  - app.json.loads (:0)
  - Data (:0)

Methods Actually Called (Dynamic Analysis):
  - make_dataclass (:0)
    Called by: test_json_dump_dataclass
  - app.json.dumps (:0)
    Called by: test_json_dump_dataclass
  - app.json.loads (:0)
    Called by: test_json_dump_dataclass
  - Data (:0)
    Called by: test_json_dump_dataclass

Test Source Code:
  def test_json_dump_dataclass(app, req_ctx):
      from dataclasses import make_dataclass
  
      Data = make_dataclass("Data", [("name", str)])
      value = app.json.dumps(Data("Flask"))
      value = app.json.loads(value)
      assert value == {"name": "Flask"}

Assertions:
  - assert value == {'name': 'Flask'}

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_dump_dataclass.json

================================================================================
Test: test_jsonify_args_and_kwargs_check
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - str (:0)
    Called by: test_jsonify_args_and_kwargs_check

Test Source Code:
  def test_jsonify_args_and_kwargs_check(app, req_ctx):
      with pytest.raises(TypeError) as e:
          flask.jsonify("fake args", kwargs="fake")
      assert "args or kwargs" in str(e.value)

Assertions:
  - assert 'args or kwargs' in str(e.value)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_args_and_kwargs_check.json

================================================================================
Test: test_url_generation
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_url_generation

Test Source Code:
  def test_url_generation(app, req_ctx):
      @app.route("/hello/<name>", methods=["POST"])
      def hello():
          pass
  
      assert flask.url_for("hello", name="test x") == "/hello/test%20x"
      assert (
          flask.url_for("hello", name="test x", _external=True)
          == "http://localhost/hello/test%20x"
      )

Assertions:
  - assert flask.url_for('hello', name='test x') == '/hello/test%20x'
  - assert flask.url_for('hello', name='test x', _external=True) == 'http://localhost/hello/test%20x'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_generation.json

================================================================================
Test: test_build_error_handler
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.url_build_error_handlers.append (:0)
  - app.test_request_context (:0)
  - RuntimeError (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_build_error_handler
  - app.url_build_error_handlers.append (:0)
    Called by: test_build_error_handler
  - RuntimeError (:0)
    Called by: test_build_error_handler

Test Source Code:
  def test_build_error_handler(app):
      # Test base case, a URL which results in a BuildError.
      with app.test_request_context():
          pytest.raises(BuildError, flask.url_for, "spam")
  
      # Verify the error is re-raised if not the current exception.
      try:
          with app.test_request_context():
              flask.url_for("spam")
      except BuildError as err:
          error = err
      try:
          raise RuntimeError("Test case where BuildError is not current.")
      except RuntimeError:
          pytest.raises(BuildError, app.handle_url_build_error, error, "spam", {})
  
      # Test a custom handler.
      def handler(error, endpoint, values):
          # Just a test.
          return "/test_handler/"
  
      app.url_build_error_handlers.append(handler)
      with app.test_request_context():
          assert flask.url_for("spam") == "/test_handler/"

Assertions:
  - assert flask.url_for('spam') == '/test_handler/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_build_error_handler.json

================================================================================
Test: test_build_error_handler_reraise
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.url_build_error_handlers.append (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_build_error_handler_reraise
  - app.url_build_error_handlers.append (:0)
    Called by: test_build_error_handler_reraise

Test Source Code:
  def test_build_error_handler_reraise(app):
      # Test a custom handler which reraises the BuildError
      def handler_raises_build_error(error, endpoint, values):
          raise error
  
      app.url_build_error_handlers.append(handler_raises_build_error)
  
      with app.test_request_context():
          pytest.raises(BuildError, flask.url_for, "not.existing")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_build_error_handler_reraise.json

================================================================================
Test: test_url_for_passes_special_values_to_build_error_handler
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_url_for_passes_special_values_to_build_error_handler

Test Source Code:
  def test_url_for_passes_special_values_to_build_error_handler(app):
      @app.url_build_error_handlers.append
      def handler(error, endpoint, values):
          assert values == {
              "_external": False,
              "_anchor": None,
              "_method": None,
              "_scheme": None,
          }
          return "handled"
  
      with app.test_request_context():
          flask.url_for("/")

Assertions:
  - assert values == {'_external': False, '_anchor': None, '_method': None, '_scheme': None}

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_for_passes_special_values_to_build_error_handler.json

================================================================================
Test: test_static_files
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - client.get (:0)
  - rv.close (:0)
  - rv.data.strip (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_static_files
  - client.get (:0)
    Called by: test_static_files
  - rv.close (:0)
    Called by: test_static_files
  - rv.data.strip (:0)
    Called by: test_static_files

Test Source Code:
  def test_static_files(app, client):
      rv = client.get("/static/index.html")
      assert rv.status_code == 200
      assert rv.data.strip() == b"<h1>Hello World!</h1>"
      with app.test_request_context():
          assert flask.url_for("static", filename="index.html") == "/static/index.html"
      rv.close()

Assertions:
  - assert rv.status_code == 200
  - assert rv.data.strip() == b'<h1>Hello World!</h1>'
  - assert flask.url_for('static', filename='index.html') == '/static/index.html'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_files.json

================================================================================
Test: test_static_url_path
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_client.get (:0)
  - rv.close (:0)
  - app.test_request_context (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_static_url_path
  - app.test_client.get (:0)
    Called by: test_static_url_path
  - rv.close (:0)
    Called by: test_static_url_path
  - app.test_client (:0)
    Called by: test_static_url_path

Test Source Code:
  def test_static_url_path():
      app = flask.Flask(__name__, static_url_path="/foo")
      app.testing = True
      rv = app.test_client().get("/foo/index.html")
      assert rv.status_code == 200
      rv.close()
  
      with app.test_request_context():
          assert flask.url_for("static", filename="index.html") == "/foo/index.html"

Assertions:
  - assert rv.status_code == 200
  - assert flask.url_for('static', filename='index.html') == '/foo/index.html'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_url_path.json

================================================================================
Test: test_static_url_path_with_ending_slash
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_client.get (:0)
  - rv.close (:0)
  - app.test_request_context (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_static_url_path_with_ending_slash
  - app.test_client.get (:0)
    Called by: test_static_url_path_with_ending_slash
  - rv.close (:0)
    Called by: test_static_url_path_with_ending_slash
  - app.test_client (:0)
    Called by: test_static_url_path_with_ending_slash

Test Source Code:
  def test_static_url_path_with_ending_slash():
      app = flask.Flask(__name__, static_url_path="/foo/")
      app.testing = True
      rv = app.test_client().get("/foo/index.html")
      assert rv.status_code == 200
      rv.close()
  
      with app.test_request_context():
          assert flask.url_for("static", filename="index.html") == "/foo/index.html"

Assertions:
  - assert rv.status_code == 200
  - assert flask.url_for('static', filename='index.html') == '/foo/index.html'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_url_path_with_ending_slash.json

================================================================================
Test: test_static_url_empty_path
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client.open (:0)
  - rv.close (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client.open (:0)
    Called by: test_static_url_empty_path
  - rv.close (:0)
    Called by: test_static_url_empty_path
  - app.test_client (:0)
    Called by: test_static_url_empty_path

Test Source Code:
  def test_static_url_empty_path(app):
      app = flask.Flask(__name__, static_folder="", static_url_path="")
      rv = app.test_client().open("/static/index.html", method="GET")
      assert rv.status_code == 200
      rv.close()

Assertions:
  - assert rv.status_code == 200

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_url_empty_path.json

================================================================================
Test: test_static_url_empty_path_default
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client.open (:0)
  - rv.close (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client.open (:0)
    Called by: test_static_url_empty_path_default
  - rv.close (:0)
    Called by: test_static_url_empty_path_default
  - app.test_client (:0)
    Called by: test_static_url_empty_path_default

Test Source Code:
  def test_static_url_empty_path_default(app):
      app = flask.Flask(__name__, static_folder="")
      rv = app.test_client().open("/static/index.html", method="GET")
      assert rv.status_code == 200
      rv.close()

Assertions:
  - assert rv.status_code == 200

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_url_empty_path_default.json

================================================================================
Test: test_static_folder_with_pathlib_path
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client.open (:0)
  - rv.close (:0)
  - Path (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client.open (:0)
    Called by: test_static_folder_with_pathlib_path
  - rv.close (:0)
    Called by: test_static_folder_with_pathlib_path
  - Path (:0)
    Called by: test_static_folder_with_pathlib_path
  - app.test_client (:0)
    Called by: test_static_folder_with_pathlib_path

Test Source Code:
  def test_static_folder_with_pathlib_path(app):
      from pathlib import Path
  
      app = flask.Flask(__name__, static_folder=Path("static"))
      rv = app.test_client().open("/static/index.html", method="GET")
      assert rv.status_code == 200
      rv.close()

Assertions:
  - assert rv.status_code == 200

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_folder_with_pathlib_path.json

================================================================================
Test: test_static_folder_with_ending_slash
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.test_client.get (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_static_folder_with_ending_slash
  - app.test_client.get (:0)
    Called by: test_static_folder_with_ending_slash
  - app.test_client (:0)
    Called by: test_static_folder_with_ending_slash

Test Source Code:
  def test_static_folder_with_ending_slash():
      app = flask.Flask(__name__, static_folder="static/")
  
      @app.route("/<path:path>")
      def catch_all(path):
          return path
  
      rv = app.test_client().get("/catch/all")
      assert rv.data == b"catch/all"

Assertions:
  - assert rv.data == b'catch/all'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_folder_with_ending_slash.json

================================================================================
Test: test_static_route_with_host_matching
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_client (:0)
  - c.get (:0)
  - rv.close (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_static_route_with_host_matching
  - app.test_client (:0)
    Called by: test_static_route_with_host_matching
  - c.get (:0)
    Called by: test_static_route_with_host_matching
  - rv.close (:0)
    Called by: test_static_route_with_host_matching

Test Source Code:
  def test_static_route_with_host_matching():
      app = flask.Flask(__name__, host_matching=True, static_host="example.com")
      c = app.test_client()
      rv = c.get("http://example.com/static/index.html")
      assert rv.status_code == 200
      rv.close()
      with app.test_request_context():
          rv = flask.url_for("static", filename="index.html", _external=True)
          assert rv == "http://example.com/static/index.html"
      # Providing static_host without host_matching=True should error.
      with pytest.raises(AssertionError):
          flask.Flask(__name__, static_host="example.com")
      # Providing host_matching=True with static_folder
      # but without static_host should error.
      with pytest.raises(AssertionError):
          flask.Flask(__name__, host_matching=True)
      # Providing host_matching=True without static_host
      # but with static_folder=None should not error.
      flask.Flask(__name__, host_matching=True, static_folder=None)

Assertions:
  - assert rv.status_code == 200
  - assert rv == 'http://example.com/static/index.html'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_static_route_with_host_matching.json

================================================================================
Test: test_request_locals
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - repr (:0)

Methods Actually Called (Dynamic Analysis):
  - repr (:0)
    Called by: test_request_locals

Test Source Code:
  def test_request_locals():
      assert repr(flask.g) == "<LocalProxy unbound>"
      assert not flask.g

Assertions:
  - assert repr(flask.g) == '<LocalProxy unbound>'
  - assert not flask.g

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_locals.json

================================================================================
Test: test_server_name_matching
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.test_client (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - nullcontext (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_server_name_matching
  - app.test_client (:0)
    Called by: test_server_name_matching
  - client.get (:0)
    Called by: test_server_name_matching
  - nullcontext (:0)
    Called by: test_server_name_matching

Test Source Code:
  def test_server_name_matching(
      subdomain_matching: bool,
      host_matching: bool,
      expect_base: str,
      expect_abc: str,
      expect_xyz: str,
  ) -> None:
      app = flask.Flask(
          __name__,
          subdomain_matching=subdomain_matching,
          host_matching=host_matching,
          static_host="example.test" if host_matching else None,
      )
      app.config["SERVER_NAME"] = "example.test"
  
      @app.route("/", defaults={"name": "default"}, host="<name>")
      @app.route("/", subdomain="<name>", host="<name>.example.test")
      def index(name: str) -> str:
          return name
  
      client = app.test_client()
  
      r = client.get(base_url="http://example.test")
      assert r.text == expect_base
  
      r = client.get(base_url="http://abc.example.test")
      assert r.text == expect_abc
  
      with pytest.warns() if subdomain_matching else nullcontext():
          r = client.get(base_url="http://xyz.other.test")
  
      assert r.text == expect_xyz

Assertions:
  - assert r.text == expect_base
  - assert r.text == expect_abc
  - assert r.text == expect_xyz

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_server_name_matching.json

================================================================================
Test: test_server_name_subdomain
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_server_name_subdomain
  - app.route (:0)
    Called by: test_server_name_subdomain
  - client.get (:0)
    Called by: test_server_name_subdomain

Test Source Code:
  def test_server_name_subdomain():
      app = flask.Flask(__name__, subdomain_matching=True)
      client = app.test_client()
  
      @app.route("/")
      def index():
          return "default"
  
      @app.route("/", subdomain="foo")
      def subdomain():
          return "subdomain"
  
      app.config["SERVER_NAME"] = "dev.local:5000"
      rv = client.get("/")
      assert rv.data == b"default"
  
      rv = client.get("/", "http://dev.local:5000")
      assert rv.data == b"default"
  
      rv = client.get("/", "https://dev.local:5000")
      assert rv.data == b"default"
  
      app.config["SERVER_NAME"] = "dev.local:443"
      rv = client.get("/", "https://dev.local")
  
      # Werkzeug 1.0 fixes matching https scheme with 443 port
      if rv.status_code != 404:
          assert rv.data == b"default"
  
      app.config["SERVER_NAME"] = "dev.local"
      rv = client.get("/", "https://dev.local")
      assert rv.data == b"default"
  
      # suppress Werkzeug 0.15 warning about name mismatch
      with warnings.catch_warnings():
          warnings.filterwarnings(
              "ignore", "Current server name", UserWarning, "flask.app"
          )
          rv = client.get("/", "http://foo.localhost")
          assert rv.status_code == 404
  
      rv = client.get("/", "http://foo.dev.local")
      assert rv.data == b"subdomain"

Assertions:
  - assert rv.data == b'default'
  - assert rv.data == b'default'
  - assert rv.data == b'default'
  - assert rv.data == b'default'
  - assert rv.data == b'subdomain'
  - assert rv.data == b'default'
  - assert rv.status_code == 404

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_server_name_subdomain.json

================================================================================
Test: test_exception_propagation
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_exception_propagation
  - client.get (:0)
    Called by: test_exception_propagation

Test Source Code:
  def test_exception_propagation(app, client, key):
      app.testing = False
  
      @app.route("/")
      def index():
          raise ZeroDivisionError
  
      if key is not None:
          app.config[key] = True
  
          with pytest.raises(ZeroDivisionError):
              client.get("/")
      else:
          assert client.get("/").status_code == 500

Assertions:
  - assert client.get('/').status_code == 500

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_exception_propagation.json

================================================================================
Test: test_werkzeug_passthrough_errors
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - app.run (:0)
  - kwargs.get (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_werkzeug_passthrough_errors
  - app.run (:0)
    Called by: test_werkzeug_passthrough_errors
  - kwargs.get (:0)
    Called by: test_werkzeug_passthrough_errors

Test Source Code:
  def test_werkzeug_passthrough_errors(
      monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app
  ):
      rv = {}
  
      # Mocks werkzeug.serving.run_simple method
      def run_simple_mock(*args, **kwargs):
          rv["passthrough_errors"] = kwargs.get("passthrough_errors")
  
      monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
      app.config["PROPAGATE_EXCEPTIONS"] = propagate_exceptions
      app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_werkzeug_passthrough_errors.json

================================================================================
Test: test_url_processors
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - values.pop (:0)
  - app.url_map.is_endpoint_expecting (:0)
  - values.setdefault (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_url_processors
  - values.pop (:0)
    Called by: test_url_processors
  - app.url_map.is_endpoint_expecting (:0)
    Called by: test_url_processors
  - values.setdefault (:0)
    Called by: test_url_processors
  - client.get (:0)
    Called by: test_url_processors

Test Source Code:
  def test_url_processors(app, client):
      @app.url_defaults
      def add_language_code(endpoint, values):
          if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(
              endpoint, "lang_code"
          ):
              values.setdefault("lang_code", flask.g.lang_code)
  
      @app.url_value_preprocessor
      def pull_lang_code(endpoint, values):
          flask.g.lang_code = values.pop("lang_code", None)
  
      @app.route("/<lang_code>/")
      def index():
          return flask.url_for("about")
  
      @app.route("/<lang_code>/about")
      def about():
          return flask.url_for("something_else")
  
      @app.route("/foo")
      def something_else():
          return flask.url_for("about", lang_code="en")
  
      assert client.get("/de/").data == b"/de/about"
      assert client.get("/de/about").data == b"/foo"
      assert client.get("/foo").data == b"/en/about"

Assertions:
  - assert client.get('/de/').data == b'/de/about'
  - assert client.get('/de/about').data == b'/foo'
  - assert client.get('/foo').data == b'/en/about'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_processors.json

================================================================================
Test: test_inject_blueprint_url_defaults
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - bp.route (:0)
  - app.register_blueprint (:0)
  - dict (:0)
  - app.inject_url_defaults (:0)
  - dict (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_inject_blueprint_url_defaults
  - bp.route (:0)
    Called by: test_inject_blueprint_url_defaults
  - app.register_blueprint (:0)
    Called by: test_inject_blueprint_url_defaults
  - dict (:0)
    Called by: test_inject_blueprint_url_defaults
  - app.inject_url_defaults (:0)
    Called by: test_inject_blueprint_url_defaults

Test Source Code:
  def test_inject_blueprint_url_defaults(app):
      bp = flask.Blueprint("foo", __name__, template_folder="template")
  
      @bp.url_defaults
      def bp_defaults(endpoint, values):
          values["page"] = "login"
  
      @bp.route("/<page>")
      def view(page):
          pass
  
      app.register_blueprint(bp)
  
      values = dict()
      app.inject_url_defaults("foo.view", values)
      expected = dict(page="login")
      assert values == expected
  
      with app.test_request_context("/somepage"):
          url = flask.url_for("foo.view")
      expected = "/login"
      assert url == expected

Assertions:
  - assert values == expected
  - assert url == expected

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_inject_blueprint_url_defaults.json

================================================================================
Test: test_nonascii_pathinfo
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_nonascii_pathinfo
  - client.get (:0)
    Called by: test_nonascii_pathinfo

Test Source Code:
  def test_nonascii_pathinfo(app, client):
      @app.route("/киртест")
      def index():
          return "Hello World!"
  
      rv = client.get("/киртест")
      assert rv.data == b"Hello World!"

Assertions:
  - assert rv.data == b'Hello World!'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_nonascii_pathinfo.json

================================================================================
Test: test_no_setup_after_first_request
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.add_url_rule (:0)
  - str (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_no_setup_after_first_request
  - app.add_url_rule (:0)
    Called by: test_no_setup_after_first_request
  - str (:0)
    Called by: test_no_setup_after_first_request
  - client.get (:0)
    Called by: test_no_setup_after_first_request

Test Source Code:
  def test_no_setup_after_first_request(app, client):
      app.debug = True
  
      @app.route("/")
      def index():
          return "Awesome"
  
      assert client.get("/").data == b"Awesome"
  
      with pytest.raises(AssertionError) as exc_info:
          app.add_url_rule("/foo", endpoint="late")
  
      assert "setup method 'add_url_rule'" in str(exc_info.value)

Assertions:
  - assert client.get('/').data == b'Awesome'
  - assert "setup method 'add_url_rule'" in str(exc_info.value)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_no_setup_after_first_request.json

================================================================================
Test: test_routing_redirect_debugging
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.post (:0)
  - monkeypatch.setattr (:0)
  - client.post (:0)
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_routing_redirect_debugging
  - client.post (:0)
    Called by: test_routing_redirect_debugging
  - monkeypatch.setattr (:0)
    Called by: test_routing_redirect_debugging
  - str (:0)
    Called by: test_routing_redirect_debugging

Test Source Code:
  def test_routing_redirect_debugging(monkeypatch, app, client):
      app.config["DEBUG"] = True
  
      @app.route("/user/", methods=["GET", "POST"])
      def user():
          return flask.request.form["status"]
  
      # default redirect code preserves form data
      rv = client.post("/user", data={"status": "success"}, follow_redirects=True)
      assert rv.data == b"success"
  
      # 301 and 302 raise error
      monkeypatch.setattr(RequestRedirect, "code", 301)
  
      with client, pytest.raises(AssertionError) as exc_info:
          client.post("/user", data={"status": "error"}, follow_redirects=True)
  
      assert "canonical URL 'http://localhost/user/'" in str(exc_info.value)

Assertions:
  - assert rv.data == b'success'
  - assert "canonical URL 'http://localhost/user/'" in str(exc_info.value)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_routing_redirect_debugging.json

================================================================================
Test: test_route_decorator_custom_endpoint
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_request_context (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_route_decorator_custom_endpoint
  - app.route (:0)
    Called by: test_route_decorator_custom_endpoint
  - client.get (:0)
    Called by: test_route_decorator_custom_endpoint

Test Source Code:
  def test_route_decorator_custom_endpoint(app, client):
      app.debug = True
  
      @app.route("/foo/")
      def foo():
          return flask.request.endpoint
  
      @app.route("/bar/", endpoint="bar")
      def for_bar():
          return flask.request.endpoint
  
      @app.route("/bar/123", endpoint="123")
      def for_bar_foo():
          return flask.request.endpoint
  
      with app.test_request_context():
          assert flask.url_for("foo") == "/foo/"
          assert flask.url_for("bar") == "/bar/"
          assert flask.url_for("123") == "/bar/123"
  
      assert client.get("/foo/").data == b"foo"
      assert client.get("/bar/").data == b"bar"
      assert client.get("/bar/123").data == b"123"

Assertions:
  - assert client.get('/foo/').data == b'foo'
  - assert client.get('/bar/').data == b'bar'
  - assert client.get('/bar/123').data == b'123'
  - assert flask.url_for('foo') == '/foo/'
  - assert flask.url_for('bar') == '/bar/'
  - assert flask.url_for('123') == '/bar/123'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_route_decorator_custom_endpoint.json

================================================================================
Test: test_get_method_on_g
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_get_method_on_g(app_ctx):
      assert flask.g.get("x") is None
      assert flask.g.get("x", 11) == 11
      flask.g.x = 42
      assert flask.g.get("x") == 42
      assert flask.g.x == 42

Assertions:
  - assert flask.g.get('x') is None
  - assert flask.g.get('x', 11) == 11
  - assert flask.g.get('x') == 42
  - assert flask.g.x == 42

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_get_method_on_g.json

================================================================================
Test: test_g_iteration_protocol
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - sorted (:0)

Methods Actually Called (Dynamic Analysis):
  - sorted (:0)
    Called by: test_g_iteration_protocol

Test Source Code:
  def test_g_iteration_protocol(app_ctx):
      flask.g.foo = 23
      flask.g.bar = 42
      assert "foo" in flask.g
      assert "foos" not in flask.g
      assert sorted(flask.g) == ["bar", "foo"]

Assertions:
  - assert 'foo' in flask.g
  - assert 'foos' not in flask.g
  - assert sorted(flask.g) == ['bar', 'foo']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_g_iteration_protocol.json

================================================================================
Test: test_subdomain_basic_support
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_subdomain_basic_support
  - app.route (:0)
    Called by: test_subdomain_basic_support
  - client.get (:0)
    Called by: test_subdomain_basic_support

Test Source Code:
  def test_subdomain_basic_support():
      app = flask.Flask(__name__, subdomain_matching=True)
      app.config["SERVER_NAME"] = "localhost.localdomain"
      client = app.test_client()
  
      @app.route("/")
      def normal_index():
          return "normal index"
  
      @app.route("/", subdomain="test")
      def test_index():
          return "test index"
  
      rv = client.get("/", "http://localhost.localdomain/")
      assert rv.data == b"normal index"
  
      rv = client.get("/", "http://test.localhost.localdomain/")
      assert rv.data == b"test index"

Assertions:
  - assert rv.data == b'normal index'
  - assert rv.data == b'test index'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_subdomain_basic_support.json

================================================================================
Test: test_subdomain_matching
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_subdomain_matching
  - app.route (:0)
    Called by: test_subdomain_matching
  - client.get (:0)
    Called by: test_subdomain_matching

Test Source Code:
  def test_subdomain_matching():
      app = flask.Flask(__name__, subdomain_matching=True)
      client = app.test_client()
      app.config["SERVER_NAME"] = "localhost.localdomain"
  
      @app.route("/", subdomain="<user>")
      def index(user):
          return f"index for {user}"
  
      rv = client.get("/", "http://mitsuhiko.localhost.localdomain/")
      assert rv.data == b"index for mitsuhiko"

Assertions:
  - assert rv.data == b'index for mitsuhiko'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_subdomain_matching.json

================================================================================
Test: test_subdomain_matching_with_ports
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_subdomain_matching_with_ports
  - app.route (:0)
    Called by: test_subdomain_matching_with_ports
  - client.get (:0)
    Called by: test_subdomain_matching_with_ports

Test Source Code:
  def test_subdomain_matching_with_ports():
      app = flask.Flask(__name__, subdomain_matching=True)
      app.config["SERVER_NAME"] = "localhost.localdomain:3000"
      client = app.test_client()
  
      @app.route("/", subdomain="<user>")
      def index(user):
          return f"index for {user}"
  
      rv = client.get("/", "http://mitsuhiko.localhost.localdomain:3000/")
      assert rv.data == b"index for mitsuhiko"

Assertions:
  - assert rv.data == b'index for mitsuhiko'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_subdomain_matching_with_ports.json

================================================================================
Test: test_subdomain_matching_other_name
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_subdomain_matching_other_name
  - app.route (:0)
    Called by: test_subdomain_matching_other_name
  - client.get (:0)
    Called by: test_subdomain_matching_other_name

Test Source Code:
  def test_subdomain_matching_other_name(matching):
      app = flask.Flask(__name__, subdomain_matching=matching)
      app.config["SERVER_NAME"] = "localhost.localdomain:3000"
      client = app.test_client()
  
      @app.route("/")
      def index():
          return "", 204
  
      # suppress Werkzeug 0.15 warning about name mismatch
      with warnings.catch_warnings():
          warnings.filterwarnings(
              "ignore", "Current server name", UserWarning, "flask.app"
          )
          # ip address can't match name
          rv = client.get("/", "http://127.0.0.1:3000/")
          assert rv.status_code == 404 if matching else 204
  
      # allow all subdomains if matching is disabled
      rv = client.get("/", "http://www.localhost.localdomain:3000/")
      assert rv.status_code == 404 if matching else 204

Assertions:
  - assert rv.status_code == 404 if matching else 204
  - assert rv.status_code == 404 if matching else 204

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_subdomain_matching_other_name.json

================================================================================
Test: test_multi_route_rules
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.open (:0)
  - client.open (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_multi_route_rules
  - client.open (:0)
    Called by: test_multi_route_rules

Test Source Code:
  def test_multi_route_rules(app, client):
      @app.route("/")
      @app.route("/<test>/")
      def index(test="a"):
          return test
  
      rv = client.open("/")
      assert rv.data == b"a"
      rv = client.open("/b/")
      assert rv.data == b"b"

Assertions:
  - assert rv.data == b'a'
  - assert rv.data == b'b'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_multi_route_rules.json

================================================================================
Test: test_multi_route_class_views
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - View (:0)
  - client.open (:0)
  - client.open (:0)
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)

Methods Actually Called (Dynamic Analysis):
  - View (:0)
    Called by: test_multi_route_class_views
  - client.open (:0)
    Called by: test_multi_route_class_views
  - app.add_url_rule (:0)
    Called by: test_multi_route_class_views

Test Source Code:
  def test_multi_route_class_views(app, client):
      class View:
          def __init__(self, app):
              app.add_url_rule("/", "index", self.index)
              app.add_url_rule("/<test>/", "index", self.index)
  
          def index(self, test="a"):
              return test
  
      _ = View(app)
      rv = client.open("/")
      assert rv.data == b"a"
      rv = client.open("/b/")
      assert rv.data == b"b"

Assertions:
  - assert rv.data == b'a'
  - assert rv.data == b'b'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_multi_route_class_views.json

================================================================================
Test: test_run_defaults
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - app.run (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_run_defaults
  - app.run (:0)
    Called by: test_run_defaults

Test Source Code:
  def test_run_defaults(monkeypatch, app):
      rv = {}
  
      # Mocks werkzeug.serving.run_simple method
      def run_simple_mock(*args, **kwargs):
          rv["result"] = "running..."
  
      monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
      app.run()
      assert rv["result"] == "running..."

Assertions:
  - assert rv['result'] == 'running...'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_defaults.json

================================================================================
Test: test_run_server_port
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - app.run (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_run_server_port
  - app.run (:0)
    Called by: test_run_server_port

Test Source Code:
  def test_run_server_port(monkeypatch, app):
      rv = {}
  
      # Mocks werkzeug.serving.run_simple method
      def run_simple_mock(hostname, port, application, *args, **kwargs):
          rv["result"] = f"running on {hostname}:{port} ..."
  
      monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
      hostname, port = "localhost", 8000
      app.run(hostname, port, debug=True)
      assert rv["result"] == f"running on {hostname}:{port} ..."

Assertions:
  - assert rv['result'] == f'running on {hostname}:{port} ...'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_server_port.json

================================================================================
Test: test_run_from_config
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - app.run (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_run_from_config
  - app.run (:0)
    Called by: test_run_from_config

Test Source Code:
  def test_run_from_config(
      monkeypatch, host, port, server_name, expect_host, expect_port, app
  ):
      def run_simple_mock(hostname, port, *args, **kwargs):
          assert hostname == expect_host
          assert port == expect_port
  
      monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
      app.config["SERVER_NAME"] = server_name
      app.run(host, port)

Assertions:
  - assert hostname == expect_host
  - assert port == expect_port

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_from_config.json

================================================================================
Test: test_max_cookie_size
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.route (:0)
  - client.get (:0)
  - recwarn.pop (:0)
  - client.get (:0)
  - app.app_context (:0)
  - r.set_cookie (:0)
  - len (:0)
  - str (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_max_cookie_size
  - app.route (:0)
    Called by: test_max_cookie_size
  - client.get (:0)
    Called by: test_max_cookie_size
  - recwarn.pop (:0)
    Called by: test_max_cookie_size
  - r.set_cookie (:0)
    Called by: test_max_cookie_size
  - len (:0)
    Called by: test_max_cookie_size
  - str (:0)
    Called by: test_max_cookie_size

Test Source Code:
  def test_max_cookie_size(app, client, recwarn):
      app.config["MAX_COOKIE_SIZE"] = 100
  
      # outside app context, default to Werkzeug static value,
      # which is also the default config
      response = flask.Response()
      default = flask.Flask.default_config["MAX_COOKIE_SIZE"]
      assert response.max_cookie_size == default
  
      # inside app context, use app config
      with app.app_context():
          assert flask.Response().max_cookie_size == 100
  
      @app.route("/")
      def index():
          r = flask.Response("", status=204)
          r.set_cookie("foo", "bar" * 100)
          return r
  
      client.get("/")
      assert len(recwarn) == 1
      w = recwarn.pop()
      assert "cookie is too large" in str(w.message)
  
      app.config["MAX_COOKIE_SIZE"] = 0
  
      client.get("/")
      assert len(recwarn) == 0

Assertions:
  - assert response.max_cookie_size == default
  - assert len(recwarn) == 1
  - assert 'cookie is too large' in str(w.message)
  - assert len(recwarn) == 0
  - assert flask.Response().max_cookie_size == 100

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_max_cookie_size.json

================================================================================
Test: test_app_freed_on_zero_refcount
File: __internal__/_data/flask/tests/test_basic.py

Methods Under Test (Static Analysis):
  - weak (:0)
  - weak (:0)
  - require_cpython_gc (:0)

Methods Actually Called (Dynamic Analysis):
  - weak (:0)
    Called by: test_app_freed_on_zero_refcount
  - require_cpython_gc (:0)
    Called by: test_app_freed_on_zero_refcount

Test Source Code:
  def test_app_freed_on_zero_refcount():
      # A Flask instance should not create a reference cycle that prevents CPython
      # from freeing it when all external references to it are released (see #3761).
      gc.disable()
      try:
          app = flask.Flask(__name__)
          assert app.view_functions["static"]
          weak = weakref.ref(app)
          assert weak() is not None
          del app
          assert weak() is None
      finally:
          gc.enable()

Assertions:
  - assert app.view_functions['static']
  - assert weak() is not None
  - assert weak() is None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_freed_on_zero_refcount.json

================================================================================
Test: test_blueprint_specific_error_handling
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - frontend.errorhandler (:0)
  - frontend.route (:0)
  - backend.errorhandler (:0)
  - backend.route (:0)
  - sideend.route (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.errorhandler (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - frontend.errorhandler (:0)
    Called by: test_blueprint_specific_error_handling
  - frontend.route (:0)
    Called by: test_blueprint_specific_error_handling
  - backend.errorhandler (:0)
    Called by: test_blueprint_specific_error_handling
  - backend.route (:0)
    Called by: test_blueprint_specific_error_handling
  - sideend.route (:0)
    Called by: test_blueprint_specific_error_handling
  - app.register_blueprint (:0)
    Called by: test_blueprint_specific_error_handling
  - app.errorhandler (:0)
    Called by: test_blueprint_specific_error_handling
  - client.get (:0)
    Called by: test_blueprint_specific_error_handling

Test Source Code:
  def test_blueprint_specific_error_handling(app, client):
      frontend = flask.Blueprint("frontend", __name__)
      backend = flask.Blueprint("backend", __name__)
      sideend = flask.Blueprint("sideend", __name__)
  
      @frontend.errorhandler(403)
      def frontend_forbidden(e):
          return "frontend says no", 403
  
      @frontend.route("/frontend-no")
      def frontend_no():
          flask.abort(403)
  
      @backend.errorhandler(403)
      def backend_forbidden(e):
          return "backend says no", 403
  
      @backend.route("/backend-no")
      def backend_no():
          flask.abort(403)
  
      @sideend.route("/what-is-a-sideend")
      def sideend_no():
          flask.abort(403)
  
      app.register_blueprint(frontend)
      app.register_blueprint(backend)
      app.register_blueprint(sideend)
  
      @app.errorhandler(403)
      def app_forbidden(e):
          return "application itself says no", 403
  
      assert client.get("/frontend-no").data == b"frontend says no"
      assert client.get("/backend-no").data == b"backend says no"
      assert client.get("/what-is-a-sideend").data == b"application itself says no"

Assertions:
  - assert client.get('/frontend-no').data == b'frontend says no'
  - assert client.get('/backend-no').data == b'backend says no'
  - assert client.get('/what-is-a-sideend').data == b'application itself says no'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_specific_error_handling.json

================================================================================
Test: test_blueprint_specific_user_error_handling
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - blue.errorhandler (:0)
  - blue.register_error_handler (:0)
  - blue.route (:0)
  - blue.route (:0)
  - app.register_blueprint (:0)
  - isinstance (:0)
  - isinstance (:0)
  - MyDecoratorException (:0)
  - MyFunctionException (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - blue.errorhandler (:0)
    Called by: test_blueprint_specific_user_error_handling
  - blue.register_error_handler (:0)
    Called by: test_blueprint_specific_user_error_handling
  - blue.route (:0)
    Called by: test_blueprint_specific_user_error_handling
  - app.register_blueprint (:0)
    Called by: test_blueprint_specific_user_error_handling
  - isinstance (:0)
    Called by: test_blueprint_specific_user_error_handling
  - MyDecoratorException (:0)
    Called by: test_blueprint_specific_user_error_handling
  - MyFunctionException (:0)
    Called by: test_blueprint_specific_user_error_handling
  - client.get (:0)
    Called by: test_blueprint_specific_user_error_handling

Test Source Code:
  def test_blueprint_specific_user_error_handling(app, client):
      class MyDecoratorException(Exception):
          pass
  
      class MyFunctionException(Exception):
          pass
  
      blue = flask.Blueprint("blue", __name__)
  
      @blue.errorhandler(MyDecoratorException)
      def my_decorator_exception_handler(e):
          assert isinstance(e, MyDecoratorException)
          return "boom"
  
      def my_function_exception_handler(e):
          assert isinstance(e, MyFunctionException)
          return "bam"
  
      blue.register_error_handler(MyFunctionException, my_function_exception_handler)
  
      @blue.route("/decorator")
      def blue_deco_test():
          raise MyDecoratorException()
  
      @blue.route("/function")
      def blue_func_test():
          raise MyFunctionException()
  
      app.register_blueprint(blue)
  
      assert client.get("/decorator").data == b"boom"
      assert client.get("/function").data == b"bam"

Assertions:
  - assert client.get('/decorator').data == b'boom'
  - assert client.get('/function').data == b'bam'
  - assert isinstance(e, MyDecoratorException)
  - assert isinstance(e, MyFunctionException)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_specific_user_error_handling.json

================================================================================
Test: test_blueprint_app_error_handling
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - errors.app_errorhandler (:0)
  - app.route (:0)
  - forbidden_bp.route (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - errors.app_errorhandler (:0)
    Called by: test_blueprint_app_error_handling
  - app.route (:0)
    Called by: test_blueprint_app_error_handling
  - forbidden_bp.route (:0)
    Called by: test_blueprint_app_error_handling
  - app.register_blueprint (:0)
    Called by: test_blueprint_app_error_handling
  - client.get (:0)
    Called by: test_blueprint_app_error_handling

Test Source Code:
  def test_blueprint_app_error_handling(app, client):
      errors = flask.Blueprint("errors", __name__)
  
      @errors.app_errorhandler(403)
      def forbidden_handler(e):
          return "you shall not pass", 403
  
      @app.route("/forbidden")
      def app_forbidden():
          flask.abort(403)
  
      forbidden_bp = flask.Blueprint("forbidden_bp", __name__)
  
      @forbidden_bp.route("/nope")
      def bp_forbidden():
          flask.abort(403)
  
      app.register_blueprint(errors)
      app.register_blueprint(forbidden_bp)
  
      assert client.get("/forbidden").data == b"you shall not pass"
      assert client.get("/nope").data == b"you shall not pass"

Assertions:
  - assert client.get('/forbidden').data == b'you shall not pass'
  - assert client.get('/nope').data == b'you shall not pass'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_app_error_handling.json

================================================================================
Test: test_blueprint_prefix_slash
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.route (:0)
  - app.register_blueprint (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.route (:0)
    Called by: test_blueprint_prefix_slash
  - app.register_blueprint (:0)
    Called by: test_blueprint_prefix_slash
  - client.get (:0)
    Called by: test_blueprint_prefix_slash

Test Source Code:
  def test_blueprint_prefix_slash(app, client, prefix, rule, url):
      bp = flask.Blueprint("test", __name__, url_prefix=prefix)
  
      @bp.route(rule)
      def index():
          return "", 204
  
      app.register_blueprint(bp)
      assert client.get(url).status_code == 204

Assertions:
  - assert client.get(url).status_code == 204

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_prefix_slash.json

================================================================================
Test: test_blueprint_url_defaults
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.route (:0)
  - bp.route (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - str (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.route (:0)
    Called by: test_blueprint_url_defaults
  - app.register_blueprint (:0)
    Called by: test_blueprint_url_defaults
  - str (:0)
    Called by: test_blueprint_url_defaults
  - client.get (:0)
    Called by: test_blueprint_url_defaults

Test Source Code:
  def test_blueprint_url_defaults(app, client):
      bp = flask.Blueprint("test", __name__)
  
      @bp.route("/foo", defaults={"baz": 42})
      def foo(bar, baz):
          return f"{bar}/{baz:d}"
  
      @bp.route("/bar")
      def bar(bar):
          return str(bar)
  
      app.register_blueprint(bp, url_prefix="/1", url_defaults={"bar": 23})
      app.register_blueprint(bp, name="test2", url_prefix="/2", url_defaults={"bar": 19})
  
      assert client.get("/1/foo").data == b"23/42"
      assert client.get("/2/foo").data == b"19/42"
      assert client.get("/1/bar").data == b"23"
      assert client.get("/2/bar").data == b"19"

Assertions:
  - assert client.get('/1/foo').data == b'23/42'
  - assert client.get('/2/foo').data == b'19/42'
  - assert client.get('/1/bar').data == b'23'
  - assert client.get('/2/bar').data == b'19'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_url_defaults.json

================================================================================
Test: test_blueprint_url_processors
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.route (:0)
  - bp.route (:0)
  - app.register_blueprint (:0)
  - values.setdefault (:0)
  - values.pop (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.route (:0)
    Called by: test_blueprint_url_processors
  - app.register_blueprint (:0)
    Called by: test_blueprint_url_processors
  - values.setdefault (:0)
    Called by: test_blueprint_url_processors
  - values.pop (:0)
    Called by: test_blueprint_url_processors
  - client.get (:0)
    Called by: test_blueprint_url_processors

Test Source Code:
  def test_blueprint_url_processors(app, client):
      bp = flask.Blueprint("frontend", __name__, url_prefix="/<lang_code>")
  
      @bp.url_defaults
      def add_language_code(endpoint, values):
          values.setdefault("lang_code", flask.g.lang_code)
  
      @bp.url_value_preprocessor
      def pull_lang_code(endpoint, values):
          flask.g.lang_code = values.pop("lang_code")
  
      @bp.route("/")
      def index():
          return flask.url_for(".about")
  
      @bp.route("/about")
      def about():
          return flask.url_for(".index")
  
      app.register_blueprint(bp)
  
      assert client.get("/de/").data == b"/de/about"
      assert client.get("/de/about").data == b"/de/"

Assertions:
  - assert client.get('/de/').data == b'/de/about'
  - assert client.get('/de/about').data == b'/de/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_url_processors.json

================================================================================
Test: test_templates_and_static
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - app.test_client (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - rv.close (:0)
  - client.get (:0)
  - rv.close (:0)
  - rv.data.strip (:0)
  - rv.data.strip (:0)
  - client.get (:0)
  - parse_cache_control_header (:0)
  - rv.close (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_templates_and_static
  - app.test_client (:0)
    Called by: test_templates_and_static
  - client.get (:0)
    Called by: test_templates_and_static
  - rv.close (:0)
    Called by: test_templates_and_static
  - rv.data.strip (:0)
    Called by: test_templates_and_static
  - parse_cache_control_header (:0)
    Called by: test_templates_and_static

Test Source Code:
  def test_templates_and_static(test_apps):
      from blueprintapp import app
  
      client = app.test_client()
  
      rv = client.get("/")
      assert rv.data == b"Hello from the Frontend"
      rv = client.get("/admin/")
      assert rv.data == b"Hello from the Admin"
      rv = client.get("/admin/index2")
      assert rv.data == b"Hello from the Admin"
      rv = client.get("/admin/static/test.txt")
      assert rv.data.strip() == b"Admin File"
      rv.close()
      rv = client.get("/admin/static/css/test.css")
      assert rv.data.strip() == b"/* nested file */"
      rv.close()
  
      # try/finally, in case other tests use this app for Blueprint tests.
      max_age_default = app.config["SEND_FILE_MAX_AGE_DEFAULT"]
      try:
          expected_max_age = 3600
          if app.config["SEND_FILE_MAX_AGE_DEFAULT"] == expected_max_age:
              expected_max_age = 7200
          app.config["SEND_FILE_MAX_AGE_DEFAULT"] = expected_max_age
          rv = client.get("/admin/static/css/test.css")
          cc = parse_cache_control_header(rv.headers["Cache-Control"])
          assert cc.max_age == expected_max_age
          rv.close()
      finally:
          app.config["SEND_FILE_MAX_AGE_DEFAULT"] = max_age_default
  
      with app.test_request_context():
          assert (
              flask.url_for("admin.static", filename="test.txt")
              == "/admin/static/test.txt"
          )
  
      with app.test_request_context():
          with pytest.raises(TemplateNotFound) as e:
              flask.render_template("missing.html")
          assert e.value.name == "missing.html"
  
      with flask.Flask(__name__).test_request_context():
          assert flask.render_template("nested/nested.txt") == "I'm nested"

Assertions:
  - assert rv.data == b'Hello from the Frontend'
  - assert rv.data == b'Hello from the Admin'
  - assert rv.data == b'Hello from the Admin'
  - assert rv.data.strip() == b'Admin File'
  - assert rv.data.strip() == b'/* nested file */'
  - assert cc.max_age == expected_max_age
  - assert flask.url_for('admin.static', filename='test.txt') == '/admin/static/test.txt'
  - assert e.value.name == 'missing.html'
  - assert flask.render_template('nested/nested.txt') == "I'm nested"

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_templates_and_static.json

================================================================================
Test: test_default_static_max_age
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - MyBlueprint (:0)
  - app.register_blueprint (:0)
  - app.test_request_context (:0)
  - app.test_request_context (:0)
  - blueprint.send_static_file (:0)
  - parse_cache_control_header (:0)
  - rv.close (:0)

Methods Actually Called (Dynamic Analysis):
  - MyBlueprint (:0)
    Called by: test_default_static_max_age
  - app.register_blueprint (:0)
    Called by: test_default_static_max_age
  - app.test_request_context (:0)
    Called by: test_default_static_max_age
  - blueprint.send_static_file (:0)
    Called by: test_default_static_max_age
  - parse_cache_control_header (:0)
    Called by: test_default_static_max_age
  - rv.close (:0)
    Called by: test_default_static_max_age

Test Source Code:
  def test_default_static_max_age(app):
      class MyBlueprint(flask.Blueprint):
          def get_send_file_max_age(self, filename):
              return 100
  
      blueprint = MyBlueprint("blueprint", __name__, static_folder="static")
      app.register_blueprint(blueprint)
  
      # try/finally, in case other tests use this app for Blueprint tests.
      max_age_default = app.config["SEND_FILE_MAX_AGE_DEFAULT"]
      try:
          with app.test_request_context():
              unexpected_max_age = 3600
              if app.config["SEND_FILE_MAX_AGE_DEFAULT"] == unexpected_max_age:
                  unexpected_max_age = 7200
              app.config["SEND_FILE_MAX_AGE_DEFAULT"] = unexpected_max_age
              rv = blueprint.send_static_file("index.html")
              cc = parse_cache_control_header(rv.headers["Cache-Control"])
              assert cc.max_age == 100
              rv.close()
      finally:
          app.config["SEND_FILE_MAX_AGE_DEFAULT"] = max_age_default

Assertions:
  - assert cc.max_age == 100

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_default_static_max_age.json

================================================================================
Test: test_templates_list
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - sorted (:0)
  - app.jinja_env.list_templates (:0)

Methods Actually Called (Dynamic Analysis):
  - sorted (:0)
    Called by: test_templates_list
  - app.jinja_env.list_templates (:0)
    Called by: test_templates_list

Test Source Code:
  def test_templates_list(test_apps):
      from blueprintapp import app
  
      templates = sorted(app.jinja_env.list_templates())
      assert templates == ["admin/index.html", "frontend/index.html"]

Assertions:
  - assert templates == ['admin/index.html', 'frontend/index.html']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_templates_list.json

================================================================================
Test: test_dotted_name_not_allowed
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_dotted_name_not_allowed(app, client):
      with pytest.raises(ValueError):
          flask.Blueprint("app.ui", __name__)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_dotted_name_not_allowed.json

================================================================================
Test: test_empty_name_not_allowed
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_empty_name_not_allowed(app, client):
      with pytest.raises(ValueError):
          flask.Blueprint("", __name__)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_empty_name_not_allowed.json

================================================================================
Test: test_dotted_names_from_app
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.register_blueprint (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_dotted_names_from_app
  - app.register_blueprint (:0)
    Called by: test_dotted_names_from_app
  - client.get (:0)
    Called by: test_dotted_names_from_app

Test Source Code:
  def test_dotted_names_from_app(app, client):
      test = flask.Blueprint("test", __name__)
  
      @app.route("/")
      def app_index():
          return flask.url_for("test.index")
  
      @test.route("/test/")
      def index():
          return flask.url_for("app_index")
  
      app.register_blueprint(test)
  
      rv = client.get("/")
      assert rv.data == b"/test/"

Assertions:
  - assert rv.data == b'/test/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_dotted_names_from_app.json

================================================================================
Test: test_empty_url_defaults
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.route (:0)
  - bp.route (:0)
  - app.register_blueprint (:0)
  - str (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.route (:0)
    Called by: test_empty_url_defaults
  - app.register_blueprint (:0)
    Called by: test_empty_url_defaults
  - str (:0)
    Called by: test_empty_url_defaults
  - client.get (:0)
    Called by: test_empty_url_defaults

Test Source Code:
  def test_empty_url_defaults(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.route("/", defaults={"page": 1})
      @bp.route("/page/<int:page>")
      def something(page):
          return str(page)
  
      app.register_blueprint(bp)
  
      assert client.get("/").data == b"1"
      assert client.get("/page/2").data == b"2"

Assertions:
  - assert client.get('/').data == b'1'
  - assert client.get('/page/2').data == b'2'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_empty_url_defaults.json

================================================================================
Test: test_route_decorator_custom_endpoint
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.route (:0)
  - bp.route (:0)
  - bp.route (:0)
  - bp.route (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.route (:0)
    Called by: test_route_decorator_custom_endpoint
  - app.register_blueprint (:0)
    Called by: test_route_decorator_custom_endpoint
  - app.route (:0)
    Called by: test_route_decorator_custom_endpoint
  - client.get (:0)
    Called by: test_route_decorator_custom_endpoint

Test Source Code:
  def test_route_decorator_custom_endpoint(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.route("/foo")
      def foo():
          return flask.request.endpoint
  
      @bp.route("/bar", endpoint="bar")
      def foo_bar():
          return flask.request.endpoint
  
      @bp.route("/bar/123", endpoint="123")
      def foo_bar_foo():
          return flask.request.endpoint
  
      @bp.route("/bar/foo")
      def bar_foo():
          return flask.request.endpoint
  
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.request.endpoint
  
      assert client.get("/").data == b"index"
      assert client.get("/py/foo").data == b"bp.foo"
      assert client.get("/py/bar").data == b"bp.bar"
      assert client.get("/py/bar/123").data == b"bp.123"
      assert client.get("/py/bar/foo").data == b"bp.bar_foo"

Assertions:
  - assert client.get('/').data == b'index'
  - assert client.get('/py/foo').data == b'bp.foo'
  - assert client.get('/py/bar').data == b'bp.bar'
  - assert client.get('/py/bar/123').data == b'bp.123'
  - assert client.get('/py/bar/foo').data == b'bp.bar_foo'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_route_decorator_custom_endpoint.json

================================================================================
Test: test_route_decorator_custom_endpoint_with_dots
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.route (:0)
  - bp.add_url_rule (:0)
  - bp.add_url_rule (:0)
  - bp.route (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.route (:0)
    Called by: test_route_decorator_custom_endpoint_with_dots
  - bp.add_url_rule (:0)
    Called by: test_route_decorator_custom_endpoint_with_dots

Test Source Code:
  def test_route_decorator_custom_endpoint_with_dots(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      with pytest.raises(ValueError):
          bp.route("/", endpoint="a.b")(lambda: "")
  
      with pytest.raises(ValueError):
          bp.add_url_rule("/", endpoint="a.b")
  
      def view():
          return ""
  
      view.__name__ = "a.b"
  
      with pytest.raises(ValueError):
          bp.add_url_rule("/", view_func=view)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_route_decorator_custom_endpoint_with_dots.json

================================================================================
Test: test_endpoint_decorator
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.url_map.add (:0)
  - bp.endpoint (:0)
  - app.register_blueprint (:0)
  - Rule (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.url_map.add (:0)
    Called by: test_endpoint_decorator
  - bp.endpoint (:0)
    Called by: test_endpoint_decorator
  - app.register_blueprint (:0)
    Called by: test_endpoint_decorator
  - Rule (:0)
    Called by: test_endpoint_decorator
  - client.get (:0)
    Called by: test_endpoint_decorator

Test Source Code:
  def test_endpoint_decorator(app, client):
      from werkzeug.routing import Rule
  
      app.url_map.add(Rule("/foo", endpoint="bar"))
  
      bp = flask.Blueprint("bp", __name__)
  
      @bp.endpoint("bar")
      def foobar():
          return flask.request.endpoint
  
      app.register_blueprint(bp, url_prefix="/bp_prefix")
  
      assert client.get("/foo").data == b"bar"
      assert client.get("/bp_prefix/bar").status_code == 404

Assertions:
  - assert client.get('/foo').data == b'bar'
  - assert client.get('/bp_prefix/bar').status_code == 404

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_endpoint_decorator.json

================================================================================
Test: test_template_filter
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_filter (:0)
    Called by: test_template_filter
  - app.register_blueprint (:0)
    Called by: test_template_filter
  - app.jinja_env.filters.keys (:0)
    Called by: test_template_filter
  - app.jinja_env.filters (:0)
    Called by: test_template_filter

Test Source Code:
  def test_template_filter(app):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_filter()
      def my_reverse(s):
          return s[::-1]
  
      app.register_blueprint(bp, url_prefix="/py")
      assert "my_reverse" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["my_reverse"] == my_reverse
      assert app.jinja_env.filters["my_reverse"]("abcd") == "dcba"

Assertions:
  - assert 'my_reverse' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['my_reverse'] == my_reverse
  - assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter.json

================================================================================
Test: test_add_template_filter
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_filter (:0)
    Called by: test_add_template_filter
  - app.register_blueprint (:0)
    Called by: test_add_template_filter
  - app.jinja_env.filters.keys (:0)
    Called by: test_add_template_filter
  - app.jinja_env.filters (:0)
    Called by: test_add_template_filter

Test Source Code:
  def test_add_template_filter(app):
      bp = flask.Blueprint("bp", __name__)
  
      def my_reverse(s):
          return s[::-1]
  
      bp.add_app_template_filter(my_reverse)
      app.register_blueprint(bp, url_prefix="/py")
      assert "my_reverse" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["my_reverse"] == my_reverse
      assert app.jinja_env.filters["my_reverse"]("abcd") == "dcba"

Assertions:
  - assert 'my_reverse' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['my_reverse'] == my_reverse
  - assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter.json

================================================================================
Test: test_template_filter_with_name
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_filter (:0)
    Called by: test_template_filter_with_name
  - app.register_blueprint (:0)
    Called by: test_template_filter_with_name
  - app.jinja_env.filters.keys (:0)
    Called by: test_template_filter_with_name
  - app.jinja_env.filters (:0)
    Called by: test_template_filter_with_name

Test Source Code:
  def test_template_filter_with_name(app):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_filter("strrev")
      def my_reverse(s):
          return s[::-1]
  
      app.register_blueprint(bp, url_prefix="/py")
      assert "strrev" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["strrev"] == my_reverse
      assert app.jinja_env.filters["strrev"]("abcd") == "dcba"

Assertions:
  - assert 'strrev' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['strrev'] == my_reverse
  - assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter_with_name.json

================================================================================
Test: test_add_template_filter_with_name
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_filter (:0)
    Called by: test_add_template_filter_with_name
  - app.register_blueprint (:0)
    Called by: test_add_template_filter_with_name
  - app.jinja_env.filters.keys (:0)
    Called by: test_add_template_filter_with_name
  - app.jinja_env.filters (:0)
    Called by: test_add_template_filter_with_name

Test Source Code:
  def test_add_template_filter_with_name(app):
      bp = flask.Blueprint("bp", __name__)
  
      def my_reverse(s):
          return s[::-1]
  
      bp.add_app_template_filter(my_reverse, "strrev")
      app.register_blueprint(bp, url_prefix="/py")
      assert "strrev" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["strrev"] == my_reverse
      assert app.jinja_env.filters["strrev"]("abcd") == "dcba"

Assertions:
  - assert 'strrev' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['strrev'] == my_reverse
  - assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter_with_name.json

================================================================================
Test: test_template_filter_with_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_filter (:0)
    Called by: test_template_filter_with_template
  - app.register_blueprint (:0)
    Called by: test_template_filter_with_template
  - app.route (:0)
    Called by: test_template_filter_with_template
  - client.get (:0)
    Called by: test_template_filter_with_template

Test Source Code:
  def test_template_filter_with_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_filter()
      def super_reverse(s):
          return s[::-1]
  
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter_with_template.json

================================================================================
Test: test_template_filter_after_route_with_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - bp.app_template_filter (:0)
  - app.register_blueprint (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_template_filter_after_route_with_template
  - bp.app_template_filter (:0)
    Called by: test_template_filter_after_route_with_template
  - app.register_blueprint (:0)
    Called by: test_template_filter_after_route_with_template
  - client.get (:0)
    Called by: test_template_filter_after_route_with_template

Test Source Code:
  def test_template_filter_after_route_with_template(app, client):
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_filter()
      def super_reverse(s):
          return s[::-1]
  
      app.register_blueprint(bp, url_prefix="/py")
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter_after_route_with_template.json

================================================================================
Test: test_add_template_filter_with_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_filter (:0)
    Called by: test_add_template_filter_with_template
  - app.register_blueprint (:0)
    Called by: test_add_template_filter_with_template
  - app.route (:0)
    Called by: test_add_template_filter_with_template
  - client.get (:0)
    Called by: test_add_template_filter_with_template

Test Source Code:
  def test_add_template_filter_with_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      def super_reverse(s):
          return s[::-1]
  
      bp.add_app_template_filter(super_reverse)
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter_with_template.json

================================================================================
Test: test_template_filter_with_name_and_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_filter (:0)
    Called by: test_template_filter_with_name_and_template
  - app.register_blueprint (:0)
    Called by: test_template_filter_with_name_and_template
  - app.route (:0)
    Called by: test_template_filter_with_name_and_template
  - client.get (:0)
    Called by: test_template_filter_with_name_and_template

Test Source Code:
  def test_template_filter_with_name_and_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_filter("super_reverse")
      def my_reverse(s):
          return s[::-1]
  
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter_with_name_and_template.json

================================================================================
Test: test_add_template_filter_with_name_and_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_filter (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_filter (:0)
    Called by: test_add_template_filter_with_name_and_template
  - app.register_blueprint (:0)
    Called by: test_add_template_filter_with_name_and_template
  - app.route (:0)
    Called by: test_add_template_filter_with_name_and_template
  - client.get (:0)
    Called by: test_add_template_filter_with_name_and_template

Test Source Code:
  def test_add_template_filter_with_name_and_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      def my_reverse(s):
          return s[::-1]
  
      bp.add_app_template_filter(my_reverse, "super_reverse")
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter_with_name_and_template.json

================================================================================
Test: test_template_test
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_test (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_test (:0)
    Called by: test_template_test
  - app.register_blueprint (:0)
    Called by: test_template_test
  - app.jinja_env.tests (:0)
    Called by: test_template_test
  - isinstance (:0)
    Called by: test_template_test
  - app.jinja_env.tests.keys (:0)
    Called by: test_template_test

Test Source Code:
  def test_template_test(app):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_test()
      def is_boolean(value):
          return isinstance(value, bool)
  
      app.register_blueprint(bp, url_prefix="/py")
      assert "is_boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["is_boolean"] == is_boolean
      assert app.jinja_env.tests["is_boolean"](False)

Assertions:
  - assert 'is_boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['is_boolean'] == is_boolean
  - assert app.jinja_env.tests['is_boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test.json

================================================================================
Test: test_add_template_test
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_test (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_test (:0)
    Called by: test_add_template_test
  - app.register_blueprint (:0)
    Called by: test_add_template_test
  - app.jinja_env.tests (:0)
    Called by: test_add_template_test
  - isinstance (:0)
    Called by: test_add_template_test
  - app.jinja_env.tests.keys (:0)
    Called by: test_add_template_test

Test Source Code:
  def test_add_template_test(app):
      bp = flask.Blueprint("bp", __name__)
  
      def is_boolean(value):
          return isinstance(value, bool)
  
      bp.add_app_template_test(is_boolean)
      app.register_blueprint(bp, url_prefix="/py")
      assert "is_boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["is_boolean"] == is_boolean
      assert app.jinja_env.tests["is_boolean"](False)

Assertions:
  - assert 'is_boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['is_boolean'] == is_boolean
  - assert app.jinja_env.tests['is_boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test.json

================================================================================
Test: test_template_test_with_name
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_test (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_test (:0)
    Called by: test_template_test_with_name
  - app.register_blueprint (:0)
    Called by: test_template_test_with_name
  - app.jinja_env.tests (:0)
    Called by: test_template_test_with_name
  - isinstance (:0)
    Called by: test_template_test_with_name
  - app.jinja_env.tests.keys (:0)
    Called by: test_template_test_with_name

Test Source Code:
  def test_template_test_with_name(app):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_test("boolean")
      def is_boolean(value):
          return isinstance(value, bool)
  
      app.register_blueprint(bp, url_prefix="/py")
      assert "boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["boolean"] == is_boolean
      assert app.jinja_env.tests["boolean"](False)

Assertions:
  - assert 'boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['boolean'] == is_boolean
  - assert app.jinja_env.tests['boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test_with_name.json

================================================================================
Test: test_add_template_test_with_name
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_test (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_test (:0)
    Called by: test_add_template_test_with_name
  - app.register_blueprint (:0)
    Called by: test_add_template_test_with_name
  - app.jinja_env.tests (:0)
    Called by: test_add_template_test_with_name
  - isinstance (:0)
    Called by: test_add_template_test_with_name
  - app.jinja_env.tests.keys (:0)
    Called by: test_add_template_test_with_name

Test Source Code:
  def test_add_template_test_with_name(app):
      bp = flask.Blueprint("bp", __name__)
  
      def is_boolean(value):
          return isinstance(value, bool)
  
      bp.add_app_template_test(is_boolean, "boolean")
      app.register_blueprint(bp, url_prefix="/py")
      assert "boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["boolean"] == is_boolean
      assert app.jinja_env.tests["boolean"](False)

Assertions:
  - assert 'boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['boolean'] == is_boolean
  - assert app.jinja_env.tests['boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test_with_name.json

================================================================================
Test: test_template_test_with_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_test (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_test (:0)
    Called by: test_template_test_with_template
  - app.register_blueprint (:0)
    Called by: test_template_test_with_template
  - app.route (:0)
    Called by: test_template_test_with_template
  - client.get (:0)
    Called by: test_template_test_with_template
  - isinstance (:0)
    Called by: test_template_test_with_template

Test Source Code:
  def test_template_test_with_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_test()
      def boolean(value):
          return isinstance(value, bool)
  
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test_with_template.json

================================================================================
Test: test_template_test_after_route_with_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - bp.app_template_test (:0)
  - app.register_blueprint (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_template_test_after_route_with_template
  - bp.app_template_test (:0)
    Called by: test_template_test_after_route_with_template
  - app.register_blueprint (:0)
    Called by: test_template_test_after_route_with_template
  - client.get (:0)
    Called by: test_template_test_after_route_with_template
  - isinstance (:0)
    Called by: test_template_test_after_route_with_template

Test Source Code:
  def test_template_test_after_route_with_template(app, client):
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_test()
      def boolean(value):
          return isinstance(value, bool)
  
      app.register_blueprint(bp, url_prefix="/py")
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test_after_route_with_template.json

================================================================================
Test: test_add_template_test_with_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_test (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_test (:0)
    Called by: test_add_template_test_with_template
  - app.register_blueprint (:0)
    Called by: test_add_template_test_with_template
  - app.route (:0)
    Called by: test_add_template_test_with_template
  - client.get (:0)
    Called by: test_add_template_test_with_template
  - isinstance (:0)
    Called by: test_add_template_test_with_template

Test Source Code:
  def test_add_template_test_with_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      def boolean(value):
          return isinstance(value, bool)
  
      bp.add_app_template_test(boolean)
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test_with_template.json

================================================================================
Test: test_template_test_with_name_and_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.app_template_test (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.app_template_test (:0)
    Called by: test_template_test_with_name_and_template
  - app.register_blueprint (:0)
    Called by: test_template_test_with_name_and_template
  - app.route (:0)
    Called by: test_template_test_with_name_and_template
  - client.get (:0)
    Called by: test_template_test_with_name_and_template
  - isinstance (:0)
    Called by: test_template_test_with_name_and_template

Test Source Code:
  def test_template_test_with_name_and_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_test("boolean")
      def is_boolean(value):
          return isinstance(value, bool)
  
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test_with_name_and_template.json

================================================================================
Test: test_add_template_test_with_name_and_template
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.add_app_template_test (:0)
  - app.register_blueprint (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.add_app_template_test (:0)
    Called by: test_add_template_test_with_name_and_template
  - app.register_blueprint (:0)
    Called by: test_add_template_test_with_name_and_template
  - app.route (:0)
    Called by: test_add_template_test_with_name_and_template
  - client.get (:0)
    Called by: test_add_template_test_with_name_and_template
  - isinstance (:0)
    Called by: test_add_template_test_with_name_and_template

Test Source Code:
  def test_add_template_test_with_name_and_template(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      def is_boolean(value):
          return isinstance(value, bool)
  
      bp.add_app_template_test(is_boolean, "boolean")
      app.register_blueprint(bp, url_prefix="/py")
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test_with_name_and_template.json

================================================================================
Test: test_context_processing
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - answer_bp.route (:0)
  - app.route (:0)
  - app.register_blueprint (:0)
  - template_string (test_blueprints.py:637)
    Source code:
      def template_string():
              return flask.render_template_string(
                  "{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}"
                  "{% if answer %}{{ answer }} is the answer.{% endif %}"
              )
  - template_string (test_blueprints.py:637)
    Source code:
      def template_string():
              return flask.render_template_string(
                  "{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}"
                  "{% if answer %}{{ answer }} is the answer.{% endif %}"
              )
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - answer_bp.route (:0)
    Called by: test_context_processing
  - app.route (:0)
    Called by: test_context_processing
  - app.register_blueprint (:0)
    Called by: test_context_processing
  - template_string (test_blueprints.py:637)
    Called by: test_context_processing
  - client.get (:0)
    Called by: test_context_processing

Test Source Code:
  def test_context_processing(app, client):
      answer_bp = flask.Blueprint("answer_bp", __name__)
  
      def template_string():
          return flask.render_template_string(
              "{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}"
              "{% if answer %}{{ answer }} is the answer.{% endif %}"
          )
  
      # App global context processor
      @answer_bp.app_context_processor
      def not_answer_context_processor():
          return {"notanswer": 43}
  
      # Blueprint local context processor
      @answer_bp.context_processor
      def answer_context_processor():
          return {"answer": 42}
  
      # Setup endpoints for testing
      @answer_bp.route("/bp")
      def bp_page():
          return template_string()
  
      @app.route("/")
      def app_page():
          return template_string()
  
      # Register the blueprint
      app.register_blueprint(answer_bp)
  
      app_page_bytes = client.get("/").data
      answer_page_bytes = client.get("/bp").data
  
      assert b"43" in app_page_bytes
      assert b"42" not in app_page_bytes
  
      assert b"42" in answer_page_bytes
      assert b"43" in answer_page_bytes

Assertions:
  - assert b'43' in app_page_bytes
  - assert b'42' not in app_page_bytes
  - assert b'42' in answer_page_bytes
  - assert b'43' in answer_page_bytes

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_context_processing.json

================================================================================
Test: test_template_global
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - bp.app_template_global (:0)
  - app.register_blueprint (:0)
  - app.jinja_env.globals.keys (:0)
  - app.jinja_env.globals.keys (:0)
  - app.jinja_env.globals (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_template_global
  - bp.app_template_global (:0)
    Called by: test_template_global
  - app.register_blueprint (:0)
    Called by: test_template_global
  - app.jinja_env.globals.keys (:0)
    Called by: test_template_global
  - app.jinja_env.globals (:0)
    Called by: test_template_global

Test Source Code:
  def test_template_global(app):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.app_template_global()
      def get_answer():
          return 42
  
      # Make sure the function is not in the jinja_env already
      assert "get_answer" not in app.jinja_env.globals.keys()
      app.register_blueprint(bp)
  
      # Tests
      assert "get_answer" in app.jinja_env.globals.keys()
      assert app.jinja_env.globals["get_answer"] is get_answer
      assert app.jinja_env.globals["get_answer"]() == 42
  
      with app.app_context():
          rv = flask.render_template_string("{{ get_answer() }}")
          assert rv == "42"

Assertions:
  - assert 'get_answer' not in app.jinja_env.globals.keys()
  - assert 'get_answer' in app.jinja_env.globals.keys()
  - assert app.jinja_env.globals['get_answer'] is get_answer
  - assert app.jinja_env.globals['get_answer']() == 42
  - assert rv == '42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_global.json

================================================================================
Test: test_request_processing
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.route (:0)
  - app.register_blueprint (:0)
  - client.get (:0)
  - evts.append (:0)
  - evts.append (:0)
  - evts.append (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.route (:0)
    Called by: test_request_processing
  - app.register_blueprint (:0)
    Called by: test_request_processing
  - client.get (:0)
    Called by: test_request_processing
  - evts.append (:0)
    Called by: test_request_processing

Test Source Code:
  def test_request_processing(app, client):
      bp = flask.Blueprint("bp", __name__)
      evts = []
  
      @bp.before_request
      def before_bp():
          evts.append("before")
  
      @bp.after_request
      def after_bp(response):
          response.data += b"|after"
          evts.append("after")
          return response
  
      @bp.teardown_request
      def teardown_bp(exc):
          evts.append("teardown")
  
      # Setup routes for testing
      @bp.route("/bp")
      def bp_endpoint():
          return "request"
  
      app.register_blueprint(bp)
  
      assert evts == []
      rv = client.get("/bp")
      assert rv.data == b"request|after"
      assert evts == ["before", "after", "teardown"]

Assertions:
  - assert evts == []
  - assert rv.data == b'request|after'
  - assert evts == ['before', 'after', 'teardown']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_processing.json

================================================================================
Test: test_app_request_processing
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.register_blueprint (:0)
  - app.route (:0)
  - evts.append (:0)
  - evts.append (:0)
  - evts.append (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.register_blueprint (:0)
    Called by: test_app_request_processing
  - app.route (:0)
    Called by: test_app_request_processing
  - evts.append (:0)
    Called by: test_app_request_processing
  - client.get (:0)
    Called by: test_app_request_processing

Test Source Code:
  def test_app_request_processing(app, client):
      bp = flask.Blueprint("bp", __name__)
      evts = []
  
      @bp.before_app_request
      def before_app():
          evts.append("before")
  
      @bp.after_app_request
      def after_app(response):
          response.data += b"|after"
          evts.append("after")
          return response
  
      @bp.teardown_app_request
      def teardown_app(exc):
          evts.append("teardown")
  
      app.register_blueprint(bp)
  
      # Setup routes for testing
      @app.route("/")
      def bp_endpoint():
          return "request"
  
      # before first request
      assert evts == []
  
      # first request
      resp = client.get("/").data
      assert resp == b"request|after"
      assert evts == ["before", "after", "teardown"]
  
      # second request
      resp = client.get("/").data
      assert resp == b"request|after"
      assert evts == ["before", "after", "teardown"] * 2

Assertions:
  - assert evts == []
  - assert resp == b'request|after'
  - assert evts == ['before', 'after', 'teardown']
  - assert resp == b'request|after'
  - assert evts == ['before', 'after', 'teardown'] * 2

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_request_processing.json

================================================================================
Test: test_app_url_processors
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - app.register_blueprint (:0)
  - values.setdefault (:0)
  - values.pop (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_app_url_processors
  - app.register_blueprint (:0)
    Called by: test_app_url_processors
  - values.setdefault (:0)
    Called by: test_app_url_processors
  - values.pop (:0)
    Called by: test_app_url_processors
  - client.get (:0)
    Called by: test_app_url_processors

Test Source Code:
  def test_app_url_processors(app, client):
      bp = flask.Blueprint("bp", __name__)
  
      # Register app-wide url defaults and preprocessor on blueprint
      @bp.app_url_defaults
      def add_language_code(endpoint, values):
          values.setdefault("lang_code", flask.g.lang_code)
  
      @bp.app_url_value_preprocessor
      def pull_lang_code(endpoint, values):
          flask.g.lang_code = values.pop("lang_code")
  
      # Register route rules at the app level
      @app.route("/<lang_code>/")
      def index():
          return flask.url_for("about")
  
      @app.route("/<lang_code>/about")
      def about():
          return flask.url_for("index")
  
      app.register_blueprint(bp)
  
      assert client.get("/de/").data == b"/de/about"
      assert client.get("/de/about").data == b"/de/"

Assertions:
  - assert client.get('/de/').data == b'/de/about'
  - assert client.get('/de/about').data == b'/de/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_url_processors.json

================================================================================
Test: test_nested_blueprint
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - parent.errorhandler (:0)
  - parent.route (:0)
  - parent.route (:0)
  - child.route (:0)
  - child.route (:0)
  - grandchild.errorhandler (:0)
  - grandchild.route (:0)
  - grandchild.route (:0)
  - child.register_blueprint (:0)
  - parent.register_blueprint (:0)
  - app.register_blueprint (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - parent.errorhandler (:0)
    Called by: test_nested_blueprint
  - parent.route (:0)
    Called by: test_nested_blueprint
  - child.route (:0)
    Called by: test_nested_blueprint
  - grandchild.errorhandler (:0)
    Called by: test_nested_blueprint
  - grandchild.route (:0)
    Called by: test_nested_blueprint
  - child.register_blueprint (:0)
    Called by: test_nested_blueprint
  - parent.register_blueprint (:0)
    Called by: test_nested_blueprint
  - app.register_blueprint (:0)
    Called by: test_nested_blueprint
  - client.get (:0)
    Called by: test_nested_blueprint

Test Source Code:
  def test_nested_blueprint(app, client):
      parent = flask.Blueprint("parent", __name__)
      child = flask.Blueprint("child", __name__)
      grandchild = flask.Blueprint("grandchild", __name__)
  
      @parent.errorhandler(403)
      def forbidden(e):
          return "Parent no", 403
  
      @parent.route("/")
      def parent_index():
          return "Parent yes"
  
      @parent.route("/no")
      def parent_no():
          flask.abort(403)
  
      @child.route("/")
      def child_index():
          return "Child yes"
  
      @child.route("/no")
      def child_no():
          flask.abort(403)
  
      @grandchild.errorhandler(403)
      def grandchild_forbidden(e):
          return "Grandchild no", 403
  
      @grandchild.route("/")
      def grandchild_index():
          return "Grandchild yes"
  
      @grandchild.route("/no")
      def grandchild_no():
          flask.abort(403)
  
      child.register_blueprint(grandchild, url_prefix="/grandchild")
      parent.register_blueprint(child, url_prefix="/child")
      app.register_blueprint(parent, url_prefix="/parent")
  
      assert client.get("/parent/").data == b"Parent yes"
      assert client.get("/parent/child/").data == b"Child yes"
      assert client.get("/parent/child/grandchild/").data == b"Grandchild yes"
      assert client.get("/parent/no").data == b"Parent no"
      assert client.get("/parent/child/no").data == b"Parent no"
      assert client.get("/parent/child/grandchild/no").data == b"Grandchild no"

Assertions:
  - assert client.get('/parent/').data == b'Parent yes'
  - assert client.get('/parent/child/').data == b'Child yes'
  - assert client.get('/parent/child/grandchild/').data == b'Grandchild yes'
  - assert client.get('/parent/no').data == b'Parent no'
  - assert client.get('/parent/child/no').data == b'Parent no'
  - assert client.get('/parent/child/grandchild/no').data == b'Grandchild no'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_nested_blueprint.json

================================================================================
Test: test_nested_callback_order
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - child.route (:0)
  - child.route (:0)
  - parent.register_blueprint (:0)
  - app.register_blueprint (:0)
  - dict (:0)
  - dict (:0)
  - dict (:0)
  - join (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - child.route (:0)
    Called by: test_nested_callback_order
  - parent.register_blueprint (:0)
    Called by: test_nested_callback_order
  - app.register_blueprint (:0)
    Called by: test_nested_callback_order
  - dict (:0)
    Called by: test_nested_callback_order
  - join (:0)
    Called by: test_nested_callback_order
  - client.get (:0)
    Called by: test_nested_callback_order

Test Source Code:
  def test_nested_callback_order(app, client):
      parent = flask.Blueprint("parent", __name__)
      child = flask.Blueprint("child", __name__)
  
      @app.before_request
      def app_before1():
          flask.g.setdefault("seen", []).append("app_1")
  
      @app.teardown_request
      def app_teardown1(e=None):
          assert flask.g.seen.pop() == "app_1"
  
      @app.before_request
      def app_before2():
          flask.g.setdefault("seen", []).append("app_2")
  
      @app.teardown_request
      def app_teardown2(e=None):
          assert flask.g.seen.pop() == "app_2"
  
      @app.context_processor
      def app_ctx():
          return dict(key="app")
  
      @parent.before_request
      def parent_before1():
          flask.g.setdefault("seen", []).append("parent_1")
  
      @parent.teardown_request
      def parent_teardown1(e=None):
          assert flask.g.seen.pop() == "parent_1"
  
      @parent.before_request
      def parent_before2():
          flask.g.setdefault("seen", []).append("parent_2")
  
      @parent.teardown_request
      def parent_teardown2(e=None):
          assert flask.g.seen.pop() == "parent_2"
  
      @parent.context_processor
      def parent_ctx():
          return dict(key="parent")
  
      @child.before_request
      def child_before1():
          flask.g.setdefault("seen", []).append("child_1")
  
      @child.teardown_request
      def child_teardown1(e=None):
          assert flask.g.seen.pop() == "child_1"
  
      @child.before_request
      def child_before2():
          flask.g.setdefault("seen", []).append("child_2")
  
      @child.teardown_request
      def child_teardown2(e=None):
          assert flask.g.seen.pop() == "child_2"
  
      @child.context_processor
      def child_ctx():
          return dict(key="child")
  
      @child.route("/a")
      def a():
          return ", ".join(flask.g.seen)
  
      @child.route("/b")
      def b():
          return flask.render_template_string("{{ key }}")
  
      parent.register_blueprint(child)
      app.register_blueprint(parent)
      assert (
          client.get("/a").data == b"app_1, app_2, parent_1, parent_2, child_1, child_2"
      )
      assert client.get("/b").data == b"child"

Assertions:
  - assert client.get('/a').data == b'app_1, app_2, parent_1, parent_2, child_1, child_2'
  - assert client.get('/b').data == b'child'
  - assert flask.g.seen.pop() == 'app_1'
  - assert flask.g.seen.pop() == 'app_2'
  - assert flask.g.seen.pop() == 'parent_1'
  - assert flask.g.seen.pop() == 'parent_2'
  - assert flask.g.seen.pop() == 'child_1'
  - assert flask.g.seen.pop() == 'child_2'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_nested_callback_order.json

================================================================================
Test: test_nesting_url_prefixes
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - child.route (:0)
  - parent.register_blueprint (:0)
  - app.register_blueprint (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - child.route (:0)
    Called by: test_nesting_url_prefixes
  - parent.register_blueprint (:0)
    Called by: test_nesting_url_prefixes
  - app.register_blueprint (:0)
    Called by: test_nesting_url_prefixes
  - client.get (:0)
    Called by: test_nesting_url_prefixes

Test Source Code:
  def test_nesting_url_prefixes(
      parent_init,
      child_init,
      parent_registration,
      child_registration,
      app,
      client,
  ) -> None:
      parent = flask.Blueprint("parent", __name__, url_prefix=parent_init)
      child = flask.Blueprint("child", __name__, url_prefix=child_init)
  
      @child.route("/")
      def index():
          return "index"
  
      parent.register_blueprint(child, url_prefix=child_registration)
      app.register_blueprint(parent, url_prefix=parent_registration)
  
      response = client.get("/parent/child/")
      assert response.status_code == 200

Assertions:
  - assert response.status_code == 200

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_nesting_url_prefixes.json

================================================================================
Test: test_nesting_subdomains
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - child.route (:0)
  - parent.register_blueprint (:0)
  - app.register_blueprint (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - child.route (:0)
    Called by: test_nesting_subdomains
  - parent.register_blueprint (:0)
    Called by: test_nesting_subdomains
  - app.register_blueprint (:0)
    Called by: test_nesting_subdomains
  - client.get (:0)
    Called by: test_nesting_subdomains

Test Source Code:
  def test_nesting_subdomains(app, client) -> None:
      app.subdomain_matching = True
      app.config["SERVER_NAME"] = "example.test"
      client.allow_subdomain_redirects = True
  
      parent = flask.Blueprint("parent", __name__)
      child = flask.Blueprint("child", __name__)
  
      @child.route("/child/")
      def index():
          return "child"
  
      parent.register_blueprint(child)
      app.register_blueprint(parent, subdomain="api")
  
      response = client.get("/child/", base_url="http://api.example.test")
      assert response.status_code == 200

Assertions:
  - assert response.status_code == 200

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_nesting_subdomains.json

================================================================================
Test: test_child_and_parent_subdomain
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - child.route (:0)
  - parent.register_blueprint (:0)
  - app.register_blueprint (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - child.route (:0)
    Called by: test_child_and_parent_subdomain
  - parent.register_blueprint (:0)
    Called by: test_child_and_parent_subdomain
  - app.register_blueprint (:0)
    Called by: test_child_and_parent_subdomain
  - client.get (:0)
    Called by: test_child_and_parent_subdomain

Test Source Code:
  def test_child_and_parent_subdomain(app, client) -> None:
      app.subdomain_matching = True
      app.config["SERVER_NAME"] = "example.test"
      client.allow_subdomain_redirects = True
  
      parent = flask.Blueprint("parent", __name__)
      child = flask.Blueprint("child", __name__, subdomain="api")
  
      @child.route("/")
      def index():
          return "child"
  
      parent.register_blueprint(child)
      app.register_blueprint(parent, subdomain="parent")
  
      response = client.get("/", base_url="http://api.parent.example.test")
      assert response.status_code == 200
  
      response = client.get("/", base_url="http://parent.example.test")
      assert response.status_code == 404

Assertions:
  - assert response.status_code == 200
  - assert response.status_code == 404

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_child_and_parent_subdomain.json

================================================================================
Test: test_unique_blueprint_names
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)

Methods Actually Called (Dynamic Analysis):
  - app.register_blueprint (:0)
    Called by: test_unique_blueprint_names

Test Source Code:
  def test_unique_blueprint_names(app, client) -> None:
      bp = flask.Blueprint("bp", __name__)
      bp2 = flask.Blueprint("bp", __name__)
  
      app.register_blueprint(bp)
  
      with pytest.raises(ValueError):
          app.register_blueprint(bp)  # same bp, same name, error
  
      app.register_blueprint(bp, name="again")  # same bp, different name, ok
  
      with pytest.raises(ValueError):
          app.register_blueprint(bp2)  # different bp, same name, error
  
      app.register_blueprint(bp2, name="alt")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_unique_blueprint_names.json

================================================================================
Test: test_self_registration
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.register_blueprint (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.register_blueprint (:0)
    Called by: test_self_registration

Test Source Code:
  def test_self_registration(app, client) -> None:
      bp = flask.Blueprint("bp", __name__)
      with pytest.raises(ValueError):
          bp.register_blueprint(bp)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_self_registration.json

================================================================================
Test: test_blueprint_renaming
File: __internal__/_data/flask/tests/test_blueprints.py

Methods Under Test (Static Analysis):
  - bp.get (:0)
  - bp.get (:0)
  - bp.errorhandler (:0)
  - bp2.get (:0)
  - bp.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.get (:0)
    Called by: test_blueprint_renaming
  - bp.errorhandler (:0)
    Called by: test_blueprint_renaming
  - bp2.get (:0)
    Called by: test_blueprint_renaming
  - bp.register_blueprint (:0)
    Called by: test_blueprint_renaming
  - app.register_blueprint (:0)
    Called by: test_blueprint_renaming
  - client.get (:0)
    Called by: test_blueprint_renaming

Test Source Code:
  def test_blueprint_renaming(app, client) -> None:
      bp = flask.Blueprint("bp", __name__)
      bp2 = flask.Blueprint("bp2", __name__)
  
      @bp.get("/")
      def index():
          return flask.request.endpoint
  
      @bp.get("/error")
      def error():
          flask.abort(403)
  
      @bp.errorhandler(403)
      def forbidden(_: Exception):
          return "Error", 403
  
      @bp2.get("/")
      def index2():
          return flask.request.endpoint
  
      bp.register_blueprint(bp2, url_prefix="/a", name="sub")
      app.register_blueprint(bp, url_prefix="/a")
      app.register_blueprint(bp, url_prefix="/b", name="alt")
  
      assert client.get("/a/").data == b"bp.index"
      assert client.get("/b/").data == b"alt.index"
      assert client.get("/a/a/").data == b"bp.sub.index2"
      assert client.get("/b/a/").data == b"alt.sub.index2"
      assert client.get("/a/error").data == b"Error"
      assert client.get("/b/error").data == b"Error"

Assertions:
  - assert client.get('/a/').data == b'bp.index'
  - assert client.get('/b/').data == b'alt.index'
  - assert client.get('/a/a/').data == b'bp.sub.index2'
  - assert client.get('/b/a/').data == b'alt.sub.index2'
  - assert client.get('/a/error').data == b'Error'
  - assert client.get('/b/error').data == b'Error'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_blueprint_renaming.json

================================================================================
Test: test_max_content_length
File: __internal__/_data/flask/tests/test_request.py

Methods Under Test (Static Analysis):
  - app.post (:0)
  - app.errorhandler (:0)
  - client.post (:0)
  - AssertionError (:0)

Methods Actually Called (Dynamic Analysis):
  - app.post (:0)
    Called by: test_max_content_length
  - app.errorhandler (:0)
    Called by: test_max_content_length
  - client.post (:0)
    Called by: test_max_content_length
  - AssertionError (:0)
    Called by: test_max_content_length

Test Source Code:
  def test_max_content_length(app: Flask, client: FlaskClient) -> None:
      app.config["MAX_CONTENT_LENGTH"] = 50
  
      @app.post("/")
      def index():
          request.form["myfile"]
          AssertionError()
  
      @app.errorhandler(413)
      def catcher(error):
          return "42"
  
      rv = client.post("/", data={"myfile": "foo" * 50})
      assert rv.data == b"42"

Assertions:
  - assert rv.data == b'42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_max_content_length.json

================================================================================
Test: test_limit_config
File: __internal__/_data/flask/tests/test_request.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.app_context (:0)
  - Request (:0)
  - app.app_context (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_limit_config
  - Request (:0)
    Called by: test_limit_config

Test Source Code:
  def test_limit_config(app: Flask):
      app.config["MAX_CONTENT_LENGTH"] = 100
      app.config["MAX_FORM_MEMORY_SIZE"] = 50
      app.config["MAX_FORM_PARTS"] = 3
      r = Request({})
  
      # no app context, use Werkzeug defaults
      assert r.max_content_length is None
      assert r.max_form_memory_size == 500_000
      assert r.max_form_parts == 1_000
  
      # in app context, use config
      with app.app_context():
          assert r.max_content_length == 100
          assert r.max_form_memory_size == 50
          assert r.max_form_parts == 3
  
      # regardless of app context, use override
      r.max_content_length = 90
      r.max_form_memory_size = 30
      r.max_form_parts = 4
  
      assert r.max_content_length == 90
      assert r.max_form_memory_size == 30
      assert r.max_form_parts == 4
  
      with app.app_context():
          assert r.max_content_length == 90
          assert r.max_form_memory_size == 30
          assert r.max_form_parts == 4

Assertions:
  - assert r.max_content_length is None
  - assert r.max_form_memory_size == 500000
  - assert r.max_form_parts == 1000
  - assert r.max_content_length == 90
  - assert r.max_form_memory_size == 30
  - assert r.max_form_parts == 4
  - assert r.max_content_length == 100
  - assert r.max_form_memory_size == 50
  - assert r.max_form_parts == 3
  - assert r.max_content_length == 90
  - assert r.max_form_memory_size == 30
  - assert r.max_form_parts == 4

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_limit_config.json

================================================================================
Test: test_trusted_hosts_config
File: __internal__/_data/flask/tests/test_request.py

Methods Under Test (Static Analysis):
  - app.get (:0)
  - app.test_client (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.get (:0)
    Called by: test_trusted_hosts_config
  - app.test_client (:0)
    Called by: test_trusted_hosts_config
  - client.get (:0)
    Called by: test_trusted_hosts_config

Test Source Code:
  def test_trusted_hosts_config(app: Flask) -> None:
      app.config["TRUSTED_HOSTS"] = ["example.test", ".other.test"]
  
      @app.get("/")
      def index() -> str:
          return ""
  
      client = app.test_client()
      r = client.get(base_url="http://example.test")
      assert r.status_code == 200
      r = client.get(base_url="http://a.other.test")
      assert r.status_code == 200
      r = client.get(base_url="http://bad.test")
      assert r.status_code == 400

Assertions:
  - assert r.status_code == 200
  - assert r.status_code == 200
  - assert r.status_code == 400

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_trusted_hosts_config.json

================================================================================
Test: test_config_from_pyfile
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - app.config.from_pyfile (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config
  - __file__.rsplit (:0)

Methods Actually Called (Dynamic Analysis):
  - app.config.from_pyfile (:0)
    Called by: test_config_from_pyfile
  - common_object_test (test_config.py:13)
    Called by: test_config_from_pyfile
  - __file__.rsplit (:0)
    Called by: test_config_from_pyfile

Test Source Code:
  def test_config_from_pyfile():
      app = flask.Flask(__name__)
      app.config.from_pyfile(f"{__file__.rsplit('.', 1)[0]}.py")
      common_object_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_pyfile.json

================================================================================
Test: test_config_from_object
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - app.config.from_object (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config

Methods Actually Called (Dynamic Analysis):
  - app.config.from_object (:0)
    Called by: test_config_from_object
  - common_object_test (test_config.py:13)
    Called by: test_config_from_object

Test Source Code:
  def test_config_from_object():
      app = flask.Flask(__name__)
      app.config.from_object(__name__)
      common_object_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_object.json

================================================================================
Test: test_config_from_file_json
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - app.config.from_file (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config

Methods Actually Called (Dynamic Analysis):
  - app.config.from_file (:0)
    Called by: test_config_from_file_json
  - common_object_test (test_config.py:13)
    Called by: test_config_from_file_json

Test Source Code:
  def test_config_from_file_json():
      app = flask.Flask(__name__)
      current_dir = os.path.dirname(os.path.abspath(__file__))
      app.config.from_file(os.path.join(current_dir, "static", "config.json"), json.load)
      common_object_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_file_json.json

================================================================================
Test: test_config_from_file_toml
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - app.config.from_file (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config

Methods Actually Called (Dynamic Analysis):
  - app.config.from_file (:0)
    Called by: test_config_from_file_toml
  - common_object_test (test_config.py:13)
    Called by: test_config_from_file_toml

Test Source Code:
  def test_config_from_file_toml():
      tomllib = pytest.importorskip("tomllib", reason="tomllib added in 3.11")
      app = flask.Flask(__name__)
      current_dir = os.path.dirname(os.path.abspath(__file__))
      app.config.from_file(
          os.path.join(current_dir, "static", "config.toml"), tomllib.load, text=False
      )
      common_object_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_file_toml.json

================================================================================
Test: test_from_prefixed_env
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - app.config.from_prefixed_env (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setenv (:0)
    Called by: test_from_prefixed_env
  - app.config.from_prefixed_env (:0)
    Called by: test_from_prefixed_env

Test Source Code:
  def test_from_prefixed_env(monkeypatch):
      monkeypatch.setenv("FLASK_STRING", "value")
      monkeypatch.setenv("FLASK_BOOL", "true")
      monkeypatch.setenv("FLASK_INT", "1")
      monkeypatch.setenv("FLASK_FLOAT", "1.2")
      monkeypatch.setenv("FLASK_LIST", "[1, 2]")
      monkeypatch.setenv("FLASK_DICT", '{"k": "v"}')
      monkeypatch.setenv("NOT_FLASK_OTHER", "other")
  
      app = flask.Flask(__name__)
      app.config.from_prefixed_env()
  
      assert app.config["STRING"] == "value"
      assert app.config["BOOL"] is True
      assert app.config["INT"] == 1
      assert app.config["FLOAT"] == 1.2
      assert app.config["LIST"] == [1, 2]
      assert app.config["DICT"] == {"k": "v"}
      assert "OTHER" not in app.config

Assertions:
  - assert app.config['STRING'] == 'value'
  - assert app.config['BOOL'] is True
  - assert app.config['INT'] == 1
  - assert app.config['FLOAT'] == 1.2
  - assert app.config['LIST'] == [1, 2]
  - assert app.config['DICT'] == {'k': 'v'}
  - assert 'OTHER' not in app.config

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_from_prefixed_env.json

================================================================================
Test: test_from_prefixed_env_custom_prefix
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - app.config.from_prefixed_env (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setenv (:0)
    Called by: test_from_prefixed_env_custom_prefix
  - app.config.from_prefixed_env (:0)
    Called by: test_from_prefixed_env_custom_prefix

Test Source Code:
  def test_from_prefixed_env_custom_prefix(monkeypatch):
      monkeypatch.setenv("FLASK_A", "a")
      monkeypatch.setenv("NOT_FLASK_A", "b")
  
      app = flask.Flask(__name__)
      app.config.from_prefixed_env("NOT_FLASK")
  
      assert app.config["A"] == "b"

Assertions:
  - assert app.config['A'] == 'b'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_from_prefixed_env_custom_prefix.json

================================================================================
Test: test_from_prefixed_env_nested
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - monkeypatch.setenv (:0)
  - app.config.from_prefixed_env (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setenv (:0)
    Called by: test_from_prefixed_env_nested
  - app.config.from_prefixed_env (:0)
    Called by: test_from_prefixed_env_nested

Test Source Code:
  def test_from_prefixed_env_nested(monkeypatch):
      monkeypatch.setenv("FLASK_EXIST__ok", "other")
      monkeypatch.setenv("FLASK_EXIST__inner__ik", "2")
      monkeypatch.setenv("FLASK_EXIST__new__more", '{"k": false}')
      monkeypatch.setenv("FLASK_NEW__K", "v")
  
      app = flask.Flask(__name__)
      app.config["EXIST"] = {"ok": "value", "flag": True, "inner": {"ik": 1}}
      app.config.from_prefixed_env()
  
      if os.name != "nt":
          assert app.config["EXIST"] == {
              "ok": "other",
              "flag": True,
              "inner": {"ik": 2},
              "new": {"more": {"k": False}},
          }
      else:
          # Windows env var keys are always uppercase.
          assert app.config["EXIST"] == {
              "ok": "value",
              "OK": "other",
              "flag": True,
              "inner": {"ik": 1},
              "INNER": {"IK": 2},
              "NEW": {"MORE": {"k": False}},
          }
  
      assert app.config["NEW"] == {"K": "v"}

Assertions:
  - assert app.config['NEW'] == {'K': 'v'}
  - assert app.config['EXIST'] == {'ok': 'other', 'flag': True, 'inner': {'ik': 2}, 'new': {'more': {'k': False}}}
  - assert app.config['EXIST'] == {'ok': 'value', 'OK': 'other', 'flag': True, 'inner': {'ik': 1}, 'INNER': {'IK': 2}, 'NEW': {'MORE': {'k': False}}}

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_from_prefixed_env_nested.json

================================================================================
Test: test_config_from_mapping
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - app.config.from_mapping (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config
  - app.config.from_mapping (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config
  - app.config.from_mapping (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config
  - app.config.from_mapping (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config
  - app.config.from_mapping (:0)

Methods Actually Called (Dynamic Analysis):
  - app.config.from_mapping (:0)
    Called by: test_config_from_mapping
  - common_object_test (test_config.py:13)
    Called by: test_config_from_mapping

Test Source Code:
  def test_config_from_mapping():
      app = flask.Flask(__name__)
      app.config.from_mapping({"SECRET_KEY": "config", "TEST_KEY": "foo"})
      common_object_test(app)
  
      app = flask.Flask(__name__)
      app.config.from_mapping([("SECRET_KEY", "config"), ("TEST_KEY", "foo")])
      common_object_test(app)
  
      app = flask.Flask(__name__)
      app.config.from_mapping(SECRET_KEY="config", TEST_KEY="foo")
      common_object_test(app)
  
      app = flask.Flask(__name__)
      app.config.from_mapping(SECRET_KEY="config", TEST_KEY="foo", skip_key="skip")
      common_object_test(app)
  
      app = flask.Flask(__name__)
      with pytest.raises(TypeError):
          app.config.from_mapping({}, {})

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_mapping.json

================================================================================
Test: test_config_from_class
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - app.config.from_object (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config

Methods Actually Called (Dynamic Analysis):
  - app.config.from_object (:0)
    Called by: test_config_from_class
  - common_object_test (test_config.py:13)
    Called by: test_config_from_class

Test Source Code:
  def test_config_from_class():
      class Base:
          TEST_KEY = "foo"
  
      class Test(Base):
          SECRET_KEY = "config"
  
      app = flask.Flask(__name__)
      app.config.from_object(Test)
      common_object_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_class.json

================================================================================
Test: test_config_from_envvar
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - monkeypatch.setattr (:0)
  - app.config.from_envvar (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config
  - app.config.from_envvar (:0)
  - str (:0)
  - app.config.from_envvar (:0)
  - __file__.rsplit (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_config_from_envvar
  - app.config.from_envvar (:0)
    Called by: test_config_from_envvar
  - common_object_test (test_config.py:13)
    Called by: test_config_from_envvar
  - str (:0)
    Called by: test_config_from_envvar
  - __file__.rsplit (:0)
    Called by: test_config_from_envvar

Test Source Code:
  def test_config_from_envvar(monkeypatch):
      monkeypatch.setattr("os.environ", {})
      app = flask.Flask(__name__)
  
      with pytest.raises(RuntimeError) as e:
          app.config.from_envvar("FOO_SETTINGS")
  
      assert "'FOO_SETTINGS' is not set" in str(e.value)
      assert not app.config.from_envvar("FOO_SETTINGS", silent=True)
  
      monkeypatch.setattr(
          "os.environ", {"FOO_SETTINGS": f"{__file__.rsplit('.', 1)[0]}.py"}
      )
      assert app.config.from_envvar("FOO_SETTINGS")
      common_object_test(app)

Assertions:
  - assert "'FOO_SETTINGS' is not set" in str(e.value)
  - assert not app.config.from_envvar('FOO_SETTINGS', silent=True)
  - assert app.config.from_envvar('FOO_SETTINGS')

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_envvar.json

================================================================================
Test: test_config_from_envvar_missing
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - str (:0)
  - msg.startswith (:0)
  - msg.endswith (:0)
  - app.config.from_envvar (:0)
  - app.config.from_envvar (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_config_from_envvar_missing
  - str (:0)
    Called by: test_config_from_envvar_missing
  - msg.startswith (:0)
    Called by: test_config_from_envvar_missing
  - msg.endswith (:0)
    Called by: test_config_from_envvar_missing
  - app.config.from_envvar (:0)
    Called by: test_config_from_envvar_missing

Test Source Code:
  def test_config_from_envvar_missing(monkeypatch):
      monkeypatch.setattr("os.environ", {"FOO_SETTINGS": "missing.cfg"})
      app = flask.Flask(__name__)
      with pytest.raises(IOError) as e:
          app.config.from_envvar("FOO_SETTINGS")
      msg = str(e.value)
      assert msg.startswith(
          "[Errno 2] Unable to load configuration file (No such file or directory):"
      )
      assert msg.endswith("missing.cfg'")
      assert not app.config.from_envvar("FOO_SETTINGS", silent=True)

Assertions:
  - assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')
  - assert msg.endswith("missing.cfg'")
  - assert not app.config.from_envvar('FOO_SETTINGS', silent=True)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_from_envvar_missing.json

================================================================================
Test: test_config_missing
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - str (:0)
  - msg.startswith (:0)
  - msg.endswith (:0)
  - app.config.from_pyfile (:0)
  - app.config.from_pyfile (:0)

Methods Actually Called (Dynamic Analysis):
  - str (:0)
    Called by: test_config_missing
  - msg.startswith (:0)
    Called by: test_config_missing
  - msg.endswith (:0)
    Called by: test_config_missing
  - app.config.from_pyfile (:0)
    Called by: test_config_missing

Test Source Code:
  def test_config_missing():
      app = flask.Flask(__name__)
      with pytest.raises(IOError) as e:
          app.config.from_pyfile("missing.cfg")
      msg = str(e.value)
      assert msg.startswith(
          "[Errno 2] Unable to load configuration file (No such file or directory):"
      )
      assert msg.endswith("missing.cfg'")
      assert not app.config.from_pyfile("missing.cfg", silent=True)

Assertions:
  - assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')
  - assert msg.endswith("missing.cfg'")
  - assert not app.config.from_pyfile('missing.cfg', silent=True)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_missing.json

================================================================================
Test: test_config_missing_file
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - str (:0)
  - msg.startswith (:0)
  - msg.endswith (:0)
  - app.config.from_file (:0)
  - app.config.from_file (:0)

Methods Actually Called (Dynamic Analysis):
  - str (:0)
    Called by: test_config_missing_file
  - msg.startswith (:0)
    Called by: test_config_missing_file
  - msg.endswith (:0)
    Called by: test_config_missing_file
  - app.config.from_file (:0)
    Called by: test_config_missing_file

Test Source Code:
  def test_config_missing_file():
      app = flask.Flask(__name__)
      with pytest.raises(IOError) as e:
          app.config.from_file("missing.json", load=json.load)
      msg = str(e.value)
      assert msg.startswith(
          "[Errno 2] Unable to load configuration file (No such file or directory):"
      )
      assert msg.endswith("missing.json'")
      assert not app.config.from_file("missing.json", load=json.load, silent=True)

Assertions:
  - assert msg.startswith('[Errno 2] Unable to load configuration file (No such file or directory):')
  - assert msg.endswith("missing.json'")
  - assert not app.config.from_file('missing.json', load=json.load, silent=True)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_config_missing_file.json

================================================================================
Test: test_custom_config_class
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - Flask (:0)
  - isinstance (:0)
  - app.config.from_object (:0)
  - common_object_test (test_config.py:13)
    Source code:
      def common_object_test(app):
          assert app.secret_key == "config"
          assert app.config["TEST_KEY"] == "foo"
          assert "TestConfig" not in app.config

Methods Actually Called (Dynamic Analysis):
  - Flask (:0)
    Called by: test_custom_config_class
  - isinstance (:0)
    Called by: test_custom_config_class
  - app.config.from_object (:0)
    Called by: test_custom_config_class
  - common_object_test (test_config.py:13)
    Called by: test_custom_config_class

Test Source Code:
  def test_custom_config_class():
      class Config(flask.Config):
          pass
  
      class Flask(flask.Flask):
          config_class = Config
  
      app = Flask(__name__)
      assert isinstance(app.config, Config)
      app.config.from_object(__name__)
      common_object_test(app)

Assertions:
  - assert isinstance(app.config, Config)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_custom_config_class.json

================================================================================
Test: test_session_lifetime
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_session_lifetime():
      app = flask.Flask(__name__)
      app.config["PERMANENT_SESSION_LIFETIME"] = 42
      assert app.permanent_session_lifetime.seconds == 42

Assertions:
  - assert app.permanent_session_lifetime.seconds == 42

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_session_lifetime.json

================================================================================
Test: test_get_namespace
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - app.config.get_namespace (:0)
  - app.config.get_namespace (:0)
  - app.config.get_namespace (:0)
  - app.config.get_namespace (:0)
  - len (:0)
  - len (:0)
  - len (:0)
  - len (:0)

Methods Actually Called (Dynamic Analysis):
  - app.config.get_namespace (:0)
    Called by: test_get_namespace
  - len (:0)
    Called by: test_get_namespace

Test Source Code:
  def test_get_namespace():
      app = flask.Flask(__name__)
      app.config["FOO_OPTION_1"] = "foo option 1"
      app.config["FOO_OPTION_2"] = "foo option 2"
      app.config["BAR_STUFF_1"] = "bar stuff 1"
      app.config["BAR_STUFF_2"] = "bar stuff 2"
      foo_options = app.config.get_namespace("FOO_")
      assert 2 == len(foo_options)
      assert "foo option 1" == foo_options["option_1"]
      assert "foo option 2" == foo_options["option_2"]
      bar_options = app.config.get_namespace("BAR_", lowercase=False)
      assert 2 == len(bar_options)
      assert "bar stuff 1" == bar_options["STUFF_1"]
      assert "bar stuff 2" == bar_options["STUFF_2"]
      foo_options = app.config.get_namespace("FOO_", trim_namespace=False)
      assert 2 == len(foo_options)
      assert "foo option 1" == foo_options["foo_option_1"]
      assert "foo option 2" == foo_options["foo_option_2"]
      bar_options = app.config.get_namespace(
          "BAR_", lowercase=False, trim_namespace=False
      )
      assert 2 == len(bar_options)
      assert "bar stuff 1" == bar_options["BAR_STUFF_1"]
      assert "bar stuff 2" == bar_options["BAR_STUFF_2"]

Assertions:
  - assert 2 == len(foo_options)
  - assert 'foo option 1' == foo_options['option_1']
  - assert 'foo option 2' == foo_options['option_2']
  - assert 2 == len(bar_options)
  - assert 'bar stuff 1' == bar_options['STUFF_1']
  - assert 'bar stuff 2' == bar_options['STUFF_2']
  - assert 2 == len(foo_options)
  - assert 'foo option 1' == foo_options['foo_option_1']
  - assert 'foo option 2' == foo_options['foo_option_2']
  - assert 2 == len(bar_options)
  - assert 'bar stuff 1' == bar_options['BAR_STUFF_1']
  - assert 'bar stuff 2' == bar_options['BAR_STUFF_2']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_get_namespace.json

================================================================================
Test: test_from_pyfile_weird_encoding
File: __internal__/_data/flask/tests/test_config.py

Methods Under Test (Static Analysis):
  - f.write_text (:0)
  - app.config.from_pyfile (:0)

Methods Actually Called (Dynamic Analysis):
  - f.write_text (:0)
    Called by: test_from_pyfile_weird_encoding
  - app.config.from_pyfile (:0)
    Called by: test_from_pyfile_weird_encoding

Test Source Code:
  def test_from_pyfile_weird_encoding(tmp_path, encoding):
      f = tmp_path / "my_config.py"
      f.write_text(f'# -*- coding: {encoding} -*-\nTEST_VALUE = "föö"\n', encoding)
      app = flask.Flask(__name__)
      app.config.from_pyfile(os.fspath(f))
      value = app.config["TEST_VALUE"]
      assert value == "föö"

Assertions:
  - assert value == 'föö'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_from_pyfile_weird_encoding.json

================================================================================
Test: test_basic_view
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - common_test (test_views.py:7)
    Source code:
      def common_test(app):
          c = app.test_client()
      
          assert c.get("/").data == b"GET"
          assert c.post("/").data == b"POST"
          assert c.put("/").status_code == 405
          meths = parse_set_header(c.open("/", method="OPTIONS").headers["Allow"])
          assert sorted(meths) == ["GET", "HEAD", "OPTIONS", "POST"]
  - Index.as_view (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_basic_view
  - common_test (test_views.py:7)
    Called by: test_basic_view
  - Index.as_view (:0)
    Called by: test_basic_view

Test Source Code:
  def test_basic_view(app):
      class Index(flask.views.View):
          methods = ["GET", "POST"]
  
          def dispatch_request(self):
              return flask.request.method
  
      app.add_url_rule("/", view_func=Index.as_view("index"))
      common_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_basic_view.json

================================================================================
Test: test_method_based_view
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - common_test (test_views.py:7)
    Source code:
      def common_test(app):
          c = app.test_client()
      
          assert c.get("/").data == b"GET"
          assert c.post("/").data == b"POST"
          assert c.put("/").status_code == 405
          meths = parse_set_header(c.open("/", method="OPTIONS").headers["Allow"])
          assert sorted(meths) == ["GET", "HEAD", "OPTIONS", "POST"]
  - Index.as_view (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_method_based_view
  - common_test (test_views.py:7)
    Called by: test_method_based_view
  - Index.as_view (:0)
    Called by: test_method_based_view

Test Source Code:
  def test_method_based_view(app):
      class Index(flask.views.MethodView):
          def get(self):
              return "GET"
  
          def post(self):
              return "POST"
  
      app.add_url_rule("/", view_func=Index.as_view("index"))
  
      common_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_method_based_view.json

================================================================================
Test: test_view_patching
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - Index.as_view (:0)
  - app.add_url_rule (:0)
  - common_test (test_views.py:7)
    Source code:
      def common_test(app):
          c = app.test_client()
      
          assert c.get("/").data == b"GET"
          assert c.post("/").data == b"POST"
          assert c.put("/").status_code == 405
          meths = parse_set_header(c.open("/", method="OPTIONS").headers["Allow"])
          assert sorted(meths) == ["GET", "HEAD", "OPTIONS", "POST"]

Methods Actually Called (Dynamic Analysis):
  - Index.as_view (:0)
    Called by: test_view_patching
  - app.add_url_rule (:0)
    Called by: test_view_patching
  - common_test (test_views.py:7)
    Called by: test_view_patching

Test Source Code:
  def test_view_patching(app):
      class Index(flask.views.MethodView):
          def get(self):
              raise ZeroDivisionError
  
          def post(self):
              raise ZeroDivisionError
  
      class Other(Index):
          def get(self):
              return "GET"
  
          def post(self):
              return "POST"
  
      view = Index.as_view("index")
      view.view_class = Other
      app.add_url_rule("/", view_func=view)
      common_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_view_patching.json

================================================================================
Test: test_view_inheritance
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - parse_set_header (:0)
  - sorted (:0)
  - BetterIndex.as_view (:0)
  - client.open (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_view_inheritance
  - parse_set_header (:0)
    Called by: test_view_inheritance
  - sorted (:0)
    Called by: test_view_inheritance
  - BetterIndex.as_view (:0)
    Called by: test_view_inheritance
  - client.open (:0)
    Called by: test_view_inheritance

Test Source Code:
  def test_view_inheritance(app, client):
      class Index(flask.views.MethodView):
          def get(self):
              return "GET"
  
          def post(self):
              return "POST"
  
      class BetterIndex(Index):
          def delete(self):
              return "DELETE"
  
      app.add_url_rule("/", view_func=BetterIndex.as_view("index"))
  
      meths = parse_set_header(client.open("/", method="OPTIONS").headers["Allow"])
      assert sorted(meths) == ["DELETE", "GET", "HEAD", "OPTIONS", "POST"]

Assertions:
  - assert sorted(meths) == ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_view_inheritance.json

================================================================================
Test: test_view_decorators
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - client.get (:0)
  - Index.as_view (:0)
  - f (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_view_decorators
  - client.get (:0)
    Called by: test_view_decorators
  - Index.as_view (:0)
    Called by: test_view_decorators
  - f (:0)
    Called by: test_view_decorators

Test Source Code:
  def test_view_decorators(app, client):
      def add_x_parachute(f):
          def new_function(*args, **kwargs):
              resp = flask.make_response(f(*args, **kwargs))
              resp.headers["X-Parachute"] = "awesome"
              return resp
  
          return new_function
  
      class Index(flask.views.View):
          decorators = [add_x_parachute]
  
          def dispatch_request(self):
              return "Awesome"
  
      app.add_url_rule("/", view_func=Index.as_view("index"))
      rv = client.get("/")
      assert rv.headers["X-Parachute"] == "awesome"
      assert rv.data == b"Awesome"

Assertions:
  - assert rv.headers['X-Parachute'] == 'awesome'
  - assert rv.data == b'Awesome'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_view_decorators.json

================================================================================
Test: test_view_provide_automatic_options_attr
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - app.test_client (:0)
  - c.open (:0)
  - app.add_url_rule (:0)
  - app.test_client (:0)
  - c.open (:0)
  - app.add_url_rule (:0)
  - app.test_client (:0)
  - c.open (:0)
  - sorted (:0)
  - Index1.as_view (:0)
  - Index2.as_view (:0)
  - Index3.as_view (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_view_provide_automatic_options_attr
  - app.test_client (:0)
    Called by: test_view_provide_automatic_options_attr
  - c.open (:0)
    Called by: test_view_provide_automatic_options_attr
  - sorted (:0)
    Called by: test_view_provide_automatic_options_attr
  - Index1.as_view (:0)
    Called by: test_view_provide_automatic_options_attr
  - Index2.as_view (:0)
    Called by: test_view_provide_automatic_options_attr
  - Index3.as_view (:0)
    Called by: test_view_provide_automatic_options_attr

Test Source Code:
  def test_view_provide_automatic_options_attr():
      app = flask.Flask(__name__)
  
      class Index1(flask.views.View):
          provide_automatic_options = False
  
          def dispatch_request(self):
              return "Hello World!"
  
      app.add_url_rule("/", view_func=Index1.as_view("index"))
      c = app.test_client()
      rv = c.open("/", method="OPTIONS")
      assert rv.status_code == 405
  
      app = flask.Flask(__name__)
  
      class Index2(flask.views.View):
          methods = ["OPTIONS"]
          provide_automatic_options = True
  
          def dispatch_request(self):
              return "Hello World!"
  
      app.add_url_rule("/", view_func=Index2.as_view("index"))
      c = app.test_client()
      rv = c.open("/", method="OPTIONS")
      assert sorted(rv.allow) == ["OPTIONS"]
  
      app = flask.Flask(__name__)
  
      class Index3(flask.views.View):
          def dispatch_request(self):
              return "Hello World!"
  
      app.add_url_rule("/", view_func=Index3.as_view("index"))
      c = app.test_client()
      rv = c.open("/", method="OPTIONS")
      assert "OPTIONS" in rv.allow

Assertions:
  - assert rv.status_code == 405
  - assert sorted(rv.allow) == ['OPTIONS']
  - assert 'OPTIONS' in rv.allow

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_view_provide_automatic_options_attr.json

================================================================================
Test: test_implicit_head
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - client.get (:0)
  - client.head (:0)
  - Index.as_view (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_implicit_head
  - client.get (:0)
    Called by: test_implicit_head
  - client.head (:0)
    Called by: test_implicit_head
  - Index.as_view (:0)
    Called by: test_implicit_head

Test Source Code:
  def test_implicit_head(app, client):
      class Index(flask.views.MethodView):
          def get(self):
              return flask.Response("Blub", headers={"X-Method": flask.request.method})
  
      app.add_url_rule("/", view_func=Index.as_view("index"))
      rv = client.get("/")
      assert rv.data == b"Blub"
      assert rv.headers["X-Method"] == "GET"
      rv = client.head("/")
      assert rv.data == b""
      assert rv.headers["X-Method"] == "HEAD"

Assertions:
  - assert rv.data == b'Blub'
  - assert rv.headers['X-Method'] == 'GET'
  - assert rv.data == b''
  - assert rv.headers['X-Method'] == 'HEAD'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_implicit_head.json

================================================================================
Test: test_explicit_head
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - client.get (:0)
  - client.head (:0)
  - Index.as_view (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_explicit_head
  - client.get (:0)
    Called by: test_explicit_head
  - client.head (:0)
    Called by: test_explicit_head
  - Index.as_view (:0)
    Called by: test_explicit_head

Test Source Code:
  def test_explicit_head(app, client):
      class Index(flask.views.MethodView):
          def get(self):
              return "GET"
  
          def head(self):
              return flask.Response("", headers={"X-Method": "HEAD"})
  
      app.add_url_rule("/", view_func=Index.as_view("index"))
      rv = client.get("/")
      assert rv.data == b"GET"
      rv = client.head("/")
      assert rv.data == b""
      assert rv.headers["X-Method"] == "HEAD"

Assertions:
  - assert rv.data == b'GET'
  - assert rv.data == b''
  - assert rv.headers['X-Method'] == 'HEAD'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_explicit_head.json

================================================================================
Test: test_endpoint_override
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - common_test (test_views.py:7)
    Source code:
      def common_test(app):
          c = app.test_client()
      
          assert c.get("/").data == b"GET"
          assert c.post("/").data == b"POST"
          assert c.put("/").status_code == 405
          meths = parse_set_header(c.open("/", method="OPTIONS").headers["Allow"])
          assert sorted(meths) == ["GET", "HEAD", "OPTIONS", "POST"]
  - app.add_url_rule (:0)
  - Index.as_view (:0)
  - Index.as_view (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_endpoint_override
  - common_test (test_views.py:7)
    Called by: test_endpoint_override
  - Index.as_view (:0)
    Called by: test_endpoint_override

Test Source Code:
  def test_endpoint_override(app):
      app.debug = True
  
      class Index(flask.views.View):
          methods = ["GET", "POST"]
  
          def dispatch_request(self):
              return flask.request.method
  
      app.add_url_rule("/", view_func=Index.as_view("index"))
  
      with pytest.raises(AssertionError):
          app.add_url_rule("/", view_func=Index.as_view("index"))
  
      # But these tests should still pass. We just log a warning.
      common_test(app)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_endpoint_override.json

================================================================================
Test: test_methods_var_inheritance
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - ChildView.as_view (:0)
  - client.get (:0)
  - client.open (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_methods_var_inheritance
  - ChildView.as_view (:0)
    Called by: test_methods_var_inheritance
  - client.get (:0)
    Called by: test_methods_var_inheritance
  - client.open (:0)
    Called by: test_methods_var_inheritance

Test Source Code:
  def test_methods_var_inheritance(app, client):
      class BaseView(flask.views.MethodView):
          methods = ["GET", "PROPFIND"]
  
      class ChildView(BaseView):
          def get(self):
              return "GET"
  
          def propfind(self):
              return "PROPFIND"
  
      app.add_url_rule("/", view_func=ChildView.as_view("index"))
  
      assert client.get("/").data == b"GET"
      assert client.open("/", method="PROPFIND").data == b"PROPFIND"
      assert ChildView.methods == {"PROPFIND", "GET"}

Assertions:
  - assert client.get('/').data == b'GET'
  - assert client.open('/', method='PROPFIND').data == b'PROPFIND'
  - assert ChildView.methods == {'PROPFIND', 'GET'}

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_methods_var_inheritance.json

================================================================================
Test: test_multiple_inheritance
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - sorted (:0)
  - GetDeleteView.as_view (:0)
  - client.get (:0)
  - client.delete (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_multiple_inheritance
  - sorted (:0)
    Called by: test_multiple_inheritance
  - GetDeleteView.as_view (:0)
    Called by: test_multiple_inheritance
  - client.get (:0)
    Called by: test_multiple_inheritance
  - client.delete (:0)
    Called by: test_multiple_inheritance

Test Source Code:
  def test_multiple_inheritance(app, client):
      class GetView(flask.views.MethodView):
          def get(self):
              return "GET"
  
      class DeleteView(flask.views.MethodView):
          def delete(self):
              return "DELETE"
  
      class GetDeleteView(GetView, DeleteView):
          pass
  
      app.add_url_rule("/", view_func=GetDeleteView.as_view("index"))
  
      assert client.get("/").data == b"GET"
      assert client.delete("/").data == b"DELETE"
      assert sorted(GetDeleteView.methods) == ["DELETE", "GET"]

Assertions:
  - assert client.get('/').data == b'GET'
  - assert client.delete('/').data == b'DELETE'
  - assert sorted(GetDeleteView.methods) == ['DELETE', 'GET']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_multiple_inheritance.json

================================================================================
Test: test_remove_method_from_parent
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - sorted (:0)
  - View.as_view (:0)
  - client.get (:0)
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_remove_method_from_parent
  - sorted (:0)
    Called by: test_remove_method_from_parent
  - View.as_view (:0)
    Called by: test_remove_method_from_parent
  - client.get (:0)
    Called by: test_remove_method_from_parent
  - client.post (:0)
    Called by: test_remove_method_from_parent

Test Source Code:
  def test_remove_method_from_parent(app, client):
      class GetView(flask.views.MethodView):
          def get(self):
              return "GET"
  
      class OtherView(flask.views.MethodView):
          def post(self):
              return "POST"
  
      class View(GetView, OtherView):
          methods = ["GET"]
  
      app.add_url_rule("/", view_func=View.as_view("index"))
  
      assert client.get("/").data == b"GET"
      assert client.post("/").status_code == 405
      assert sorted(View.methods) == ["GET"]

Assertions:
  - assert client.get('/').data == b'GET'
  - assert client.post('/').status_code == 405
  - assert sorted(View.methods) == ['GET']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_remove_method_from_parent.json

================================================================================
Test: test_init_once
File: __internal__/_data/flask/tests/test_views.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - str (:0)
  - CountInit.as_view (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_init_once
  - str (:0)
    Called by: test_init_once
  - CountInit.as_view (:0)
    Called by: test_init_once
  - client.get (:0)
    Called by: test_init_once

Test Source Code:
  def test_init_once(app, client):
      n = 0
  
      class CountInit(flask.views.View):
          init_every_request = False
  
          def __init__(self):
              nonlocal n
              n += 1
  
          def dispatch_request(self):
              return str(n)
  
      app.add_url_rule("/", view_func=CountInit.as_view("index"))
      assert client.get("/").data == b"1"
      assert client.get("/").data == b"1"

Assertions:
  - assert client.get('/').data == b'1'
  - assert client.get('/').data == b'1'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_init_once.json

================================================================================
Test: test_error_handler_no_match
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - isinstance (:0)
  - app.register_error_handler (:0)
  - str (:0)
  - app.register_error_handler (:0)
  - str (:0)
  - isinstance (:0)
  - app.register_error_handler (:0)
  - str (:0)
  - CustomException (:0)
  - KeyError (:0)
  - CustomException (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - type (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_error_handler_no_match
  - app.route (:0)
    Called by: test_error_handler_no_match
  - isinstance (:0)
    Called by: test_error_handler_no_match
  - app.register_error_handler (:0)
    Called by: test_error_handler_no_match
  - str (:0)
    Called by: test_error_handler_no_match
  - CustomException (:0)
    Called by: test_error_handler_no_match
  - KeyError (:0)
    Called by: test_error_handler_no_match
  - client.get (:0)
    Called by: test_error_handler_no_match
  - type (:0)
    Called by: test_error_handler_no_match

Test Source Code:
  def test_error_handler_no_match(app, client):
      class CustomException(Exception):
          pass
  
      @app.errorhandler(CustomException)
      def custom_exception_handler(e):
          assert isinstance(e, CustomException)
          return "custom"
  
      with pytest.raises(TypeError) as exc_info:
          app.register_error_handler(CustomException(), None)
  
      assert "CustomException() is an instance, not a class." in str(exc_info.value)
  
      with pytest.raises(ValueError) as exc_info:
          app.register_error_handler(list, None)
  
      assert "'list' is not a subclass of Exception." in str(exc_info.value)
  
      @app.errorhandler(500)
      def handle_500(e):
          assert isinstance(e, InternalServerError)
  
          if e.original_exception is not None:
              return f"wrapped {type(e.original_exception).__name__}"
  
          return "direct"
  
      with pytest.raises(ValueError) as exc_info:
          app.register_error_handler(999, None)
  
      assert "Use a subclass of HTTPException" in str(exc_info.value)
  
      @app.route("/custom")
      def custom_test():
          raise CustomException()
  
      @app.route("/keyerror")
      def key_error():
          raise KeyError()
  
      @app.route("/abort")
      def do_abort():
          flask.abort(500)
  
      app.testing = False
      assert client.get("/custom").data == b"custom"
      assert client.get("/keyerror").data == b"wrapped KeyError"
      assert client.get("/abort").data == b"direct"

Assertions:
  - assert 'CustomException() is an instance, not a class.' in str(exc_info.value)
  - assert "'list' is not a subclass of Exception." in str(exc_info.value)
  - assert 'Use a subclass of HTTPException' in str(exc_info.value)
  - assert client.get('/custom').data == b'custom'
  - assert client.get('/keyerror').data == b'wrapped KeyError'
  - assert client.get('/abort').data == b'direct'
  - assert isinstance(e, CustomException)
  - assert isinstance(e, InternalServerError)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_error_handler_no_match.json

================================================================================
Test: test_error_handler_subclass
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_client (:0)
  - isinstance (:0)
  - isinstance (:0)
  - ParentException (:0)
  - ChildExceptionUnregistered (:0)
  - ChildExceptionRegistered (:0)
  - c.get (:0)
  - c.get (:0)
  - c.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_error_handler_subclass
  - app.route (:0)
    Called by: test_error_handler_subclass
  - app.test_client (:0)
    Called by: test_error_handler_subclass
  - isinstance (:0)
    Called by: test_error_handler_subclass
  - ParentException (:0)
    Called by: test_error_handler_subclass
  - ChildExceptionUnregistered (:0)
    Called by: test_error_handler_subclass
  - ChildExceptionRegistered (:0)
    Called by: test_error_handler_subclass
  - c.get (:0)
    Called by: test_error_handler_subclass

Test Source Code:
  def test_error_handler_subclass(app):
      class ParentException(Exception):
          pass
  
      class ChildExceptionUnregistered(ParentException):
          pass
  
      class ChildExceptionRegistered(ParentException):
          pass
  
      @app.errorhandler(ParentException)
      def parent_exception_handler(e):
          assert isinstance(e, ParentException)
          return "parent"
  
      @app.errorhandler(ChildExceptionRegistered)
      def child_exception_handler(e):
          assert isinstance(e, ChildExceptionRegistered)
          return "child-registered"
  
      @app.route("/parent")
      def parent_test():
          raise ParentException()
  
      @app.route("/child-unregistered")
      def unregistered_test():
          raise ChildExceptionUnregistered()
  
      @app.route("/child-registered")
      def registered_test():
          raise ChildExceptionRegistered()
  
      c = app.test_client()
  
      assert c.get("/parent").data == b"parent"
      assert c.get("/child-unregistered").data == b"parent"
      assert c.get("/child-registered").data == b"child-registered"

Assertions:
  - assert c.get('/parent').data == b'parent'
  - assert c.get('/child-unregistered').data == b'parent'
  - assert c.get('/child-registered').data == b'child-registered'
  - assert isinstance(e, ParentException)
  - assert isinstance(e, ChildExceptionRegistered)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_error_handler_subclass.json

================================================================================
Test: test_error_handler_http_subclass
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - app.route (:0)
  - app.test_client (:0)
  - isinstance (:0)
  - isinstance (:0)
  - Forbidden (:0)
  - ForbiddenSubclassRegistered (:0)
  - ForbiddenSubclassUnregistered (:0)
  - c.get (:0)
  - c.get (:0)
  - c.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_error_handler_http_subclass
  - app.route (:0)
    Called by: test_error_handler_http_subclass
  - app.test_client (:0)
    Called by: test_error_handler_http_subclass
  - isinstance (:0)
    Called by: test_error_handler_http_subclass
  - Forbidden (:0)
    Called by: test_error_handler_http_subclass
  - ForbiddenSubclassRegistered (:0)
    Called by: test_error_handler_http_subclass
  - ForbiddenSubclassUnregistered (:0)
    Called by: test_error_handler_http_subclass
  - c.get (:0)
    Called by: test_error_handler_http_subclass

Test Source Code:
  def test_error_handler_http_subclass(app):
      class ForbiddenSubclassRegistered(Forbidden):
          pass
  
      class ForbiddenSubclassUnregistered(Forbidden):
          pass
  
      @app.errorhandler(403)
      def code_exception_handler(e):
          assert isinstance(e, Forbidden)
          return "forbidden"
  
      @app.errorhandler(ForbiddenSubclassRegistered)
      def subclass_exception_handler(e):
          assert isinstance(e, ForbiddenSubclassRegistered)
          return "forbidden-registered"
  
      @app.route("/forbidden")
      def forbidden_test():
          raise Forbidden()
  
      @app.route("/forbidden-registered")
      def registered_test():
          raise ForbiddenSubclassRegistered()
  
      @app.route("/forbidden-unregistered")
      def unregistered_test():
          raise ForbiddenSubclassUnregistered()
  
      c = app.test_client()
  
      assert c.get("/forbidden").data == b"forbidden"
      assert c.get("/forbidden-unregistered").data == b"forbidden"
      assert c.get("/forbidden-registered").data == b"forbidden-registered"

Assertions:
  - assert c.get('/forbidden').data == b'forbidden'
  - assert c.get('/forbidden-unregistered').data == b'forbidden'
  - assert c.get('/forbidden-registered').data == b'forbidden-registered'
  - assert isinstance(e, Forbidden)
  - assert isinstance(e, ForbiddenSubclassRegistered)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_error_handler_http_subclass.json

================================================================================
Test: test_error_handler_blueprint
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - bp.errorhandler (:0)
  - bp.route (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.register_blueprint (:0)
  - app.test_client (:0)
  - InternalServerError (:0)
  - InternalServerError (:0)
  - c.get (:0)
  - c.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.errorhandler (:0)
    Called by: test_error_handler_blueprint
  - bp.route (:0)
    Called by: test_error_handler_blueprint
  - app.errorhandler (:0)
    Called by: test_error_handler_blueprint
  - app.route (:0)
    Called by: test_error_handler_blueprint
  - app.register_blueprint (:0)
    Called by: test_error_handler_blueprint
  - app.test_client (:0)
    Called by: test_error_handler_blueprint
  - InternalServerError (:0)
    Called by: test_error_handler_blueprint
  - c.get (:0)
    Called by: test_error_handler_blueprint

Test Source Code:
  def test_error_handler_blueprint(app):
      bp = flask.Blueprint("bp", __name__)
  
      @bp.errorhandler(500)
      def bp_exception_handler(e):
          return "bp-error"
  
      @bp.route("/error")
      def bp_test():
          raise InternalServerError()
  
      @app.errorhandler(500)
      def app_exception_handler(e):
          return "app-error"
  
      @app.route("/error")
      def app_test():
          raise InternalServerError()
  
      app.register_blueprint(bp, url_prefix="/bp")
  
      c = app.test_client()
  
      assert c.get("/error").data == b"app-error"
      assert c.get("/bp/error").data == b"bp-error"

Assertions:
  - assert c.get('/error').data == b'app-error'
  - assert c.get('/bp/error').data == b'bp-error'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_error_handler_blueprint.json

================================================================================
Test: test_default_error_handler
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - bp.errorhandler (:0)
  - bp.errorhandler (:0)
  - bp.route (:0)
  - bp.route (:0)
  - app.errorhandler (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - app.register_blueprint (:0)
  - app.test_client (:0)
  - isinstance (:0)
  - isinstance (:0)
  - isinstance (:0)
  - NotFound (:0)
  - Forbidden (:0)
  - isinstance (:0)
  - isinstance (:0)
  - isinstance (:0)
  - Forbidden (:0)
  - c.get (:0)
  - c.get (:0)
  - c.get (:0)
  - c.get (:0)
  - c.get (:0)

Methods Actually Called (Dynamic Analysis):
  - bp.errorhandler (:0)
    Called by: test_default_error_handler
  - bp.route (:0)
    Called by: test_default_error_handler
  - app.errorhandler (:0)
    Called by: test_default_error_handler
  - app.route (:0)
    Called by: test_default_error_handler
  - app.register_blueprint (:0)
    Called by: test_default_error_handler
  - app.test_client (:0)
    Called by: test_default_error_handler
  - isinstance (:0)
    Called by: test_default_error_handler
  - NotFound (:0)
    Called by: test_default_error_handler
  - Forbidden (:0)
    Called by: test_default_error_handler
  - c.get (:0)
    Called by: test_default_error_handler

Test Source Code:
  def test_default_error_handler():
      bp = flask.Blueprint("bp", __name__)
  
      @bp.errorhandler(HTTPException)
      def bp_exception_handler(e):
          assert isinstance(e, HTTPException)
          assert isinstance(e, NotFound)
          return "bp-default"
  
      @bp.errorhandler(Forbidden)
      def bp_forbidden_handler(e):
          assert isinstance(e, Forbidden)
          return "bp-forbidden"
  
      @bp.route("/undefined")
      def bp_registered_test():
          raise NotFound()
  
      @bp.route("/forbidden")
      def bp_forbidden_test():
          raise Forbidden()
  
      app = flask.Flask(__name__)
  
      @app.errorhandler(HTTPException)
      def catchall_exception_handler(e):
          assert isinstance(e, HTTPException)
          assert isinstance(e, NotFound)
          return "default"
  
      @app.errorhandler(Forbidden)
      def catchall_forbidden_handler(e):
          assert isinstance(e, Forbidden)
          return "forbidden"
  
      @app.route("/forbidden")
      def forbidden():
          raise Forbidden()
  
      @app.route("/slash/")
      def slash():
          return "slash"
  
      app.register_blueprint(bp, url_prefix="/bp")
  
      c = app.test_client()
      assert c.get("/bp/undefined").data == b"bp-default"
      assert c.get("/bp/forbidden").data == b"bp-forbidden"
      assert c.get("/undefined").data == b"default"
      assert c.get("/forbidden").data == b"forbidden"
      # Don't handle RequestRedirect raised when adding slash.
      assert c.get("/slash", follow_redirects=True).data == b"slash"

Assertions:
  - assert c.get('/bp/undefined').data == b'bp-default'
  - assert c.get('/bp/forbidden').data == b'bp-forbidden'
  - assert c.get('/undefined').data == b'default'
  - assert c.get('/forbidden').data == b'forbidden'
  - assert c.get('/slash', follow_redirects=True).data == b'slash'
  - assert isinstance(e, HTTPException)
  - assert isinstance(e, NotFound)
  - assert isinstance(e, Forbidden)
  - assert isinstance(e, HTTPException)
  - assert isinstance(e, NotFound)
  - assert isinstance(e, Forbidden)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_default_error_handler.json

================================================================================
Test: test_handle_class_or_code
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - isinstance (:0)
  - self.report_error (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_handle_class_or_code
  - isinstance (:0)
    Called by: test_handle_class_or_code
  - self.report_error (:0)
    Called by: test_handle_class_or_code
  - client.get (:0)
    Called by: test_handle_class_or_code

Test Source Code:
  def test_handle_class_or_code(self, app, client, to_handle):
          """``InternalServerError`` and ``500`` are aliases, they should
          have the same behavior. Both should only receive
          ``InternalServerError``, which might wrap another error.
          """
  
          @app.errorhandler(to_handle)
          def handle_500(e):
              assert isinstance(e, InternalServerError)
              return self.report_error(e)
  
          assert client.get("/custom").data == b"wrapped Custom"
          assert client.get("/error").data == b"wrapped KeyError"
          assert client.get("/abort").data == b"direct InternalServerError"
          assert client.get("/raise").data == b"direct InternalServerError"

Assertions:
  - assert client.get('/custom').data == b'wrapped Custom'
  - assert client.get('/error').data == b'wrapped KeyError'
  - assert client.get('/abort').data == b'direct InternalServerError'
  - assert client.get('/raise').data == b'direct InternalServerError'
  - assert isinstance(e, InternalServerError)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_handle_class_or_code.json

================================================================================
Test: test_handle_generic_http
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - isinstance (:0)
  - str (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_handle_generic_http
  - isinstance (:0)
    Called by: test_handle_generic_http
  - str (:0)
    Called by: test_handle_generic_http
  - client.get (:0)
    Called by: test_handle_generic_http

Test Source Code:
  def test_handle_generic_http(self, app, client):
          """``HTTPException`` should only receive ``HTTPException``
          subclasses. It will receive ``404`` routing exceptions.
          """
  
          @app.errorhandler(HTTPException)
          def handle_http(e):
              assert isinstance(e, HTTPException)
              return str(e.code)
  
          assert client.get("/error").data == b"500"
          assert client.get("/abort").data == b"500"
          assert client.get("/not-found").data == b"404"

Assertions:
  - assert client.get('/error').data == b'500'
  - assert client.get('/abort').data == b'500'
  - assert client.get('/not-found').data == b'404'
  - assert isinstance(e, HTTPException)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_handle_generic_http.json

================================================================================
Test: test_handle_generic
File: __internal__/_data/flask/tests/test_user_error_handler.py

Methods Under Test (Static Analysis):
  - app.errorhandler (:0)
  - self.report_error (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.errorhandler (:0)
    Called by: test_handle_generic
  - self.report_error (:0)
    Called by: test_handle_generic
  - client.get (:0)
    Called by: test_handle_generic

Test Source Code:
  def test_handle_generic(self, app, client):
          """Generic ``Exception`` will handle all exceptions directly,
          including ``HTTPExceptions``.
          """
  
          @app.errorhandler(Exception)
          def handle_exception(e):
              return self.report_error(e)
  
          assert client.get("/custom").data == b"direct Custom"
          assert client.get("/error").data == b"direct KeyError"
          assert client.get("/abort").data == b"direct InternalServerError"
          assert client.get("/not-found").data == b"direct NotFound"

Assertions:
  - assert client.get('/custom').data == b'direct Custom'
  - assert client.get('/error').data == b'direct KeyError'
  - assert client.get('/abort').data == b'direct InternalServerError'
  - assert client.get('/not-found').data == b'direct NotFound'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_handle_generic.json

================================================================================
Test: test_custom_converters
File: __internal__/_data/flask/tests/test_converters.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.route (:0)
  - join (:0)
  - app.test_request_context (:0)
  - value.split (:0)
  - join (:0)
  - client.get (:0)
  - Flask.url_for (app.py:1003)
    Source code:
      def url_for(
              self,
              /,
              endpoint: str,
              *,
              _anchor: str | None = None,
              _method: str | None = None,
              _scheme: str | None = None,
              _external: bool | None = None,
              **values: t.Any,
          ) -> str:
              """Generate a URL to the given endpoint with the given values.
      
              This is called by :func:`flask.url_for`, and can be called
              directly as well.
      
              An *endpoint* is the name of a URL rule, usually added with
              :meth:`@app.route() <route>`, and usually the same name as the
              view function. A route defined in a :class:`~flask.Blueprint`
              will prepend the blueprint's name separated by a ``.`` to the
              endpoint.
      
              In some cases, such as email messages, you want URLs to include
              the scheme and domain, like ``https://example.com/hello``. When
              not in an active request, URLs will be external by default, but
              this requires setting :data:`SERVER_NAME` so Flask knows what
              domain to use. :data:`APPLICATION_ROOT` and
              :data:`PREFERRED_URL_SCHEME` should also be configured as
              needed. This config is only used when not in an active request.
      
              Functions can be decorated with :meth:`url_defaults` to modify
              keyword arguments before the URL is built.
      
              If building fails for some reason, such as an unknown endpoint
              or incorrect values, the app's :meth:`handle_url_build_error`
              method is called. If that returns a string, that is returned,
              otherwise a :exc:`~werkzeug.routing.BuildError` is raised.
      
              :param endpoint: The endpoint name associated with the URL to
                  generate. If this starts with a ``.``, the current blueprint
                  name (if any) will be used.
              :param _anchor: If given, append this as ``#anchor`` to the URL.
              :param _method: If given, generate the URL associated with this
                  method for the endpoint.
              :param _scheme: If given, the URL will have this scheme if it
                  is external.
              :param _external: If given, prefer the URL to be internal
                  (False) or require it to be external (True). External URLs
                  include the scheme and domain. When not in an active
                  request, URLs are external by default.
              :param values: Values to use for the variable parts of the URL
                  rule. Unknown keys are appended as query string arguments,
                  like ``?a=b&c=d``.
      
              .. versionadded:: 2.2
                  Moved from ``flask.url_for``, which calls this method.
              """
              req_ctx = _cv_request.get(None)
      
              if req_ctx is not None:
                  url_adapter = req_ctx.url_adapter
                  blueprint_name = req_ctx.request.blueprint
      
                  # If the endpoint starts with "." and the request matches a
                  # blueprint, the endpoint is relative to the blueprint.
                  if endpoint[:1] == ".":
                      if blueprint_name is not None:
                          endpoint = f"{blueprint_name}{endpoint}"
                      else:
                          endpoint = endpoint[1:]
      
                  # When in a request, generate a URL without scheme and
                  # domain by default, unless a scheme is given.
                  if _external is None:
                      _external = _scheme is not None
              else:
                  app_ctx = _cv_app.get(None)
      
                  # If called by helpers.url_for, an app context is active,
                  # use its url_adapter. Otherwise, app.url_for was called
                  # directly, build an adapter.
                  if app_ctx is not None:
                      url_adapter = app_ctx.url_adapter
                  else:
                      url_adapter = self.create_url_adapter(None)
      
                  if url_adapter is None:
                      raise RuntimeError(
                          "Unable to build URLs outside an active request"
                          " without 'SERVER_NAME' configured. Also configure"
                          " 'APPLICATION_ROOT' and 'PREFERRED_URL_SCHEME' as"
                          " needed."
                      )
      
                  # When outside a request, generate a URL with scheme and
                  # domain by default.
                  if _external is None:
                      _external = True
      
              # It is an error to set _scheme when _external=False, in order
              # to avoid accidental insecure URLs.
              if _scheme is not None and not _external:
                  raise ValueError("When specifying '_scheme', '_external' must be True.")
      
              self.inject_url_defaults(endpoint, values)
      
              try:
                  rv = url_adapter.build(  # type: ignore[union-attr]
                      endpoint,
                      values,
                      method=_method,
                      url_scheme=_scheme,
                      force_external=_external,
                  )
              except BuildError as error:
                  values.update(
                      _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external
                  )
                  return self.handle_url_build_error(error, endpoint, values)
      
              if _anchor is not None:
                  _anchor = _url_quote(_anchor, safe="%!#$&'()*+,/:;=?@")
                  rv = f"{rv}#{_anchor}"
      
              return rv
  - super (:0)
  - base_to_url (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_custom_converters
  - app.route (:0)
    Called by: test_custom_converters
  - join (:0)
    Called by: test_custom_converters
  - value.split (:0)
    Called by: test_custom_converters
  - client.get (:0)
    Called by: test_custom_converters
  - Flask.url_for (app.py:1003)
    Called by: test_custom_converters
  - super (:0)
    Called by: test_custom_converters
  - base_to_url (:0)
    Called by: test_custom_converters

Test Source Code:
  def test_custom_converters(app, client):
      class ListConverter(BaseConverter):
          def to_python(self, value):
              return value.split(",")
  
          def to_url(self, value):
              base_to_url = super().to_url
              return ",".join(base_to_url(x) for x in value)
  
      app.url_map.converters["list"] = ListConverter
  
      @app.route("/<list:args>")
      def index(args):
          return "|".join(args)
  
      assert client.get("/1,2,3").data == b"1|2|3"
  
      with app.test_request_context():
          assert url_for("index", args=[4, 5, 6]) == "/4,5,6"

Assertions:
  - assert client.get('/1,2,3').data == b'1|2|3'
  - assert url_for('index', args=[4, 5, 6]) == '/4,5,6'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_custom_converters.json

================================================================================
Test: test_context_available
File: __internal__/_data/flask/tests/test_converters.py

Methods Under Test (Static Analysis):
  - app.get (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.get (:0)
    Called by: test_context_available
  - client.get (:0)
    Called by: test_context_available

Test Source Code:
  def test_context_available(app, client):
      class ContextConverter(BaseConverter):
          def to_python(self, value):
              assert request is not None
              assert session is not None
              return value
  
      app.url_map.converters["ctx"] = ContextConverter
  
      @app.get("/<ctx:name>")
      def index(name):
          return name
  
      assert client.get("/admin").data == b"admin"

Assertions:
  - assert client.get('/admin').data == b'admin'
  - assert request is not None
  - assert session is not None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_context_available.json

================================================================================
Test: test_aborting
File: __internal__/_data/flask/tests/test_regression.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.errorhandler (:0)
  - app.route (:0)
  - app.route (:0)
  - str (:0)
  - Foo (:0)
  - app.test_client (:0)
  - c.get (:0)
  - rv.headers.rpartition (:0)
  - c.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_aborting
  - app.errorhandler (:0)
    Called by: test_aborting
  - app.route (:0)
    Called by: test_aborting
  - str (:0)
    Called by: test_aborting
  - Foo (:0)
    Called by: test_aborting
  - c.get (:0)
    Called by: test_aborting
  - rv.headers.rpartition (:0)
    Called by: test_aborting

Test Source Code:
  def test_aborting(app):
      class Foo(Exception):
          whatever = 42
  
      @app.errorhandler(Foo)
      def handle_foo(e):
          return str(e.whatever)
  
      @app.route("/")
      def index():
          raise flask.abort(flask.redirect(flask.url_for("test")))
  
      @app.route("/test")
      def test():
          raise Foo()
  
      with app.test_client() as c:
          rv = c.get("/")
          location_parts = rv.headers["Location"].rpartition("/")
  
          if location_parts[0]:
              # For older Werkzeug that used absolute redirects.
              assert location_parts[0] == "http://localhost"
  
          assert location_parts[2] == "test"
          rv = c.get("/test")
          assert rv.data == b"42"

Assertions:
  - assert location_parts[2] == 'test'
  - assert rv.data == b'42'
  - assert location_parts[0] == 'http://localhost'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_aborting.json

================================================================================
Test: test_basic_url_generation
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.route (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_basic_url_generation
  - app.route (:0)
    Called by: test_basic_url_generation

Test Source Code:
  def test_basic_url_generation(app):
      app.config["SERVER_NAME"] = "localhost"
      app.config["PREFERRED_URL_SCHEME"] = "https"
  
      @app.route("/")
      def index():
          pass
  
      with app.app_context():
          rv = flask.url_for("index")
          assert rv == "https://localhost/"

Assertions:
  - assert rv == 'https://localhost/'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_basic_url_generation.json

================================================================================
Test: test_url_generation_requires_server_name
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_url_generation_requires_server_name

Test Source Code:
  def test_url_generation_requires_server_name(app):
      with app.app_context():
          with pytest.raises(RuntimeError):
              flask.url_for("index")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_generation_requires_server_name.json

================================================================================
Test: test_url_generation_without_context_fails
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_url_generation_without_context_fails():
      with pytest.raises(RuntimeError):
          flask.url_for("index")

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_url_generation_without_context_fails.json

================================================================================
Test: test_request_context_means_app_context
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.test_request_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_request_context_means_app_context

Test Source Code:
  def test_request_context_means_app_context(app):
      with app.test_request_context():
          assert flask.current_app._get_current_object() is app
      assert not flask.current_app

Assertions:
  - assert not flask.current_app
  - assert flask.current_app._get_current_object() is app

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_context_means_app_context.json

================================================================================
Test: test_app_context_provides_current_app
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_app_context_provides_current_app

Test Source Code:
  def test_app_context_provides_current_app(app):
      with app.app_context():
          assert flask.current_app._get_current_object() is app
      assert not flask.current_app

Assertions:
  - assert not flask.current_app
  - assert flask.current_app._get_current_object() is app

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_context_provides_current_app.json

================================================================================
Test: test_app_tearing_down
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - cleanup_stuff.append (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_app_tearing_down
  - cleanup_stuff.append (:0)
    Called by: test_app_tearing_down

Test Source Code:
  def test_app_tearing_down(app):
      cleanup_stuff = []
  
      @app.teardown_appcontext
      def cleanup(exception):
          cleanup_stuff.append(exception)
  
      with app.app_context():
          pass
  
      assert cleanup_stuff == [None]

Assertions:
  - assert cleanup_stuff == [None]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_tearing_down.json

================================================================================
Test: test_app_tearing_down_with_previous_exception
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - cleanup_stuff.append (:0)
  - Exception (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_app_tearing_down_with_previous_exception
  - cleanup_stuff.append (:0)
    Called by: test_app_tearing_down_with_previous_exception
  - Exception (:0)
    Called by: test_app_tearing_down_with_previous_exception

Test Source Code:
  def test_app_tearing_down_with_previous_exception(app):
      cleanup_stuff = []
  
      @app.teardown_appcontext
      def cleanup(exception):
          cleanup_stuff.append(exception)
  
      try:
          raise Exception("dummy")
      except Exception:
          pass
  
      with app.app_context():
          pass
  
      assert cleanup_stuff == [None]

Assertions:
  - assert cleanup_stuff == [None]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_tearing_down_with_previous_exception.json

================================================================================
Test: test_app_tearing_down_with_handled_exception_by_except_block
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - cleanup_stuff.append (:0)
  - app.app_context (:0)
  - Exception (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_except_block
  - cleanup_stuff.append (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_except_block
  - Exception (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_except_block

Test Source Code:
  def test_app_tearing_down_with_handled_exception_by_except_block(app):
      cleanup_stuff = []
  
      @app.teardown_appcontext
      def cleanup(exception):
          cleanup_stuff.append(exception)
  
      with app.app_context():
          try:
              raise Exception("dummy")
          except Exception:
              pass
  
      assert cleanup_stuff == [None]

Assertions:
  - assert cleanup_stuff == [None]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_tearing_down_with_handled_exception_by_except_block.json

================================================================================
Test: test_app_tearing_down_with_handled_exception_by_app_handler
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.route (:0)
  - app.errorhandler (:0)
  - cleanup_stuff.append (:0)
  - Exception (:0)
  - app.app_context (:0)
  - client.get (:0)
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_app_handler
  - app.route (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_app_handler
  - app.errorhandler (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_app_handler
  - cleanup_stuff.append (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_app_handler
  - Exception (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_app_handler
  - client.get (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_app_handler
  - str (:0)
    Called by: test_app_tearing_down_with_handled_exception_by_app_handler

Test Source Code:
  def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):
      app.config["PROPAGATE_EXCEPTIONS"] = True
      cleanup_stuff = []
  
      @app.teardown_appcontext
      def cleanup(exception):
          cleanup_stuff.append(exception)
  
      @app.route("/")
      def index():
          raise Exception("dummy")
  
      @app.errorhandler(Exception)
      def handler(f):
          return flask.jsonify(str(f))
  
      with app.app_context():
          client.get("/")
  
      assert cleanup_stuff == [None]

Assertions:
  - assert cleanup_stuff == [None]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_tearing_down_with_handled_exception_by_app_handler.json

================================================================================
Test: test_app_tearing_down_with_unhandled_exception
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.app_context (:0)
  - isinstance (:0)
  - cleanup_stuff.append (:0)
  - ValueError (:0)
  - len (:0)
  - str (:0)
  - app.app_context (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_app_tearing_down_with_unhandled_exception
  - app.app_context (:0)
    Called by: test_app_tearing_down_with_unhandled_exception
  - isinstance (:0)
    Called by: test_app_tearing_down_with_unhandled_exception
  - cleanup_stuff.append (:0)
    Called by: test_app_tearing_down_with_unhandled_exception
  - ValueError (:0)
    Called by: test_app_tearing_down_with_unhandled_exception
  - len (:0)
    Called by: test_app_tearing_down_with_unhandled_exception
  - str (:0)
    Called by: test_app_tearing_down_with_unhandled_exception
  - client.get (:0)
    Called by: test_app_tearing_down_with_unhandled_exception

Test Source Code:
  def test_app_tearing_down_with_unhandled_exception(app, client):
      app.config["PROPAGATE_EXCEPTIONS"] = True
      cleanup_stuff = []
  
      @app.teardown_appcontext
      def cleanup(exception):
          cleanup_stuff.append(exception)
  
      @app.route("/")
      def index():
          raise ValueError("dummy")
  
      with pytest.raises(ValueError, match="dummy"):
          with app.app_context():
              client.get("/")
  
      assert len(cleanup_stuff) == 1
      assert isinstance(cleanup_stuff[0], ValueError)
      assert str(cleanup_stuff[0]) == "dummy"

Assertions:
  - assert len(cleanup_stuff) == 1
  - assert isinstance(cleanup_stuff[0], ValueError)
  - assert str(cleanup_stuff[0]) == 'dummy'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_tearing_down_with_unhandled_exception.json

================================================================================
Test: test_app_ctx_globals_methods
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - list (:0)
  - repr (:0)

Methods Actually Called (Dynamic Analysis):
  - list (:0)
    Called by: test_app_ctx_globals_methods
  - repr (:0)
    Called by: test_app_ctx_globals_methods

Test Source Code:
  def test_app_ctx_globals_methods(app, app_ctx):
      # get
      assert flask.g.get("foo") is None
      assert flask.g.get("foo", "bar") == "bar"
      # __contains__
      assert "foo" not in flask.g
      flask.g.foo = "bar"
      assert "foo" in flask.g
      # setdefault
      flask.g.setdefault("bar", "the cake is a lie")
      flask.g.setdefault("bar", "hello world")
      assert flask.g.bar == "the cake is a lie"
      # pop
      assert flask.g.pop("bar") == "the cake is a lie"
      with pytest.raises(KeyError):
          flask.g.pop("bar")
      assert flask.g.pop("bar", "more cake") == "more cake"
      # __iter__
      assert list(flask.g) == ["foo"]
      # __repr__
      assert repr(flask.g) == "<flask.g of 'flask_test'>"

Assertions:
  - assert flask.g.get('foo') is None
  - assert flask.g.get('foo', 'bar') == 'bar'
  - assert 'foo' not in flask.g
  - assert 'foo' in flask.g
  - assert flask.g.bar == 'the cake is a lie'
  - assert flask.g.pop('bar') == 'the cake is a lie'
  - assert flask.g.pop('bar', 'more cake') == 'more cake'
  - assert list(flask.g) == ['foo']
  - assert repr(flask.g) == "<flask.g of 'flask_test'>"

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_ctx_globals_methods.json

================================================================================
Test: test_custom_app_ctx_globals_class
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - app.app_context (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_custom_app_ctx_globals_class

Test Source Code:
  def test_custom_app_ctx_globals_class(app):
      class CustomRequestGlobals:
          def __init__(self):
              self.spam = "eggs"
  
      app.app_ctx_globals_class = CustomRequestGlobals
      with app.app_context():
          assert flask.render_template_string("{{ g.spam }}") == "eggs"

Assertions:
  - assert flask.render_template_string('{{ g.spam }}') == 'eggs'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_custom_app_ctx_globals_class.json

================================================================================
Test: test_context_refcounts
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - called.append (:0)
  - called.append (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_context_refcounts
  - client.get (:0)
    Called by: test_context_refcounts
  - called.append (:0)
    Called by: test_context_refcounts

Test Source Code:
  def test_context_refcounts(app, client):
      called = []
  
      @app.teardown_request
      def teardown_req(error=None):
          called.append("request")
  
      @app.teardown_appcontext
      def teardown_app(error=None):
          called.append("app")
  
      @app.route("/")
      def index():
          with app_ctx:
              with request_ctx:
                  pass
  
          assert flask.request.environ["werkzeug.request"] is not None
          return ""
  
      res = client.get("/")
      assert res.status_code == 200
      assert res.data == b""
      assert called == ["request", "app"]

Assertions:
  - assert res.status_code == 200
  - assert res.data == b''
  - assert called == ['request', 'app']
  - assert flask.request.environ['werkzeug.request'] is not None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_context_refcounts.json

================================================================================
Test: test_clean_pop
File: __internal__/_data/flask/tests/test_appctx.py

Methods Under Test (Static Analysis):
  - app.app_context (:0)
  - called.append (:0)
  - app.app_context (:0)
  - called.append (:0)

Methods Actually Called (Dynamic Analysis):
  - app.app_context (:0)
    Called by: test_clean_pop
  - called.append (:0)
    Called by: test_clean_pop

Test Source Code:
  def test_clean_pop(app):
      app.testing = False
      called = []
  
      @app.teardown_request
      def teardown_req(error=None):
          raise ZeroDivisionError
  
      @app.teardown_appcontext
      def teardown_app(error=None):
          called.append("TEARDOWN")
  
      with app.app_context():
          called.append(flask.current_app.name)
  
      assert called == ["flask_test", "TEARDOWN"]
      assert not flask.current_app

Assertions:
  - assert called == ['flask_test', 'TEARDOWN']
  - assert not flask.current_app

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_clean_pop.json

================================================================================
Test: test_bad_request_debug_message
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_bad_request_debug_message
  - client.post (:0)
    Called by: test_bad_request_debug_message

Test Source Code:
  def test_bad_request_debug_message(app, client, debug):
      app.config["DEBUG"] = debug
      app.config["TRAP_BAD_REQUEST_ERRORS"] = False
  
      @app.route("/json", methods=["POST"])
      def post_json():
          flask.request.get_json()
          return None
  
      rv = client.post("/json", data=None, content_type="application/json")
      assert rv.status_code == 400
      contains = b"Failed to decode JSON object" in rv.data
      assert contains == debug

Assertions:
  - assert rv.status_code == 400
  - assert contains == debug

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_bad_request_debug_message.json

================================================================================
Test: test_json_bad_requests
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.post (:0)
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_json_bad_requests
  - client.post (:0)
    Called by: test_json_bad_requests
  - str (:0)
    Called by: test_json_bad_requests

Test Source Code:
  def test_json_bad_requests(app, client):
      @app.route("/json", methods=["POST"])
      def return_json():
          return flask.jsonify(foo=str(flask.request.get_json()))
  
      rv = client.post("/json", data="malformed", content_type="application/json")
      assert rv.status_code == 400

Assertions:
  - assert rv.status_code == 400

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_bad_requests.json

================================================================================
Test: test_json_custom_mimetypes
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.post (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_json_custom_mimetypes
  - client.post (:0)
    Called by: test_json_custom_mimetypes

Test Source Code:
  def test_json_custom_mimetypes(app, client):
      @app.route("/json", methods=["POST"])
      def return_json():
          return flask.request.get_json()
  
      rv = client.post("/json", data='"foo"', content_type="application/x+json")
      assert rv.data == b"foo"

Assertions:
  - assert rv.data == b'foo'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_custom_mimetypes.json

================================================================================
Test: test_json_as_unicode
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.json.dumps (:0)

Methods Actually Called (Dynamic Analysis):
  - app.json.dumps (:0)
    Called by: test_json_as_unicode

Test Source Code:
  def test_json_as_unicode(test_value, expected, app, app_ctx):
      app.json.ensure_ascii = test_value
      rv = app.json.dumps("\N{SNOWMAN}")
      assert rv == expected

Assertions:
  - assert rv == expected

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_as_unicode.json

================================================================================
Test: test_json_dump_to_file
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - out.seek (:0)

Methods Actually Called (Dynamic Analysis):
  - out.seek (:0)
    Called by: test_json_dump_to_file

Test Source Code:
  def test_json_dump_to_file(app, app_ctx):
      test_data = {"name": "Flask"}
      out = io.StringIO()
  
      flask.json.dump(test_data, out)
      out.seek(0)
      rv = flask.json.load(out)
      assert rv == test_data

Assertions:
  - assert rv == test_data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_dump_to_file.json

================================================================================
Test: test_jsonify_basic_types
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_jsonify_basic_types
  - client.get (:0)
    Called by: test_jsonify_basic_types

Test Source Code:
  def test_jsonify_basic_types(test_value, app, client):
      url = "/jsonify_basic_types"
      app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
      rv = client.get(url)
      assert rv.mimetype == "application/json"
      assert flask.json.loads(rv.data) == test_value

Assertions:
  - assert rv.mimetype == 'application/json'
  - assert flask.json.loads(rv.data) == test_value

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_basic_types.json

================================================================================
Test: test_jsonify_dicts
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_jsonify_dicts
  - client.get (:0)
    Called by: test_jsonify_dicts

Test Source Code:
  def test_jsonify_dicts(app, client):
      d = {
          "a": 0,
          "b": 23,
          "c": 3.14,
          "d": "t",
          "e": "Hi",
          "f": True,
          "g": False,
          "h": ["test list", 10, False],
          "i": {"test": "dict"},
      }
  
      @app.route("/kw")
      def return_kwargs():
          return flask.jsonify(**d)
  
      @app.route("/dict")
      def return_dict():
          return flask.jsonify(d)
  
      for url in "/kw", "/dict":
          rv = client.get(url)
          assert rv.mimetype == "application/json"
          assert flask.json.loads(rv.data) == d

Assertions:
  - assert rv.mimetype == 'application/json'
  - assert flask.json.loads(rv.data) == d

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_dicts.json

================================================================================
Test: test_jsonify_arrays
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_jsonify_arrays
  - client.get (:0)
    Called by: test_jsonify_arrays

Test Source Code:
  def test_jsonify_arrays(app, client):
      """Test jsonify of lists and args unpacking."""
      a_list = [
          0,
          42,
          3.14,
          "t",
          "hello",
          True,
          False,
          ["test list", 2, False],
          {"test": "dict"},
      ]
  
      @app.route("/args_unpack")
      def return_args_unpack():
          return flask.jsonify(*a_list)
  
      @app.route("/array")
      def return_array():
          return flask.jsonify(a_list)
  
      for url in "/args_unpack", "/array":
          rv = client.get(url)
          assert rv.mimetype == "application/json"
          assert flask.json.loads(rv.data) == a_list

Assertions:
  - assert rv.mimetype == 'application/json'
  - assert flask.json.loads(rv.data) == a_list

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_arrays.json

================================================================================
Test: test_jsonify_datetime
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - http_date (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_jsonify_datetime
  - client.get (:0)
    Called by: test_jsonify_datetime
  - http_date (:0)
    Called by: test_jsonify_datetime

Test Source Code:
  def test_jsonify_datetime(app, client, value):
      @app.route("/")
      def index():
          return flask.jsonify(value=value)
  
      r = client.get()
      assert r.json["value"] == http_date(value)

Assertions:
  - assert r.json['value'] == http_date(value)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_datetime.json

================================================================================
Test: test_jsonify_aware_datetimes
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - FixedOffset (:0)
  - FixedOffset (:0)
  - dt.astimezone.strftime (:0)
  - dt.astimezone (:0)

Methods Actually Called (Dynamic Analysis):
  - FixedOffset (:0)
    Called by: test_jsonify_aware_datetimes
  - dt.astimezone.strftime (:0)
    Called by: test_jsonify_aware_datetimes
  - dt.astimezone (:0)
    Called by: test_jsonify_aware_datetimes

Test Source Code:
  def test_jsonify_aware_datetimes(tz):
      """Test if aware datetime.datetime objects are converted into GMT."""
      tzinfo = FixedOffset(hours=tz[1], name=tz[0])
      dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)
      gmt = FixedOffset(hours=0, name="GMT")
      expected = dt.astimezone(gmt).strftime('"%a, %d %b %Y %H:%M:%S %Z"')
      assert flask.json.dumps(dt) == expected

Assertions:
  - assert flask.json.dumps(dt) == expected

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_aware_datetimes.json

================================================================================
Test: test_jsonify_uuid_types
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.add_url_rule (:0)
  - client.get (:0)
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_url_rule (:0)
    Called by: test_jsonify_uuid_types
  - client.get (:0)
    Called by: test_jsonify_uuid_types
  - str (:0)
    Called by: test_jsonify_uuid_types

Test Source Code:
  def test_jsonify_uuid_types(app, client):
      """Test jsonify with uuid.UUID types"""
  
      test_uuid = uuid.UUID(bytes=b"\xde\xad\xbe\xef" * 4)
      url = "/uuid_test"
      app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))
  
      rv = client.get(url)
  
      rv_x = flask.json.loads(rv.data)["x"]
      assert rv_x == str(test_uuid)
      rv_uuid = uuid.UUID(rv_x)
      assert rv_uuid == test_uuid

Assertions:
  - assert rv_x == str(test_uuid)
  - assert rv_uuid == test_uuid

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_jsonify_uuid_types.json

================================================================================
Test: test_json_decimal
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_json_decimal():
      rv = flask.json.dumps(decimal.Decimal("0.003"))
      assert rv == '"0.003"'

Assertions:
  - assert rv == '"0.003"'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_decimal.json

================================================================================
Test: test_json_attr
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.post (:0)
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_json_attr
  - client.post (:0)
    Called by: test_json_attr
  - str (:0)
    Called by: test_json_attr

Test Source Code:
  def test_json_attr(app, client):
      @app.route("/add", methods=["POST"])
      def add():
          json = flask.request.get_json()
          return str(json["a"] + json["b"])
  
      rv = client.post(
          "/add",
          data=flask.json.dumps({"a": 1, "b": 2}),
          content_type="application/json",
      )
      assert rv.data == b"3"

Assertions:
  - assert rv.data == b'3'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_attr.json

================================================================================
Test: test_tojson_filter
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_tojson_filter(app, req_ctx):
      # The tojson filter is tested in Jinja, this confirms that it's
      # using Flask's dumps.
      rv = flask.render_template_string(
          "const data = {{ data|tojson }};",
          data={"name": "</script>", "time": datetime.datetime(2021, 2, 1, 7, 15)},
      )
      assert rv == (
          'const data = {"name": "\\u003c/script\\u003e",'
          ' "time": "Mon, 01 Feb 2021 07:15:00 GMT"};'
      )

Assertions:
  - assert rv == 'const data = {"name": "\\u003c/script\\u003e", "time": "Mon, 01 Feb 2021 07:15:00 GMT"};'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_tojson_filter.json

================================================================================
Test: test_json_customization
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - CustomProvider (:0)
  - app.route (:0)
  - client.post (:0)
  - isinstance (:0)
  - DefaultJSONProvider.default (:0)
  - kwargs.setdefault (:0)
  - super.loads (:0)
  - X (:0)
  - len (:0)
  - super (:0)

Methods Actually Called (Dynamic Analysis):
  - CustomProvider (:0)
    Called by: test_json_customization
  - app.route (:0)
    Called by: test_json_customization
  - client.post (:0)
    Called by: test_json_customization
  - isinstance (:0)
    Called by: test_json_customization
  - DefaultJSONProvider.default (:0)
    Called by: test_json_customization
  - kwargs.setdefault (:0)
    Called by: test_json_customization
  - super.loads (:0)
    Called by: test_json_customization
  - X (:0)
    Called by: test_json_customization
  - len (:0)
    Called by: test_json_customization
  - super (:0)
    Called by: test_json_customization

Test Source Code:
  def test_json_customization(app, client):
      class X:  # noqa: B903, for Python2 compatibility
          def __init__(self, val):
              self.val = val
  
      def default(o):
          if isinstance(o, X):
              return f"<{o.val}>"
  
          return DefaultJSONProvider.default(o)
  
      class CustomProvider(DefaultJSONProvider):
          def object_hook(self, obj):
              if len(obj) == 1 and "_foo" in obj:
                  return X(obj["_foo"])
  
              return obj
  
          def loads(self, s, **kwargs):
              kwargs.setdefault("object_hook", self.object_hook)
              return super().loads(s, **kwargs)
  
      app.json = CustomProvider(app)
      app.json.default = default
  
      @app.route("/", methods=["POST"])
      def index():
          return flask.json.dumps(flask.request.get_json()["x"])
  
      rv = client.post(
          "/",
          data=flask.json.dumps({"x": {"_foo": 42}}),
          content_type="application/json",
      )
      assert rv.data == b'"<42>"'

Assertions:
  - assert rv.data == b'"<42>"'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_customization.json

================================================================================
Test: test_json_key_sorting
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - dict.fromkeys (:0)
  - app.route (:0)
  - client.get (:0)
  - range (:0)
  - x.strip (:0)
  - rv.data.strip.decode.splitlines (:0)
  - rv.data.strip.decode (:0)
  - rv.data.strip (:0)

Methods Actually Called (Dynamic Analysis):
  - dict.fromkeys (:0)
    Called by: test_json_key_sorting
  - app.route (:0)
    Called by: test_json_key_sorting
  - client.get (:0)
    Called by: test_json_key_sorting
  - range (:0)
    Called by: test_json_key_sorting
  - x.strip (:0)
    Called by: test_json_key_sorting
  - rv.data.strip.decode.splitlines (:0)
    Called by: test_json_key_sorting
  - rv.data.strip.decode (:0)
    Called by: test_json_key_sorting
  - rv.data.strip (:0)
    Called by: test_json_key_sorting

Test Source Code:
  def test_json_key_sorting(app, client):
      app.debug = True
      assert app.json.sort_keys
      d = dict.fromkeys(range(20), "foo")
  
      @app.route("/")
      def index():
          return flask.jsonify(values=d)
  
      rv = client.get("/")
      lines = [x.strip() for x in rv.data.strip().decode("utf-8").splitlines()]
      sorted_by_str = [
          "{",
          '"values": {',
          '"0": "foo",',
          '"1": "foo",',
          '"10": "foo",',
          '"11": "foo",',
          '"12": "foo",',
          '"13": "foo",',
          '"14": "foo",',
          '"15": "foo",',
          '"16": "foo",',
          '"17": "foo",',
          '"18": "foo",',
          '"19": "foo",',
          '"2": "foo",',
          '"3": "foo",',
          '"4": "foo",',
          '"5": "foo",',
          '"6": "foo",',
          '"7": "foo",',
          '"8": "foo",',
          '"9": "foo"',
          "}",
          "}",
      ]
      sorted_by_int = [
          "{",
          '"values": {',
          '"0": "foo",',
          '"1": "foo",',
          '"2": "foo",',
          '"3": "foo",',
          '"4": "foo",',
          '"5": "foo",',
          '"6": "foo",',
          '"7": "foo",',
          '"8": "foo",',
          '"9": "foo",',
          '"10": "foo",',
          '"11": "foo",',
          '"12": "foo",',
          '"13": "foo",',
          '"14": "foo",',
          '"15": "foo",',
          '"16": "foo",',
          '"17": "foo",',
          '"18": "foo",',
          '"19": "foo"',
          "}",
          "}",
      ]
  
      try:
          assert lines == sorted_by_int
      except AssertionError:
          assert lines == sorted_by_str

Assertions:
  - assert app.json.sort_keys
  - assert lines == sorted_by_int
  - assert lines == sorted_by_str

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_json_key_sorting.json

================================================================================
Test: test_html_method
File: __internal__/_data/flask/tests/test_json.py

Methods Under Test (Static Analysis):
  - ObjectWithHTML (:0)

Methods Actually Called (Dynamic Analysis):
  - ObjectWithHTML (:0)
    Called by: test_html_method

Test Source Code:
  def test_html_method():
      class ObjectWithHTML:
          def __html__(self):
              return "<p>test</p>"
  
      result = json.dumps(ObjectWithHTML())
      assert result == '"<p>test</p>"'

Assertions:
  - assert result == '"<p>test</p>"'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_html_method.json

================================================================================
Test: test_logger
File: __internal__/_data/flask/tests/test_logging.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_logger(app):
      assert app.logger.name == "flask_test"
      assert app.logger.level == logging.NOTSET
      assert app.logger.handlers == [default_handler]

Assertions:
  - assert app.logger.name == 'flask_test'
  - assert app.logger.level == logging.NOTSET
  - assert app.logger.handlers == [default_handler]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_logger.json

================================================================================
Test: test_logger_debug
File: __internal__/_data/flask/tests/test_logging.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_logger_debug(app):
      app.debug = True
      assert app.logger.level == logging.DEBUG
      assert app.logger.handlers == [default_handler]

Assertions:
  - assert app.logger.level == logging.DEBUG
  - assert app.logger.handlers == [default_handler]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_logger_debug.json

================================================================================
Test: test_existing_handler
File: __internal__/_data/flask/tests/test_logging.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_existing_handler(app):
      logging.root.addHandler(logging.StreamHandler())
      assert app.logger.level == logging.NOTSET
      assert not app.logger.handlers

Assertions:
  - assert app.logger.level == logging.NOTSET
  - assert not app.logger.handlers

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_existing_handler.json

================================================================================
Test: test_wsgi_errors_stream
File: __internal__/_data/flask/tests/test_logging.py

Methods Under Test (Static Analysis):
  - app.test_request_context (:0)
  - app.route (:0)
  - StringIO (:0)
  - client.get (:0)
  - app.logger.error (:0)
  - stream.getvalue (:0)
  - wsgi_errors_stream._get_current_object (:0)
  - app.test_request_context (:0)
  - wsgi_errors_stream._get_current_object (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_request_context (:0)
    Called by: test_wsgi_errors_stream
  - app.route (:0)
    Called by: test_wsgi_errors_stream
  - StringIO (:0)
    Called by: test_wsgi_errors_stream
  - client.get (:0)
    Called by: test_wsgi_errors_stream
  - app.logger.error (:0)
    Called by: test_wsgi_errors_stream
  - stream.getvalue (:0)
    Called by: test_wsgi_errors_stream
  - wsgi_errors_stream._get_current_object (:0)
    Called by: test_wsgi_errors_stream

Test Source Code:
  def test_wsgi_errors_stream(app, client):
      @app.route("/")
      def index():
          app.logger.error("test")
          return ""
  
      stream = StringIO()
      client.get("/", errors_stream=stream)
      assert "ERROR in test_logging: test" in stream.getvalue()
  
      assert wsgi_errors_stream._get_current_object() is sys.stderr
  
      with app.test_request_context(errors_stream=stream):
          assert wsgi_errors_stream._get_current_object() is stream

Assertions:
  - assert 'ERROR in test_logging: test' in stream.getvalue()
  - assert wsgi_errors_stream._get_current_object() is sys.stderr
  - assert wsgi_errors_stream._get_current_object() is stream

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_wsgi_errors_stream.json

================================================================================
Test: test_has_level_handler
File: __internal__/_data/flask/tests/test_logging.py

Methods Under Test (Static Analysis):
  - has_level_handler (logging.py:31)
    Source code:
      def has_level_handler(logger: logging.Logger) -> bool:
          """Check if there is a handler in the logging chain that will handle the
          given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.
          """
          level = logger.getEffectiveLevel()
          current = logger
      
          while current:
              if any(handler.level <= level for handler in current.handlers):
                  return True
      
              if not current.propagate:
                  break
      
              current = current.parent  # type: ignore
      
          return False
  - handler.setLevel (:0)
  - has_level_handler (logging.py:31)
    Source code:
      def has_level_handler(logger: logging.Logger) -> bool:
          """Check if there is a handler in the logging chain that will handle the
          given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.
          """
          level = logger.getEffectiveLevel()
          current = logger
      
          while current:
              if any(handler.level <= level for handler in current.handlers):
                  return True
      
              if not current.propagate:
                  break
      
              current = current.parent  # type: ignore
      
          return False
  - has_level_handler (logging.py:31)
    Source code:
      def has_level_handler(logger: logging.Logger) -> bool:
          """Check if there is a handler in the logging chain that will handle the
          given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.
          """
          level = logger.getEffectiveLevel()
          current = logger
      
          while current:
              if any(handler.level <= level for handler in current.handlers):
                  return True
      
              if not current.propagate:
                  break
      
              current = current.parent  # type: ignore
      
          return False
  - has_level_handler (logging.py:31)
    Source code:
      def has_level_handler(logger: logging.Logger) -> bool:
          """Check if there is a handler in the logging chain that will handle the
          given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.
          """
          level = logger.getEffectiveLevel()
          current = logger
      
          while current:
              if any(handler.level <= level for handler in current.handlers):
                  return True
      
              if not current.propagate:
                  break
      
              current = current.parent  # type: ignore
      
          return False

Methods Actually Called (Dynamic Analysis):
  - has_level_handler (logging.py:31)
    Called by: test_has_level_handler
  - handler.setLevel (:0)
    Called by: test_has_level_handler

Test Source Code:
  def test_has_level_handler():
      logger = logging.getLogger("flask.app")
      assert not has_level_handler(logger)
  
      handler = logging.StreamHandler()
      logging.root.addHandler(handler)
      assert has_level_handler(logger)
  
      logger.propagate = False
      assert not has_level_handler(logger)
      logger.propagate = True
  
      handler.setLevel(logging.ERROR)
      assert not has_level_handler(logger)

Assertions:
  - assert not has_level_handler(logger)
  - assert has_level_handler(logger)
  - assert not has_level_handler(logger)
  - assert not has_level_handler(logger)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_has_level_handler.json

================================================================================
Test: test_log_view_exception
File: __internal__/_data/flask/tests/test_logging.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - StringIO (:0)
  - client.get (:0)
  - stream.getvalue (:0)
  - Exception (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_log_view_exception
  - StringIO (:0)
    Called by: test_log_view_exception
  - client.get (:0)
    Called by: test_log_view_exception
  - stream.getvalue (:0)
    Called by: test_log_view_exception
  - Exception (:0)
    Called by: test_log_view_exception

Test Source Code:
  def test_log_view_exception(app, client):
      @app.route("/")
      def index():
          raise Exception("test")
  
      app.testing = False
      stream = StringIO()
      rv = client.get("/", errors_stream=stream)
      assert rv.status_code == 500
      assert rv.data
      err = stream.getvalue()
      assert "Exception on / [GET]" in err
      assert "Exception: test" in err

Assertions:
  - assert rv.status_code == 500
  - assert rv.data
  - assert 'Exception on / [GET]' in err
  - assert 'Exception: test' in err

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_log_view_exception.json

================================================================================
Test: test_cli_name
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_cli_name(test_apps):
      """Make sure the CLI object's name is the app's name and not the app itself"""
      from cliapp.app import testapp
  
      assert testapp.cli.name == testapp.name

Assertions:
  - assert testapp.cli.name == testapp.name

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_cli_name.json

================================================================================
Test: test_find_best_app
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - isinstance (:0)
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - isinstance (:0)
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - isinstance (:0)
  - Flask (:0)
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - Flask (:0)
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - Flask (:0)
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - Flask (:0)
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - Flask (:0)
  - find_best_app (cli.py:41)
    Source code:
      def find_best_app(module: ModuleType) -> Flask:
          """Given a module instance this tries to find the best possible
          application in the module or raises an exception.
          """
          from . import Flask
      
          # Search for the most common names first.
          for attr_name in ("app", "application"):
              app = getattr(module, attr_name, None)
      
              if isinstance(app, Flask):
                  return app
      
          # Otherwise find the only object that is a Flask instance.
          matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]
      
          if len(matches) == 1:
              return matches[0]
          elif len(matches) > 1:
              raise NoAppException(
                  "Detected multiple Flask applications in module"
                  f" '{module.__name__}'. Use '{module.__name__}:name'"
                  " to specify the correct one."
              )
      
          # Search for app factory functions.
          for attr_name in ("create_app", "make_app"):
              app_factory = getattr(module, attr_name, None)
      
              if inspect.isfunction(app_factory):
                  try:
                      app = app_factory()
      
                      if isinstance(app, Flask):
                          return app
                  except TypeError as e:
                      if not _called_with_wrong_args(app_factory):
                          raise
      
                      raise NoAppException(
                          f"Detected factory '{attr_name}' in module '{module.__name__}',"
                          " but could not call it without arguments. Use"
                          f" '{module.__name__}:{attr_name}(args)'"
                          " to specify arguments."
                      ) from e
      
          raise NoAppException(
              "Failed to find Flask application or factory in module"
              f" '{module.__name__}'. Use '{module.__name__}:name'"
              " to specify one."
          )
  - Flask (:0)
  - Flask (:0)
  - Flask (:0)
  - Flask (:0)
  - Flask (:0)
  - Flask (:0)
  - Flask (:0)
  - Flask (:0)
  - TypeError (:0)

Methods Actually Called (Dynamic Analysis):
  - find_best_app (cli.py:41)
    Called by: test_find_best_app
  - isinstance (:0)
    Called by: test_find_best_app
  - Flask (:0)
    Called by: test_find_best_app
  - TypeError (:0)
    Called by: test_find_best_app

Test Source Code:
  def test_find_best_app(test_apps):
      class Module:
          app = Flask("appname")
  
      assert find_best_app(Module) == Module.app
  
      class Module:
          application = Flask("appname")
  
      assert find_best_app(Module) == Module.application
  
      class Module:
          myapp = Flask("appname")
  
      assert find_best_app(Module) == Module.myapp
  
      class Module:
          @staticmethod
          def create_app():
              return Flask("appname")
  
      app = find_best_app(Module)
      assert isinstance(app, Flask)
      assert app.name == "appname"
  
      class Module:
          @staticmethod
          def create_app(**kwargs):
              return Flask("appname")
  
      app = find_best_app(Module)
      assert isinstance(app, Flask)
      assert app.name == "appname"
  
      class Module:
          @staticmethod
          def make_app():
              return Flask("appname")
  
      app = find_best_app(Module)
      assert isinstance(app, Flask)
      assert app.name == "appname"
  
      class Module:
          myapp = Flask("appname1")
  
          @staticmethod
          def create_app():
              return Flask("appname2")
  
      assert find_best_app(Module) == Module.myapp
  
      class Module:
          myapp = Flask("appname1")
  
          @staticmethod
          def create_app():
              return Flask("appname2")
  
      assert find_best_app(Module) == Module.myapp
  
      class Module:
          pass
  
      pytest.raises(NoAppException, find_best_app, Module)
  
      class Module:
          myapp1 = Flask("appname1")
          myapp2 = Flask("appname2")
  
      pytest.raises(NoAppException, find_best_app, Module)
  
      class Module:
          @staticmethod
          def create_app(foo, bar):
              return Flask("appname2")
  
      pytest.raises(NoAppException, find_best_app, Module)
  
      class Module:
          @staticmethod
          def create_app():
              raise TypeError("bad bad factory!")
  
      pytest.raises(TypeError, find_best_app, Module)

Assertions:
  - assert find_best_app(Module) == Module.app
  - assert find_best_app(Module) == Module.application
  - assert find_best_app(Module) == Module.myapp
  - assert isinstance(app, Flask)
  - assert app.name == 'appname'
  - assert isinstance(app, Flask)
  - assert app.name == 'appname'
  - assert isinstance(app, Flask)
  - assert app.name == 'appname'
  - assert find_best_app(Module) == Module.myapp
  - assert find_best_app(Module) == Module.myapp

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_find_best_app.json

================================================================================
Test: test_prepare_import
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - request.addfinalizer (:0)
  - prepare_import (cli.py:200)
    Source code:
      def prepare_import(path: str) -> str:
          """Given a filename this will try to calculate the python path, add it
          to the search path and return the actual module name that is expected.
          """
          path = os.path.realpath(path)
      
          fname, ext = os.path.splitext(path)
          if ext == ".py":
              path = fname
      
          if os.path.basename(path) == "__init__":
              path = os.path.dirname(path)
      
          module_name = []
      
          # move up until outside package structure (no __init__.py)
          while True:
              path, name = os.path.split(path)
              module_name.append(name)
      
              if not os.path.exists(os.path.join(path, "__init__.py")):
                  break
      
          if sys.path[0] != path:
              sys.path.insert(0, path)
      
          return ".".join(module_name[::-1])
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - request.addfinalizer (:0)
    Called by: test_prepare_import
  - prepare_import (cli.py:200)
    Called by: test_prepare_import
  - str (:0)
    Called by: test_prepare_import

Test Source Code:
  def test_prepare_import(request, value, path, result):
      """Expect the correct path to be set and the correct import and app names
      to be returned.
  
      :func:`prepare_exec_for_file` has a side effect where the parent directory
      of the given import is added to :data:`sys.path`. This is reset after the
      test runs.
      """
      original_path = sys.path[:]
  
      def reset_path():
          sys.path[:] = original_path
  
      request.addfinalizer(reset_path)
  
      assert prepare_import(value) == result
      assert sys.path[0] == str(path)

Assertions:
  - assert prepare_import(value) == result
  - assert sys.path[0] == str(path)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_prepare_import.json

================================================================================
Test: test_locate_app
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - locate_app (cli.py:230)
    Source code:
      def locate_app(
          module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
      ) -> Flask: ...

Methods Actually Called (Dynamic Analysis):
  - locate_app (cli.py:230)
    Called by: test_locate_app

Test Source Code:
  def test_locate_app(test_apps, iname, aname, result):
      assert locate_app(iname, aname).name == result

Assertions:
  - assert locate_app(iname, aname).name == result

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_locate_app.json

================================================================================
Test: test_locate_app_raises
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - locate_app (cli.py:230)
    Source code:
      def locate_app(
          module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
      ) -> Flask: ...

Methods Actually Called (Dynamic Analysis):
  - locate_app (cli.py:230)
    Called by: test_locate_app_raises

Test Source Code:
  def test_locate_app_raises(test_apps, iname, aname):
      with pytest.raises(NoAppException):
          locate_app(iname, aname)

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_locate_app_raises.json

================================================================================
Test: test_locate_app_suppress_raise
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - locate_app (cli.py:230)
    Source code:
      def locate_app(
          module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
      ) -> Flask: ...
  - locate_app (cli.py:230)
    Source code:
      def locate_app(
          module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True
      ) -> Flask: ...

Methods Actually Called (Dynamic Analysis):
  - locate_app (cli.py:230)
    Called by: test_locate_app_suppress_raise

Test Source Code:
  def test_locate_app_suppress_raise(test_apps):
      app = locate_app("notanapp.py", None, raise_if_not_found=False)
      assert app is None
  
      # only direct import error is suppressed
      with pytest.raises(NoAppException):
          locate_app("cliapp.importerrorapp", None, raise_if_not_found=False)

Assertions:
  - assert app is None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_locate_app_suppress_raise.json

================================================================================
Test: test_get_version
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - MockCtx (:0)
  - get_version (cli.py:267)
    Source code:
      def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -> None:
          if not value or ctx.resilient_parsing:
              return
      
          flask_version = importlib.metadata.version("flask")
          werkzeug_version = importlib.metadata.version("werkzeug")
      
          click.echo(
              f"Python {platform.python_version()}\n"
              f"Flask {flask_version}\n"
              f"Werkzeug {werkzeug_version}",
              color=ctx.color,
          )
          ctx.exit()
  - capsys.readouterr (:0)

Methods Actually Called (Dynamic Analysis):
  - MockCtx (:0)
    Called by: test_get_version
  - get_version (cli.py:267)
    Called by: test_get_version
  - capsys.readouterr (:0)
    Called by: test_get_version

Test Source Code:
  def test_get_version(test_apps, capsys):
      class MockCtx:
          resilient_parsing = False
          color = None
  
          def exit(self):
              return
  
      ctx = MockCtx()
      get_version(ctx, None, "test")
      out, err = capsys.readouterr()
      assert f"Python {platform.python_version()}" in out
      assert f"Flask {importlib.metadata.version('flask')}" in out
      assert f"Werkzeug {importlib.metadata.version('werkzeug')}" in out

Assertions:
  - assert f'Python {platform.python_version()}' in out
  - assert f"Flask {importlib.metadata.version('flask')}" in out
  - assert f"Werkzeug {importlib.metadata.version('werkzeug')}" in out

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_get_version.json

================================================================================
Test: test_scriptinfo
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - ScriptInfo (:0)
  - obj.load_app (:0)
  - str (:0)
  - ScriptInfo (:0)
  - obj.load_app (:0)
  - ScriptInfo (:0)
  - obj.load_app (:0)
  - ScriptInfo (:0)
  - obj.load_app (:0)
  - ScriptInfo (:0)
  - monkeypatch.chdir (:0)
  - ScriptInfo (:0)
  - obj.load_app (:0)
  - monkeypatch.chdir (:0)
  - ScriptInfo (:0)
  - obj.load_app (:0)
  - obj.load_app (:0)
  - obj.load_app (:0)
  - obj.load_app (:0)
  - Flask (:0)
  - obj.load_app (:0)

Methods Actually Called (Dynamic Analysis):
  - ScriptInfo (:0)
    Called by: test_scriptinfo
  - obj.load_app (:0)
    Called by: test_scriptinfo
  - str (:0)
    Called by: test_scriptinfo
  - monkeypatch.chdir (:0)
    Called by: test_scriptinfo
  - Flask (:0)
    Called by: test_scriptinfo

Test Source Code:
  def test_scriptinfo(test_apps, monkeypatch):
      obj = ScriptInfo(app_import_path="cliapp.app:testapp")
      app = obj.load_app()
      assert app.name == "testapp"
      assert obj.load_app() is app
  
      # import app with module's absolute path
      cli_app_path = str(test_path / "cliapp" / "app.py")
  
      obj = ScriptInfo(app_import_path=cli_app_path)
      app = obj.load_app()
      assert app.name == "testapp"
      assert obj.load_app() is app
      obj = ScriptInfo(app_import_path=f"{cli_app_path}:testapp")
      app = obj.load_app()
      assert app.name == "testapp"
      assert obj.load_app() is app
  
      def create_app():
          return Flask("createapp")
  
      obj = ScriptInfo(create_app=create_app)
      app = obj.load_app()
      assert app.name == "createapp"
      assert obj.load_app() is app
  
      obj = ScriptInfo()
      pytest.raises(NoAppException, obj.load_app)
  
      # import app from wsgi.py in current directory
      monkeypatch.chdir(test_path / "helloworld")
      obj = ScriptInfo()
      app = obj.load_app()
      assert app.name == "hello"
  
      # import app from app.py in current directory
      monkeypatch.chdir(test_path / "cliapp")
      obj = ScriptInfo()
      app = obj.load_app()
      assert app.name == "testapp"

Assertions:
  - assert app.name == 'testapp'
  - assert obj.load_app() is app
  - assert app.name == 'testapp'
  - assert obj.load_app() is app
  - assert app.name == 'testapp'
  - assert obj.load_app() is app
  - assert app.name == 'createapp'
  - assert obj.load_app() is app
  - assert app.name == 'hello'
  - assert app.name == 'testapp'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_scriptinfo.json

================================================================================
Test: test_app_cli_has_app_context
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - app.cli.command (:0)
  - FlaskGroup (:0)
  - runner.invoke (:0)
  - bool (:0)
  - current_app._get_current_object (:0)

Methods Actually Called (Dynamic Analysis):
  - app.cli.command (:0)
    Called by: test_app_cli_has_app_context
  - FlaskGroup (:0)
    Called by: test_app_cli_has_app_context
  - runner.invoke (:0)
    Called by: test_app_cli_has_app_context
  - bool (:0)
    Called by: test_app_cli_has_app_context
  - current_app._get_current_object (:0)
    Called by: test_app_cli_has_app_context

Test Source Code:
  def test_app_cli_has_app_context(app, runner):
      def _param_cb(ctx, param, value):
          # current_app should be available in parameter callbacks
          return bool(current_app)
  
      @app.cli.command()
      @click.argument("value", callback=_param_cb)
      def check(value):
          app = click.get_current_context().obj.load_app()
          # the loaded app should be the same as current_app
          same_app = current_app._get_current_object() is app
          return same_app, value
  
      cli = FlaskGroup(create_app=lambda: app)
      result = runner.invoke(cli, ["check", "x"], standalone_mode=False)
      assert result.return_value == (True, True)

Assertions:
  - assert result.return_value == (True, True)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_app_cli_has_app_context.json

================================================================================
Test: test_with_appcontext
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - ScriptInfo (:0)
  - runner.invoke (:0)
  - Flask (:0)

Methods Actually Called (Dynamic Analysis):
  - ScriptInfo (:0)
    Called by: test_with_appcontext
  - runner.invoke (:0)
    Called by: test_with_appcontext
  - Flask (:0)
    Called by: test_with_appcontext

Test Source Code:
  def test_with_appcontext(runner):
      @click.command()
      @with_appcontext
      def testcmd():
          click.echo(current_app.name)
  
      obj = ScriptInfo(create_app=lambda: Flask("testapp"))
  
      result = runner.invoke(testcmd, obj=obj)
      assert result.exit_code == 0
      assert result.output == "testapp\n"

Assertions:
  - assert result.exit_code == 0
  - assert result.output == 'testapp\n'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_with_appcontext.json

================================================================================
Test: test_appgroup_app_context
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - cli.command (:0)
  - cli.group (:0)
  - subgroup.command (:0)
  - ScriptInfo (:0)
  - runner.invoke (:0)
  - runner.invoke (:0)
  - Flask (:0)

Methods Actually Called (Dynamic Analysis):
  - cli.command (:0)
    Called by: test_appgroup_app_context
  - cli.group (:0)
    Called by: test_appgroup_app_context
  - subgroup.command (:0)
    Called by: test_appgroup_app_context
  - ScriptInfo (:0)
    Called by: test_appgroup_app_context
  - runner.invoke (:0)
    Called by: test_appgroup_app_context
  - Flask (:0)
    Called by: test_appgroup_app_context

Test Source Code:
  def test_appgroup_app_context(runner):
      @click.group(cls=AppGroup)
      def cli():
          pass
  
      @cli.command()
      def test():
          click.echo(current_app.name)
  
      @cli.group()
      def subgroup():
          pass
  
      @subgroup.command()
      def test2():
          click.echo(current_app.name)
  
      obj = ScriptInfo(create_app=lambda: Flask("testappgroup"))
  
      result = runner.invoke(cli, ["test"], obj=obj)
      assert result.exit_code == 0
      assert result.output == "testappgroup\n"
  
      result = runner.invoke(cli, ["subgroup", "test2"], obj=obj)
      assert result.exit_code == 0
      assert result.output == "testappgroup\n"

Assertions:
  - assert result.exit_code == 0
  - assert result.output == 'testappgroup\n'
  - assert result.exit_code == 0
  - assert result.output == 'testappgroup\n'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_appgroup_app_context.json

================================================================================
Test: test_flaskgroup_app_context
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - cli.command (:0)
  - runner.invoke (:0)
  - Flask (:0)

Methods Actually Called (Dynamic Analysis):
  - cli.command (:0)
    Called by: test_flaskgroup_app_context
  - runner.invoke (:0)
    Called by: test_flaskgroup_app_context
  - Flask (:0)
    Called by: test_flaskgroup_app_context

Test Source Code:
  def test_flaskgroup_app_context(runner):
      def create_app():
          return Flask("flaskgroup")
  
      @click.group(cls=FlaskGroup, create_app=create_app)
      def cli(**params):
          pass
  
      @cli.command()
      def test():
          click.echo(current_app.name)
  
      result = runner.invoke(cli, ["test"])
      assert result.exit_code == 0
      assert result.output == "flaskgroup\n"

Assertions:
  - assert result.exit_code == 0
  - assert result.output == 'flaskgroup\n'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_flaskgroup_app_context.json

================================================================================
Test: test_flaskgroup_debug
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - cli.command (:0)
  - runner.invoke (:0)
  - Flask (:0)
  - str (:0)

Methods Actually Called (Dynamic Analysis):
  - cli.command (:0)
    Called by: test_flaskgroup_debug
  - runner.invoke (:0)
    Called by: test_flaskgroup_debug
  - Flask (:0)
    Called by: test_flaskgroup_debug
  - str (:0)
    Called by: test_flaskgroup_debug

Test Source Code:
  def test_flaskgroup_debug(runner, set_debug_flag):
      def create_app():
          app = Flask("flaskgroup")
          app.debug = True
          return app
  
      @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)
      def cli(**params):
          pass
  
      @cli.command()
      def test():
          click.echo(str(current_app.debug))
  
      result = runner.invoke(cli, ["test"])
      assert result.exit_code == 0
      assert result.output == f"{not set_debug_flag}\n"

Assertions:
  - assert result.exit_code == 0
  - assert result.output == f'{not set_debug_flag}\n'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_flaskgroup_debug.json

================================================================================
Test: test_flaskgroup_nested
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - FlaskGroup (:0)
  - cli.add_command (:0)
  - flask_group.command (:0)
  - runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - FlaskGroup (:0)
    Called by: test_flaskgroup_nested
  - cli.add_command (:0)
    Called by: test_flaskgroup_nested
  - flask_group.command (:0)
    Called by: test_flaskgroup_nested
  - runner.invoke (:0)
    Called by: test_flaskgroup_nested

Test Source Code:
  def test_flaskgroup_nested(app, runner):
      cli = click.Group("cli")
      flask_group = FlaskGroup(name="flask", create_app=lambda: app)
      cli.add_command(flask_group)
  
      @flask_group.command()
      def show():
          click.echo(current_app.name)
  
      result = runner.invoke(cli, ["flask", "show"])
      assert result.output == "flask_test\n"

Assertions:
  - assert result.output == 'flask_test\n'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_flaskgroup_nested.json

================================================================================
Test: test_no_command_echo_loading_error
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - runner.invoke (:0)
  - CliRunner (:0)
  - CliRunner (:0)

Methods Actually Called (Dynamic Analysis):
  - runner.invoke (:0)
    Called by: test_no_command_echo_loading_error
  - CliRunner (:0)
    Called by: test_no_command_echo_loading_error

Test Source Code:
  def test_no_command_echo_loading_error():
      from flask.cli import cli
  
      try:
          runner = CliRunner(mix_stderr=False)
      except (DeprecationWarning, TypeError):
          # Click >= 8.2
          runner = CliRunner()
  
      result = runner.invoke(cli, ["missing"])
      assert result.exit_code == 2
      assert "FLASK_APP" in result.stderr
      assert "Usage:" in result.stderr

Assertions:
  - assert result.exit_code == 2
  - assert 'FLASK_APP' in result.stderr
  - assert 'Usage:' in result.stderr

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_no_command_echo_loading_error.json

================================================================================
Test: test_help_echo_loading_error
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - runner.invoke (:0)
  - CliRunner (:0)
  - CliRunner (:0)

Methods Actually Called (Dynamic Analysis):
  - runner.invoke (:0)
    Called by: test_help_echo_loading_error
  - CliRunner (:0)
    Called by: test_help_echo_loading_error

Test Source Code:
  def test_help_echo_loading_error():
      from flask.cli import cli
  
      try:
          runner = CliRunner(mix_stderr=False)
      except (DeprecationWarning, TypeError):
          # Click >= 8.2
          runner = CliRunner()
  
      result = runner.invoke(cli, ["--help"])
      assert result.exit_code == 0
      assert "FLASK_APP" in result.stderr
      assert "Usage:" in result.stdout

Assertions:
  - assert result.exit_code == 0
  - assert 'FLASK_APP' in result.stderr
  - assert 'Usage:' in result.stdout

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_help_echo_loading_error.json

================================================================================
Test: test_help_echo_exception
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - FlaskGroup (:0)
  - runner.invoke (:0)
  - Exception (:0)
  - CliRunner (:0)
  - CliRunner (:0)

Methods Actually Called (Dynamic Analysis):
  - FlaskGroup (:0)
    Called by: test_help_echo_exception
  - runner.invoke (:0)
    Called by: test_help_echo_exception
  - Exception (:0)
    Called by: test_help_echo_exception
  - CliRunner (:0)
    Called by: test_help_echo_exception

Test Source Code:
  def test_help_echo_exception():
      def create_app():
          raise Exception("oh no")
  
      cli = FlaskGroup(create_app=create_app)
  
      try:
          runner = CliRunner(mix_stderr=False)
      except (DeprecationWarning, TypeError):
          # Click >= 8.2
          runner = CliRunner()
  
      result = runner.invoke(cli, ["--help"])
      assert result.exit_code == 0
      assert "Exception: oh no" in result.stderr
      assert "Usage:" in result.stdout

Assertions:
  - assert result.exit_code == 0
  - assert 'Exception: oh no' in result.stderr
  - assert 'Usage:' in result.stdout

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_help_echo_exception.json

================================================================================
Test: test_simple
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)
  - self.expect_order (:0)

Methods Actually Called (Dynamic Analysis):
  - FlaskCliRunner.invoke (testing.py:275)
    Called by: test_simple
  - self.expect_order (:0)
    Called by: test_simple

Test Source Code:
  def test_simple(self, invoke):
          result = invoke(["routes"])
          assert result.exit_code == 0
          self.expect_order(["aaa_post", "static", "yyy_get_post"], result.output)

Assertions:
  - assert result.exit_code == 0

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_simple.json

================================================================================
Test: test_sort
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - self.expect_order (:0)
  - self.expect_order (:0)
  - self.expect_order (:0)
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)
  - app.url_map.iter_rules (:0)
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)

Methods Actually Called (Dynamic Analysis):
  - self.expect_order (:0)
    Called by: test_sort
  - FlaskCliRunner.invoke (testing.py:275)
    Called by: test_sort
  - app.url_map.iter_rules (:0)
    Called by: test_sort

Test Source Code:
  def test_sort(self, app, invoke):
          default_output = invoke(["routes"]).output
          endpoint_output = invoke(["routes", "-s", "endpoint"]).output
          assert default_output == endpoint_output
          self.expect_order(
              ["static", "yyy_get_post", "aaa_post"],
              invoke(["routes", "-s", "methods"]).output,
          )
          self.expect_order(
              ["yyy_get_post", "static", "aaa_post"],
              invoke(["routes", "-s", "rule"]).output,
          )
          match_order = [r.endpoint for r in app.url_map.iter_rules()]
          self.expect_order(match_order, invoke(["routes", "-s", "match"]).output)

Assertions:
  - assert default_output == endpoint_output

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_sort.json

================================================================================
Test: test_all_methods
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)
  - FlaskCliRunner.invoke (testing.py:275)
    Source code:
      def invoke(  # type: ignore
              self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any
          ) -> Result:
              """Invokes a CLI command in an isolated environment. See
              :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for
              full method documentation. See :ref:`testing-cli` for examples.
      
              If the ``obj`` argument is not given, passes an instance of
              :class:`~flask.cli.ScriptInfo` that knows how to load the Flask
              app being tested.
      
              :param cli: Command object to invoke. Default is the app's
                  :attr:`~flask.app.Flask.cli` group.
              :param args: List of strings to invoke the command with.
      
              :return: a :class:`~click.testing.Result` object.
              """
              if cli is None:
                  cli = self.app.cli
      
              if "obj" not in kwargs:
                  kwargs["obj"] = ScriptInfo(create_app=lambda: self.app)
      
              return super().invoke(cli, args, **kwargs)

Methods Actually Called (Dynamic Analysis):
  - FlaskCliRunner.invoke (testing.py:275)
    Called by: test_all_methods

Test Source Code:
  def test_all_methods(self, invoke):
          output = invoke(["routes"]).output
          assert "GET, HEAD, OPTIONS, POST" not in output
          output = invoke(["routes", "--all-methods"]).output
          assert "GET, HEAD, OPTIONS, POST" in output

Assertions:
  - assert 'GET, HEAD, OPTIONS, POST' not in output
  - assert 'GET, HEAD, OPTIONS, POST' in output

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_all_methods.json

================================================================================
Test: test_no_routes
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - Flask (:0)
  - FlaskGroup (:0)
  - runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - Flask (:0)
    Called by: test_no_routes
  - FlaskGroup (:0)
    Called by: test_no_routes
  - runner.invoke (:0)
    Called by: test_no_routes

Test Source Code:
  def test_no_routes(self, runner):
          app = Flask(__name__, static_folder=None)
          cli = FlaskGroup(create_app=lambda: app)
          result = runner.invoke(cli, ["routes"])
          assert result.exit_code == 0
          assert "No routes were registered." in result.output

Assertions:
  - assert result.exit_code == 0
  - assert 'No routes were registered.' in result.output

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_no_routes.json

================================================================================
Test: test_subdomain
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - Flask (:0)
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)
  - FlaskGroup (:0)
  - runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - Flask (:0)
    Called by: test_subdomain
  - app.add_url_rule (:0)
    Called by: test_subdomain
  - FlaskGroup (:0)
    Called by: test_subdomain
  - runner.invoke (:0)
    Called by: test_subdomain

Test Source Code:
  def test_subdomain(self, runner):
          app = Flask(__name__, static_folder=None)
          app.add_url_rule("/a", subdomain="a", endpoint="a")
          app.add_url_rule("/b", subdomain="b", endpoint="b")
          cli = FlaskGroup(create_app=lambda: app)
          result = runner.invoke(cli, ["routes"])
          assert result.exit_code == 0
          assert "Subdomain" in result.output

Assertions:
  - assert result.exit_code == 0
  - assert 'Subdomain' in result.output

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_subdomain.json

================================================================================
Test: test_host
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - Flask (:0)
  - app.add_url_rule (:0)
  - app.add_url_rule (:0)
  - FlaskGroup (:0)
  - runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - Flask (:0)
    Called by: test_host
  - app.add_url_rule (:0)
    Called by: test_host
  - FlaskGroup (:0)
    Called by: test_host
  - runner.invoke (:0)
    Called by: test_host

Test Source Code:
  def test_host(self, runner):
          app = Flask(__name__, static_folder=None, host_matching=True)
          app.add_url_rule("/a", host="a", endpoint="a")
          app.add_url_rule("/b", host="b", endpoint="b")
          cli = FlaskGroup(create_app=lambda: app)
          result = runner.invoke(cli, ["routes"])
          assert result.exit_code == 0
          assert "Host" in result.output

Assertions:
  - assert result.exit_code == 0
  - assert 'Host' in result.output

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_host.json

================================================================================
Test: test_load_dotenv
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - monkeypatch.setenv (:0)
  - monkeypatch.chdir (:0)
  - load_dotenv (cli.py:704)
    Source code:
      def load_dotenv(
          path: str | os.PathLike[str] | None = None, load_defaults: bool = True
      ) -> bool:
          """Load "dotenv" files to set environment variables. A given path takes
          precedence over ``.env``, which takes precedence over ``.flaskenv``. After
          loading and combining these files, values are only set if the key is not
          already set in ``os.environ``.
      
          This is a no-op if `python-dotenv`_ is not installed.
      
          .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme
      
          :param path: Load the file at this location.
          :param load_defaults: Search for and load the default ``.flaskenv`` and
              ``.env`` files.
          :return: ``True`` if at least one env var was loaded.
      
          .. versionchanged:: 3.1
              Added the ``load_defaults`` parameter. A given path takes precedence
              over default files.
      
          .. versionchanged:: 2.0
              The current directory is not changed to the location of the
              loaded file.
      
          .. versionchanged:: 2.0
              When loading the env files, set the default encoding to UTF-8.
      
          .. versionchanged:: 1.1.0
              Returns ``False`` when python-dotenv is not installed, or when
              the given path isn't a file.
      
          .. versionadded:: 1.0
          """
          try:
              import dotenv
          except ImportError:
              if path or os.path.isfile(".env") or os.path.isfile(".flaskenv"):
                  click.secho(
                      " * Tip: There are .env files present. Install python-dotenv"
                      " to use them.",
                      fg="yellow",
                      err=True,
                  )
      
              return False
      
          data: dict[str, str | None] = {}
      
          if load_defaults:
              for default_name in (".flaskenv", ".env"):
                  if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):
                      continue
      
                  data |= dotenv.dotenv_values(default_path, encoding="utf-8")
      
          if path is not None and os.path.isfile(path):
              data |= dotenv.dotenv_values(path, encoding="utf-8")
      
          for key, value in data.items():
              if key in os.environ or value is None:
                  continue
      
              os.environ[key] = value
      
          return bool(data)
  - monkeypatch._setitem.append (:0)
  - Path.cwd (:0)
  - load_dotenv (cli.py:704)
    Source code:
      def load_dotenv(
          path: str | os.PathLike[str] | None = None, load_defaults: bool = True
      ) -> bool:
          """Load "dotenv" files to set environment variables. A given path takes
          precedence over ``.env``, which takes precedence over ``.flaskenv``. After
          loading and combining these files, values are only set if the key is not
          already set in ``os.environ``.
      
          This is a no-op if `python-dotenv`_ is not installed.
      
          .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme
      
          :param path: Load the file at this location.
          :param load_defaults: Search for and load the default ``.flaskenv`` and
              ``.env`` files.
          :return: ``True`` if at least one env var was loaded.
      
          .. versionchanged:: 3.1
              Added the ``load_defaults`` parameter. A given path takes precedence
              over default files.
      
          .. versionchanged:: 2.0
              The current directory is not changed to the location of the
              loaded file.
      
          .. versionchanged:: 2.0
              When loading the env files, set the default encoding to UTF-8.
      
          .. versionchanged:: 1.1.0
              Returns ``False`` when python-dotenv is not installed, or when
              the given path isn't a file.
      
          .. versionadded:: 1.0
          """
          try:
              import dotenv
          except ImportError:
              if path or os.path.isfile(".env") or os.path.isfile(".flaskenv"):
                  click.secho(
                      " * Tip: There are .env files present. Install python-dotenv"
                      " to use them.",
                      fg="yellow",
                      err=True,
                  )
      
              return False
      
          data: dict[str, str | None] = {}
      
          if load_defaults:
              for default_name in (".flaskenv", ".env"):
                  if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):
                      continue
      
                  data |= dotenv.dotenv_values(default_path, encoding="utf-8")
      
          if path is not None and os.path.isfile(path):
              data |= dotenv.dotenv_values(path, encoding="utf-8")
      
          for key, value in data.items():
              if key in os.environ or value is None:
                  continue
      
              os.environ[key] = value
      
          return bool(data)
  - need_dotenv (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setenv (:0)
    Called by: test_load_dotenv
  - monkeypatch.chdir (:0)
    Called by: test_load_dotenv
  - load_dotenv (cli.py:704)
    Called by: test_load_dotenv
  - monkeypatch._setitem.append (:0)
    Called by: test_load_dotenv
  - Path.cwd (:0)
    Called by: test_load_dotenv
  - need_dotenv (:0)
    Called by: test_load_dotenv

Test Source Code:
  def test_load_dotenv(monkeypatch):
      # can't use monkeypatch.delitem since the keys don't exist yet
      for item in ("FOO", "BAR", "SPAM", "HAM"):
          monkeypatch._setitem.append((os.environ, item, notset))
  
      monkeypatch.setenv("EGGS", "3")
      monkeypatch.chdir(test_path)
      assert load_dotenv()
      assert Path.cwd() == test_path
      # .flaskenv doesn't overwrite .env
      assert os.environ["FOO"] == "env"
      # set only in .flaskenv
      assert os.environ["BAR"] == "bar"
      # set only in .env
      assert os.environ["SPAM"] == "1"
      # set manually, files don't overwrite
      assert os.environ["EGGS"] == "3"
      # test env file encoding
      assert os.environ["HAM"] == "火腿"
      # Non existent file should not load
      assert not load_dotenv("non-existent-file", load_defaults=False)

Assertions:
  - assert load_dotenv()
  - assert Path.cwd() == test_path
  - assert os.environ['FOO'] == 'env'
  - assert os.environ['BAR'] == 'bar'
  - assert os.environ['SPAM'] == '1'
  - assert os.environ['EGGS'] == '3'
  - assert os.environ['HAM'] == '火腿'
  - assert not load_dotenv('non-existent-file', load_defaults=False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_load_dotenv.json

================================================================================
Test: test_dotenv_path
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - load_dotenv (cli.py:704)
    Source code:
      def load_dotenv(
          path: str | os.PathLike[str] | None = None, load_defaults: bool = True
      ) -> bool:
          """Load "dotenv" files to set environment variables. A given path takes
          precedence over ``.env``, which takes precedence over ``.flaskenv``. After
          loading and combining these files, values are only set if the key is not
          already set in ``os.environ``.
      
          This is a no-op if `python-dotenv`_ is not installed.
      
          .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme
      
          :param path: Load the file at this location.
          :param load_defaults: Search for and load the default ``.flaskenv`` and
              ``.env`` files.
          :return: ``True`` if at least one env var was loaded.
      
          .. versionchanged:: 3.1
              Added the ``load_defaults`` parameter. A given path takes precedence
              over default files.
      
          .. versionchanged:: 2.0
              The current directory is not changed to the location of the
              loaded file.
      
          .. versionchanged:: 2.0
              When loading the env files, set the default encoding to UTF-8.
      
          .. versionchanged:: 1.1.0
              Returns ``False`` when python-dotenv is not installed, or when
              the given path isn't a file.
      
          .. versionadded:: 1.0
          """
          try:
              import dotenv
          except ImportError:
              if path or os.path.isfile(".env") or os.path.isfile(".flaskenv"):
                  click.secho(
                      " * Tip: There are .env files present. Install python-dotenv"
                      " to use them.",
                      fg="yellow",
                      err=True,
                  )
      
              return False
      
          data: dict[str, str | None] = {}
      
          if load_defaults:
              for default_name in (".flaskenv", ".env"):
                  if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):
                      continue
      
                  data |= dotenv.dotenv_values(default_path, encoding="utf-8")
      
          if path is not None and os.path.isfile(path):
              data |= dotenv.dotenv_values(path, encoding="utf-8")
      
          for key, value in data.items():
              if key in os.environ or value is None:
                  continue
      
              os.environ[key] = value
      
          return bool(data)
  - monkeypatch._setitem.append (:0)
  - Path.cwd (:0)
  - need_dotenv (:0)

Methods Actually Called (Dynamic Analysis):
  - load_dotenv (cli.py:704)
    Called by: test_dotenv_path
  - monkeypatch._setitem.append (:0)
    Called by: test_dotenv_path
  - Path.cwd (:0)
    Called by: test_dotenv_path
  - need_dotenv (:0)
    Called by: test_dotenv_path

Test Source Code:
  def test_dotenv_path(monkeypatch):
      for item in ("FOO", "BAR", "EGGS"):
          monkeypatch._setitem.append((os.environ, item, notset))
  
      load_dotenv(test_path / ".flaskenv")
      assert Path.cwd() == cwd
      assert "FOO" in os.environ

Assertions:
  - assert Path.cwd() == cwd
  - assert 'FOO' in os.environ

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_dotenv_path.json

================================================================================
Test: test_dotenv_optional
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - monkeypatch.setitem (:0)
  - monkeypatch.chdir (:0)
  - load_dotenv (cli.py:704)
    Source code:
      def load_dotenv(
          path: str | os.PathLike[str] | None = None, load_defaults: bool = True
      ) -> bool:
          """Load "dotenv" files to set environment variables. A given path takes
          precedence over ``.env``, which takes precedence over ``.flaskenv``. After
          loading and combining these files, values are only set if the key is not
          already set in ``os.environ``.
      
          This is a no-op if `python-dotenv`_ is not installed.
      
          .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme
      
          :param path: Load the file at this location.
          :param load_defaults: Search for and load the default ``.flaskenv`` and
              ``.env`` files.
          :return: ``True`` if at least one env var was loaded.
      
          .. versionchanged:: 3.1
              Added the ``load_defaults`` parameter. A given path takes precedence
              over default files.
      
          .. versionchanged:: 2.0
              The current directory is not changed to the location of the
              loaded file.
      
          .. versionchanged:: 2.0
              When loading the env files, set the default encoding to UTF-8.
      
          .. versionchanged:: 1.1.0
              Returns ``False`` when python-dotenv is not installed, or when
              the given path isn't a file.
      
          .. versionadded:: 1.0
          """
          try:
              import dotenv
          except ImportError:
              if path or os.path.isfile(".env") or os.path.isfile(".flaskenv"):
                  click.secho(
                      " * Tip: There are .env files present. Install python-dotenv"
                      " to use them.",
                      fg="yellow",
                      err=True,
                  )
      
              return False
      
          data: dict[str, str | None] = {}
      
          if load_defaults:
              for default_name in (".flaskenv", ".env"):
                  if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):
                      continue
      
                  data |= dotenv.dotenv_values(default_path, encoding="utf-8")
      
          if path is not None and os.path.isfile(path):
              data |= dotenv.dotenv_values(path, encoding="utf-8")
      
          for key, value in data.items():
              if key in os.environ or value is None:
                  continue
      
              os.environ[key] = value
      
          return bool(data)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setitem (:0)
    Called by: test_dotenv_optional
  - monkeypatch.chdir (:0)
    Called by: test_dotenv_optional
  - load_dotenv (cli.py:704)
    Called by: test_dotenv_optional

Test Source Code:
  def test_dotenv_optional(monkeypatch):
      monkeypatch.setitem(sys.modules, "dotenv", None)
      monkeypatch.chdir(test_path)
      load_dotenv()
      assert "FOO" not in os.environ

Assertions:
  - assert 'FOO' not in os.environ

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_dotenv_optional.json

================================================================================
Test: test_disable_dotenv_from_env
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - monkeypatch.chdir (:0)
  - monkeypatch.setitem (:0)
  - runner.invoke (:0)
  - FlaskGroup (:0)
  - need_dotenv (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.chdir (:0)
    Called by: test_disable_dotenv_from_env
  - monkeypatch.setitem (:0)
    Called by: test_disable_dotenv_from_env
  - runner.invoke (:0)
    Called by: test_disable_dotenv_from_env
  - FlaskGroup (:0)
    Called by: test_disable_dotenv_from_env
  - need_dotenv (:0)
    Called by: test_disable_dotenv_from_env

Test Source Code:
  def test_disable_dotenv_from_env(monkeypatch, runner):
      monkeypatch.chdir(test_path)
      monkeypatch.setitem(os.environ, "FLASK_SKIP_DOTENV", "1")
      runner.invoke(FlaskGroup())
      assert "FOO" not in os.environ

Assertions:
  - assert 'FOO' not in os.environ

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_disable_dotenv_from_env.json

================================================================================
Test: test_run_cert_path
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - run_command.make_context (:0)
  - run_command.make_context (:0)
  - run_command.make_context (:0)
  - run_command.make_context (:0)

Methods Actually Called (Dynamic Analysis):
  - run_command.make_context (:0)
    Called by: test_run_cert_path

Test Source Code:
  def test_run_cert_path():
      # no key
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--cert", __file__])
  
      # no cert
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--key", __file__])
  
      # cert specified first
      ctx = run_command.make_context("run", ["--cert", __file__, "--key", __file__])
      assert ctx.params["cert"] == (__file__, __file__)
  
      # key specified first
      ctx = run_command.make_context("run", ["--key", __file__, "--cert", __file__])
      assert ctx.params["cert"] == (__file__, __file__)

Assertions:
  - assert ctx.params['cert'] == (__file__, __file__)
  - assert ctx.params['cert'] == (__file__, __file__)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_cert_path.json

================================================================================
Test: test_run_cert_adhoc
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - monkeypatch.setitem (:0)
  - monkeypatch.setitem (:0)
  - run_command.make_context (:0)
  - run_command.make_context (:0)
  - run_command.make_context (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setitem (:0)
    Called by: test_run_cert_adhoc
  - run_command.make_context (:0)
    Called by: test_run_cert_adhoc

Test Source Code:
  def test_run_cert_adhoc(monkeypatch):
      monkeypatch.setitem(sys.modules, "cryptography", None)
  
      # cryptography not installed
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--cert", "adhoc"])
  
      # cryptography installed
      monkeypatch.setitem(sys.modules, "cryptography", types.ModuleType("cryptography"))
      ctx = run_command.make_context("run", ["--cert", "adhoc"])
      assert ctx.params["cert"] == "adhoc"
  
      # no key with adhoc
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--cert", "adhoc", "--key", __file__])

Assertions:
  - assert ctx.params['cert'] == 'adhoc'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_cert_adhoc.json

================================================================================
Test: test_run_cert_import
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - monkeypatch.setitem (:0)
  - monkeypatch.setitem (:0)
  - run_command.make_context (:0)
  - run_command.make_context (:0)
  - run_command.make_context (:0)
  - run_command.make_context (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setitem (:0)
    Called by: test_run_cert_import
  - run_command.make_context (:0)
    Called by: test_run_cert_import

Test Source Code:
  def test_run_cert_import(monkeypatch):
      monkeypatch.setitem(sys.modules, "not_here", None)
  
      # ImportError
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--cert", "not_here"])
  
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--cert", "flask"])
  
      # SSLContext
      ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
  
      monkeypatch.setitem(sys.modules, "ssl_context", ssl_context)
      ctx = run_command.make_context("run", ["--cert", "ssl_context"])
      assert ctx.params["cert"] is ssl_context
  
      # no --key with SSLContext
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--cert", "ssl_context", "--key", __file__])

Assertions:
  - assert ctx.params['cert'] is ssl_context

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_cert_import.json

================================================================================
Test: test_run_cert_no_ssl
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - monkeypatch.setitem (:0)
  - run_command.make_context (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setitem (:0)
    Called by: test_run_cert_no_ssl
  - run_command.make_context (:0)
    Called by: test_run_cert_no_ssl

Test Source Code:
  def test_run_cert_no_ssl(monkeypatch):
      monkeypatch.setitem(sys.modules, "ssl", None)
  
      with pytest.raises(click.BadParameter):
          run_command.make_context("run", ["--cert", "not_here"])

Assertions:

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_cert_no_ssl.json

================================================================================
Test: test_cli_blueprints
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - Blueprint (:0)
  - Blueprint (:0)
  - Blueprint (:0)
  - Blueprint (:0)
  - custom.cli.command (:0)
  - nested.cli.command (:0)
  - merged.cli.command (:0)
  - late.cli.command (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.register_blueprint (:0)
  - app.test_cli_runner (:0)
  - app_runner.invoke (:0)
  - app_runner.invoke (:0)
  - app_runner.invoke (:0)
  - app_runner.invoke (:0)

Methods Actually Called (Dynamic Analysis):
  - Blueprint (:0)
    Called by: test_cli_blueprints
  - custom.cli.command (:0)
    Called by: test_cli_blueprints
  - nested.cli.command (:0)
    Called by: test_cli_blueprints
  - merged.cli.command (:0)
    Called by: test_cli_blueprints
  - late.cli.command (:0)
    Called by: test_cli_blueprints
  - app.register_blueprint (:0)
    Called by: test_cli_blueprints
  - app.test_cli_runner (:0)
    Called by: test_cli_blueprints
  - app_runner.invoke (:0)
    Called by: test_cli_blueprints

Test Source Code:
  def test_cli_blueprints(app):
      """Test blueprint commands register correctly to the application"""
      custom = Blueprint("custom", __name__, cli_group="customized")
      nested = Blueprint("nested", __name__)
      merged = Blueprint("merged", __name__, cli_group=None)
      late = Blueprint("late", __name__)
  
      @custom.cli.command("custom")
      def custom_command():
          click.echo("custom_result")
  
      @nested.cli.command("nested")
      def nested_command():
          click.echo("nested_result")
  
      @merged.cli.command("merged")
      def merged_command():
          click.echo("merged_result")
  
      @late.cli.command("late")
      def late_command():
          click.echo("late_result")
  
      app.register_blueprint(custom)
      app.register_blueprint(nested)
      app.register_blueprint(merged)
      app.register_blueprint(late, cli_group="late_registration")
  
      app_runner = app.test_cli_runner()
  
      result = app_runner.invoke(args=["customized", "custom"])
      assert "custom_result" in result.output
  
      result = app_runner.invoke(args=["nested", "nested"])
      assert "nested_result" in result.output
  
      result = app_runner.invoke(args=["merged"])
      assert "merged_result" in result.output
  
      result = app_runner.invoke(args=["late_registration", "late"])
      assert "late_result" in result.output

Assertions:
  - assert 'custom_result' in result.output
  - assert 'nested_result' in result.output
  - assert 'merged_result' in result.output
  - assert 'late_result' in result.output

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_cli_blueprints.json

================================================================================
Test: test_cli_empty
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - Blueprint (:0)
  - app.register_blueprint (:0)
  - app.test_cli_runner.invoke (:0)
  - app.test_cli_runner (:0)

Methods Actually Called (Dynamic Analysis):
  - Blueprint (:0)
    Called by: test_cli_empty
  - app.register_blueprint (:0)
    Called by: test_cli_empty
  - app.test_cli_runner.invoke (:0)
    Called by: test_cli_empty
  - app.test_cli_runner (:0)
    Called by: test_cli_empty

Test Source Code:
  def test_cli_empty(app):
      """If a Blueprint's CLI group is empty, do not register it."""
      bp = Blueprint("blue", __name__, cli_group="blue")
      app.register_blueprint(bp)
  
      result = app.test_cli_runner().invoke(args=["blue", "--help"])
      assert result.exit_code == 2, f"Unexpected success:\n\n{result.output}"

Assertions:
  - assert result.exit_code == 2, f'Unexpected success:\n\n{result.output}'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_cli_empty.json

================================================================================
Test: test_run_exclude_patterns
File: __internal__/_data/flask/tests/test_cli.py

Methods Under Test (Static Analysis):
  - run_command.make_context (:0)

Methods Actually Called (Dynamic Analysis):
  - run_command.make_context (:0)
    Called by: test_run_exclude_patterns

Test Source Code:
  def test_run_exclude_patterns():
      ctx = run_command.make_context("run", ["--exclude-patterns", __file__])
      assert ctx.params["exclude_patterns"] == [__file__]

Assertions:
  - assert ctx.params['exclude_patterns'] == [__file__]

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_run_exclude_patterns.json

================================================================================
Test: test_context_processing
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_context_processing
  - client.get (:0)
    Called by: test_context_processing

Test Source Code:
  def test_context_processing(app, client):
      @app.context_processor
      def context_processor():
          return {"injected_value": 42}
  
      @app.route("/")
      def index():
          return flask.render_template("context_template.html", value=23)
  
      rv = client.get("/")
      assert rv.data == b"<p>23|42"

Assertions:
  - assert rv.data == b'<p>23|42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_context_processing.json

================================================================================
Test: test_original_win
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_original_win
  - client.get (:0)
    Called by: test_original_win

Test Source Code:
  def test_original_win(app, client):
      @app.route("/")
      def index():
          return flask.render_template_string("{{ config }}", config=42)
  
      rv = client.get("/")
      assert rv.data == b"42"

Assertions:
  - assert rv.data == b'42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_original_win.json

================================================================================
Test: test_simple_stream
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_simple_stream
  - client.get (:0)
    Called by: test_simple_stream

Test Source Code:
  def test_simple_stream(app, client):
      @app.route("/")
      def index():
          return flask.stream_template_string("{{ config }}", config=42)
  
      rv = client.get("/")
      assert rv.data == b"42"

Assertions:
  - assert rv.data == b'42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_simple_stream.json

================================================================================
Test: test_request_less_rendering
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - dict (:0)

Methods Actually Called (Dynamic Analysis):
  - dict (:0)
    Called by: test_request_less_rendering

Test Source Code:
  def test_request_less_rendering(app, app_ctx):
      app.config["WORLD_NAME"] = "Special World"
  
      @app.context_processor
      def context_processor():
          return dict(foo=42)
  
      rv = flask.render_template_string("Hello {{ config.WORLD_NAME }} {{ foo }}")
      assert rv == "Hello Special World 42"

Assertions:
  - assert rv == 'Hello Special World 42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_request_less_rendering.json

================================================================================
Test: test_standard_context
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)
  - rv.data.split (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_standard_context
  - client.get (:0)
    Called by: test_standard_context
  - rv.data.split (:0)
    Called by: test_standard_context

Test Source Code:
  def test_standard_context(app, client):
      @app.route("/")
      def index():
          flask.g.foo = 23
          flask.session["test"] = "aha"
          return flask.render_template_string(
              """
              {{ request.args.foo }}
              {{ g.foo }}
              {{ config.DEBUG }}
              {{ session.test }}
          """
          )
  
      rv = client.get("/?foo=42")
      assert rv.data.split() == [b"42", b"23", b"False", b"aha"]

Assertions:
  - assert rv.data.split() == [b'42', b'23', b'False', b'aha']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_standard_context.json

================================================================================
Test: test_escaping
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get.data.splitlines (:0)
  - Markup (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_escaping
  - client.get.data.splitlines (:0)
    Called by: test_escaping
  - Markup (:0)
    Called by: test_escaping
  - client.get (:0)
    Called by: test_escaping

Test Source Code:
  def test_escaping(app, client):
      text = "<p>Hello World!"
  
      @app.route("/")
      def index():
          return flask.render_template(
              "escaping_template.html", text=text, html=Markup(text)
          )
  
      lines = client.get("/").data.splitlines()
      assert lines == [
          b"&lt;p&gt;Hello World!",
          b"<p>Hello World!",
          b"<p>Hello World!",
          b"<p>Hello World!",
          b"&lt;p&gt;Hello World!",
          b"<p>Hello World!",
      ]

Assertions:
  - assert lines == [b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_escaping.json

================================================================================
Test: test_no_escaping
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get.data.splitlines (:0)
  - Markup (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_no_escaping
  - client.get.data.splitlines (:0)
    Called by: test_no_escaping
  - Markup (:0)
    Called by: test_no_escaping
  - client.get (:0)
    Called by: test_no_escaping

Test Source Code:
  def test_no_escaping(app, client):
      text = "<p>Hello World!"
  
      @app.route("/")
      def index():
          return flask.render_template(
              "non_escaping_template.txt", text=text, html=Markup(text)
          )
  
      lines = client.get("/").data.splitlines()
      assert lines == [
          b"<p>Hello World!",
          b"<p>Hello World!",
          b"<p>Hello World!",
          b"<p>Hello World!",
          b"&lt;p&gt;Hello World!",
          b"<p>Hello World!",
          b"<p>Hello World!",
          b"<p>Hello World!",
      ]

Assertions:
  - assert lines == [b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'&lt;p&gt;Hello World!', b'<p>Hello World!', b'<p>Hello World!', b'<p>Hello World!']

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_no_escaping.json

================================================================================
Test: test_escaping_without_template_filename
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_escaping_without_template_filename(app, client, req_ctx):
      assert flask.render_template_string("{{ foo }}", foo="<test>") == "&lt;test&gt;"
      assert flask.render_template("mail.txt", foo="<test>") == "<test> Mail"

Assertions:
  - assert flask.render_template_string('{{ foo }}', foo='<test>') == '&lt;test&gt;'
  - assert flask.render_template('mail.txt', foo='<test>') == '<test> Mail'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_escaping_without_template_filename.json

================================================================================
Test: test_macros
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - macro (:0)

Methods Actually Called (Dynamic Analysis):
  - macro (:0)
    Called by: test_macros

Test Source Code:
  def test_macros(app, req_ctx):
      macro = flask.get_template_attribute("_macro.html", "hello")
      assert macro("World") == "Hello World!"

Assertions:
  - assert macro('World') == 'Hello World!'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_macros.json

================================================================================
Test: test_template_filter
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_filter (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_filter (:0)
    Called by: test_template_filter
  - app.jinja_env.filters.keys (:0)
    Called by: test_template_filter
  - app.jinja_env.filters (:0)
    Called by: test_template_filter

Test Source Code:
  def test_template_filter(app):
      @app.template_filter()
      def my_reverse(s):
          return s[::-1]
  
      assert "my_reverse" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["my_reverse"] == my_reverse
      assert app.jinja_env.filters["my_reverse"]("abcd") == "dcba"

Assertions:
  - assert 'my_reverse' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['my_reverse'] == my_reverse
  - assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter.json

================================================================================
Test: test_add_template_filter
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_filter (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_filter (:0)
    Called by: test_add_template_filter
  - app.jinja_env.filters.keys (:0)
    Called by: test_add_template_filter
  - app.jinja_env.filters (:0)
    Called by: test_add_template_filter

Test Source Code:
  def test_add_template_filter(app):
      def my_reverse(s):
          return s[::-1]
  
      app.add_template_filter(my_reverse)
      assert "my_reverse" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["my_reverse"] == my_reverse
      assert app.jinja_env.filters["my_reverse"]("abcd") == "dcba"

Assertions:
  - assert 'my_reverse' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['my_reverse'] == my_reverse
  - assert app.jinja_env.filters['my_reverse']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter.json

================================================================================
Test: test_template_filter_with_name
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_filter (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_filter (:0)
    Called by: test_template_filter_with_name
  - app.jinja_env.filters.keys (:0)
    Called by: test_template_filter_with_name
  - app.jinja_env.filters (:0)
    Called by: test_template_filter_with_name

Test Source Code:
  def test_template_filter_with_name(app):
      @app.template_filter("strrev")
      def my_reverse(s):
          return s[::-1]
  
      assert "strrev" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["strrev"] == my_reverse
      assert app.jinja_env.filters["strrev"]("abcd") == "dcba"

Assertions:
  - assert 'strrev' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['strrev'] == my_reverse
  - assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter_with_name.json

================================================================================
Test: test_add_template_filter_with_name
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_filter (:0)
  - app.jinja_env.filters.keys (:0)
  - app.jinja_env.filters (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_filter (:0)
    Called by: test_add_template_filter_with_name
  - app.jinja_env.filters.keys (:0)
    Called by: test_add_template_filter_with_name
  - app.jinja_env.filters (:0)
    Called by: test_add_template_filter_with_name

Test Source Code:
  def test_add_template_filter_with_name(app):
      def my_reverse(s):
          return s[::-1]
  
      app.add_template_filter(my_reverse, "strrev")
      assert "strrev" in app.jinja_env.filters.keys()
      assert app.jinja_env.filters["strrev"] == my_reverse
      assert app.jinja_env.filters["strrev"]("abcd") == "dcba"

Assertions:
  - assert 'strrev' in app.jinja_env.filters.keys()
  - assert app.jinja_env.filters['strrev'] == my_reverse
  - assert app.jinja_env.filters['strrev']('abcd') == 'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter_with_name.json

================================================================================
Test: test_template_filter_with_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_filter (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_filter (:0)
    Called by: test_template_filter_with_template
  - app.route (:0)
    Called by: test_template_filter_with_template
  - client.get (:0)
    Called by: test_template_filter_with_template

Test Source Code:
  def test_template_filter_with_template(app, client):
      @app.template_filter()
      def super_reverse(s):
          return s[::-1]
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter_with_template.json

================================================================================
Test: test_add_template_filter_with_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_filter (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_filter (:0)
    Called by: test_add_template_filter_with_template
  - app.route (:0)
    Called by: test_add_template_filter_with_template
  - client.get (:0)
    Called by: test_add_template_filter_with_template

Test Source Code:
  def test_add_template_filter_with_template(app, client):
      def super_reverse(s):
          return s[::-1]
  
      app.add_template_filter(super_reverse)
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter_with_template.json

================================================================================
Test: test_template_filter_with_name_and_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_filter (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_filter (:0)
    Called by: test_template_filter_with_name_and_template
  - app.route (:0)
    Called by: test_template_filter_with_name_and_template
  - client.get (:0)
    Called by: test_template_filter_with_name_and_template

Test Source Code:
  def test_template_filter_with_name_and_template(app, client):
      @app.template_filter("super_reverse")
      def my_reverse(s):
          return s[::-1]
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_filter_with_name_and_template.json

================================================================================
Test: test_add_template_filter_with_name_and_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_filter (:0)
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_filter (:0)
    Called by: test_add_template_filter_with_name_and_template
  - app.route (:0)
    Called by: test_add_template_filter_with_name_and_template
  - client.get (:0)
    Called by: test_add_template_filter_with_name_and_template

Test Source Code:
  def test_add_template_filter_with_name_and_template(app, client):
      def my_reverse(s):
          return s[::-1]
  
      app.add_template_filter(my_reverse, "super_reverse")
  
      @app.route("/")
      def index():
          return flask.render_template("template_filter.html", value="abcd")
  
      rv = client.get("/")
      assert rv.data == b"dcba"

Assertions:
  - assert rv.data == b'dcba'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_filter_with_name_and_template.json

================================================================================
Test: test_template_test
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_test (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_test (:0)
    Called by: test_template_test
  - app.jinja_env.tests (:0)
    Called by: test_template_test
  - isinstance (:0)
    Called by: test_template_test
  - app.jinja_env.tests.keys (:0)
    Called by: test_template_test

Test Source Code:
  def test_template_test(app):
      @app.template_test()
      def boolean(value):
          return isinstance(value, bool)
  
      assert "boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["boolean"] == boolean
      assert app.jinja_env.tests["boolean"](False)

Assertions:
  - assert 'boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['boolean'] == boolean
  - assert app.jinja_env.tests['boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test.json

================================================================================
Test: test_add_template_test
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_test (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_test (:0)
    Called by: test_add_template_test
  - app.jinja_env.tests (:0)
    Called by: test_add_template_test
  - isinstance (:0)
    Called by: test_add_template_test
  - app.jinja_env.tests.keys (:0)
    Called by: test_add_template_test

Test Source Code:
  def test_add_template_test(app):
      def boolean(value):
          return isinstance(value, bool)
  
      app.add_template_test(boolean)
      assert "boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["boolean"] == boolean
      assert app.jinja_env.tests["boolean"](False)

Assertions:
  - assert 'boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['boolean'] == boolean
  - assert app.jinja_env.tests['boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test.json

================================================================================
Test: test_template_test_with_name
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_test (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_test (:0)
    Called by: test_template_test_with_name
  - app.jinja_env.tests (:0)
    Called by: test_template_test_with_name
  - isinstance (:0)
    Called by: test_template_test_with_name
  - app.jinja_env.tests.keys (:0)
    Called by: test_template_test_with_name

Test Source Code:
  def test_template_test_with_name(app):
      @app.template_test("boolean")
      def is_boolean(value):
          return isinstance(value, bool)
  
      assert "boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["boolean"] == is_boolean
      assert app.jinja_env.tests["boolean"](False)

Assertions:
  - assert 'boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['boolean'] == is_boolean
  - assert app.jinja_env.tests['boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test_with_name.json

================================================================================
Test: test_add_template_test_with_name
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_test (:0)
  - app.jinja_env.tests (:0)
  - isinstance (:0)
  - app.jinja_env.tests.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_test (:0)
    Called by: test_add_template_test_with_name
  - app.jinja_env.tests (:0)
    Called by: test_add_template_test_with_name
  - isinstance (:0)
    Called by: test_add_template_test_with_name
  - app.jinja_env.tests.keys (:0)
    Called by: test_add_template_test_with_name

Test Source Code:
  def test_add_template_test_with_name(app):
      def is_boolean(value):
          return isinstance(value, bool)
  
      app.add_template_test(is_boolean, "boolean")
      assert "boolean" in app.jinja_env.tests.keys()
      assert app.jinja_env.tests["boolean"] == is_boolean
      assert app.jinja_env.tests["boolean"](False)

Assertions:
  - assert 'boolean' in app.jinja_env.tests.keys()
  - assert app.jinja_env.tests['boolean'] == is_boolean
  - assert app.jinja_env.tests['boolean'](False)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test_with_name.json

================================================================================
Test: test_template_test_with_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_test (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_test (:0)
    Called by: test_template_test_with_template
  - app.route (:0)
    Called by: test_template_test_with_template
  - client.get (:0)
    Called by: test_template_test_with_template
  - isinstance (:0)
    Called by: test_template_test_with_template

Test Source Code:
  def test_template_test_with_template(app, client):
      @app.template_test()
      def boolean(value):
          return isinstance(value, bool)
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test_with_template.json

================================================================================
Test: test_add_template_test_with_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_test (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_test (:0)
    Called by: test_add_template_test_with_template
  - app.route (:0)
    Called by: test_add_template_test_with_template
  - client.get (:0)
    Called by: test_add_template_test_with_template
  - isinstance (:0)
    Called by: test_add_template_test_with_template

Test Source Code:
  def test_add_template_test_with_template(app, client):
      def boolean(value):
          return isinstance(value, bool)
  
      app.add_template_test(boolean)
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test_with_template.json

================================================================================
Test: test_template_test_with_name_and_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_test (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_test (:0)
    Called by: test_template_test_with_name_and_template
  - app.route (:0)
    Called by: test_template_test_with_name_and_template
  - client.get (:0)
    Called by: test_template_test_with_name_and_template
  - isinstance (:0)
    Called by: test_template_test_with_name_and_template

Test Source Code:
  def test_template_test_with_name_and_template(app, client):
      @app.template_test("boolean")
      def is_boolean(value):
          return isinstance(value, bool)
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_test_with_name_and_template.json

================================================================================
Test: test_add_template_test_with_name_and_template
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.add_template_test (:0)
  - app.route (:0)
  - client.get (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - app.add_template_test (:0)
    Called by: test_add_template_test_with_name_and_template
  - app.route (:0)
    Called by: test_add_template_test_with_name_and_template
  - client.get (:0)
    Called by: test_add_template_test_with_name_and_template
  - isinstance (:0)
    Called by: test_add_template_test_with_name_and_template

Test Source Code:
  def test_add_template_test_with_name_and_template(app, client):
      def is_boolean(value):
          return isinstance(value, bool)
  
      app.add_template_test(is_boolean, "boolean")
  
      @app.route("/")
      def index():
          return flask.render_template("template_test.html", value=False)
  
      rv = client.get("/")
      assert b"Success!" in rv.data

Assertions:
  - assert b'Success!' in rv.data

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_test_with_name_and_template.json

================================================================================
Test: test_add_template_global
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.template_global (:0)
  - app.jinja_env.globals (:0)
  - app.jinja_env.globals.keys (:0)

Methods Actually Called (Dynamic Analysis):
  - app.template_global (:0)
    Called by: test_add_template_global
  - app.jinja_env.globals (:0)
    Called by: test_add_template_global
  - app.jinja_env.globals.keys (:0)
    Called by: test_add_template_global

Test Source Code:
  def test_add_template_global(app, app_ctx):
      @app.template_global()
      def get_stuff():
          return 42
  
      assert "get_stuff" in app.jinja_env.globals.keys()
      assert app.jinja_env.globals["get_stuff"] == get_stuff
      assert app.jinja_env.globals["get_stuff"](), 42
  
      rv = flask.render_template_string("{{ get_stuff() }}")
      assert rv == "42"

Assertions:
  - assert 'get_stuff' in app.jinja_env.globals.keys()
  - assert app.jinja_env.globals['get_stuff'] == get_stuff
  - assert app.jinja_env.globals['get_stuff'](), 42
  - assert rv == '42'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_add_template_global.json

================================================================================
Test: test_custom_template_loader
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - MyFlask (:0)
  - app.route (:0)
  - app.test_client (:0)
  - c.get (:0)
  - DictLoader (:0)

Methods Actually Called (Dynamic Analysis):
  - MyFlask (:0)
    Called by: test_custom_template_loader
  - app.route (:0)
    Called by: test_custom_template_loader
  - app.test_client (:0)
    Called by: test_custom_template_loader
  - c.get (:0)
    Called by: test_custom_template_loader
  - DictLoader (:0)
    Called by: test_custom_template_loader

Test Source Code:
  def test_custom_template_loader(client):
      class MyFlask(flask.Flask):
          def create_global_jinja_loader(self):
              from jinja2 import DictLoader
  
              return DictLoader({"index.html": "Hello Custom World!"})
  
      app = MyFlask(__name__)
  
      @app.route("/")
      def index():
          return flask.render_template("index.html")
  
      c = app.test_client()
      rv = c.get("/")
      assert rv.data == b"Hello Custom World!"

Assertions:
  - assert rv.data == b'Hello Custom World!'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_custom_template_loader.json

================================================================================
Test: test_iterable_loader
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.route (:0)
  - client.get (:0)

Methods Actually Called (Dynamic Analysis):
  - app.route (:0)
    Called by: test_iterable_loader
  - client.get (:0)
    Called by: test_iterable_loader

Test Source Code:
  def test_iterable_loader(app, client):
      @app.context_processor
      def context_processor():
          return {"whiskey": "Jameson"}
  
      @app.route("/")
      def index():
          return flask.render_template(
              [
                  "no_template.xml",  # should skip this one
                  "simple_template.html",  # should render this
                  "context_template.html",
              ],
              value=23,
          )
  
      rv = client.get("/")
      assert rv.data == b"<h1>Jameson</h1>"

Assertions:
  - assert rv.data == b'<h1>Jameson</h1>'

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_iterable_loader.json

================================================================================
Test: test_templates_auto_reload
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):

Methods Actually Called (Dynamic Analysis):

Test Source Code:
  def test_templates_auto_reload(app):
      # debug is False, config option is None
      assert app.debug is False
      assert app.config["TEMPLATES_AUTO_RELOAD"] is None
      assert app.jinja_env.auto_reload is False
      # debug is False, config option is False
      app = flask.Flask(__name__)
      app.config["TEMPLATES_AUTO_RELOAD"] = False
      assert app.debug is False
      assert app.jinja_env.auto_reload is False
      # debug is False, config option is True
      app = flask.Flask(__name__)
      app.config["TEMPLATES_AUTO_RELOAD"] = True
      assert app.debug is False
      assert app.jinja_env.auto_reload is True
      # debug is True, config option is None
      app = flask.Flask(__name__)
      app.config["DEBUG"] = True
      assert app.config["TEMPLATES_AUTO_RELOAD"] is None
      assert app.jinja_env.auto_reload is True
      # debug is True, config option is False
      app = flask.Flask(__name__)
      app.config["DEBUG"] = True
      app.config["TEMPLATES_AUTO_RELOAD"] = False
      assert app.jinja_env.auto_reload is False
      # debug is True, config option is True
      app = flask.Flask(__name__)
      app.config["DEBUG"] = True
      app.config["TEMPLATES_AUTO_RELOAD"] = True
      assert app.jinja_env.auto_reload is True

Assertions:
  - assert app.debug is False
  - assert app.config['TEMPLATES_AUTO_RELOAD'] is None
  - assert app.jinja_env.auto_reload is False
  - assert app.debug is False
  - assert app.jinja_env.auto_reload is False
  - assert app.debug is False
  - assert app.jinja_env.auto_reload is True
  - assert app.config['TEMPLATES_AUTO_RELOAD'] is None
  - assert app.jinja_env.auto_reload is True
  - assert app.jinja_env.auto_reload is False
  - assert app.jinja_env.auto_reload is True

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_templates_auto_reload.json

================================================================================
Test: test_templates_auto_reload_debug_run
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - monkeypatch.setattr (:0)
  - app.run (:0)
  - app.run (:0)

Methods Actually Called (Dynamic Analysis):
  - monkeypatch.setattr (:0)
    Called by: test_templates_auto_reload_debug_run
  - app.run (:0)
    Called by: test_templates_auto_reload_debug_run

Test Source Code:
  def test_templates_auto_reload_debug_run(app, monkeypatch):
      def run_simple_mock(*args, **kwargs):
          pass
  
      monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
  
      app.run()
      assert not app.jinja_env.auto_reload
  
      app.run(debug=True)
      assert app.jinja_env.auto_reload

Assertions:
  - assert not app.jinja_env.auto_reload
  - assert app.jinja_env.auto_reload

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_templates_auto_reload_debug_run.json

================================================================================
Test: test_template_loader_debugging
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - app.test_client (:0)
  - app.test_client (:0)
  - monkeypatch.setitem (:0)
  - monkeypatch.setattr (:0)
  - len (:0)
  - called.append (:0)
  - str (:0)
  - c.get (:0)
  - str (:0)
  - _TestHandler (:0)

Methods Actually Called (Dynamic Analysis):
  - app.test_client (:0)
    Called by: test_template_loader_debugging
  - monkeypatch.setitem (:0)
    Called by: test_template_loader_debugging
  - monkeypatch.setattr (:0)
    Called by: test_template_loader_debugging
  - len (:0)
    Called by: test_template_loader_debugging
  - called.append (:0)
    Called by: test_template_loader_debugging
  - str (:0)
    Called by: test_template_loader_debugging
  - c.get (:0)
    Called by: test_template_loader_debugging
  - _TestHandler (:0)
    Called by: test_template_loader_debugging

Test Source Code:
  def test_template_loader_debugging(test_apps, monkeypatch):
      from blueprintapp import app
  
      called = []
  
      class _TestHandler(logging.Handler):
          def handle(self, record):
              called.append(True)
              text = str(record.msg)
              assert "1: trying loader of application 'blueprintapp'" in text
              assert (
                  "2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)"
              ) in text
              assert (
                  "trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)"
              ) in text
              assert "Error: the template could not be found" in text
              assert (
                  "looked up from an endpoint that belongs to the blueprint 'frontend'"
              ) in text
              assert "See https://flask.palletsprojects.com/blueprints/#templates" in text
  
      with app.test_client() as c:
          monkeypatch.setitem(app.config, "EXPLAIN_TEMPLATE_LOADING", True)
          monkeypatch.setattr(
              logging.getLogger("blueprintapp"), "handlers", [_TestHandler()]
          )
  
          with pytest.raises(TemplateNotFound) as excinfo:
              c.get("/missing")
  
          assert "missing_template.html" in str(excinfo.value)
  
      assert len(called) == 1

Assertions:
  - assert len(called) == 1
  - assert 'missing_template.html' in str(excinfo.value)
  - assert "1: trying loader of application 'blueprintapp'" in text
  - assert "2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)" in text
  - assert "trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)" in text
  - assert 'Error: the template could not be found' in text
  - assert "looked up from an endpoint that belongs to the blueprint 'frontend'" in text
  - assert 'See https://flask.palletsprojects.com/blueprints/#templates' in text

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_template_loader_debugging.json

================================================================================
Test: test_custom_jinja_env
File: __internal__/_data/flask/tests/test_templating.py

Methods Under Test (Static Analysis):
  - CustomFlask (:0)
  - isinstance (:0)

Methods Actually Called (Dynamic Analysis):
  - CustomFlask (:0)
    Called by: test_custom_jinja_env
  - isinstance (:0)
    Called by: test_custom_jinja_env

Test Source Code:
  def test_custom_jinja_env():
      class CustomEnvironment(flask.templating.Environment):
          pass
  
      class CustomFlask(flask.Flask):
          jinja_environment = CustomEnvironment
  
      app = CustomFlask(__name__)
      assert isinstance(app.jinja_env, CustomEnvironment)

Assertions:
  - assert isinstance(app.jinja_env, CustomEnvironment)

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_custom_jinja_env.json

================================================================================
Test: test_open_session_with_endpoint
File: __internal__/_data/flask/tests/test_session_interface.py

Methods Under Test (Static Analysis):
  - MySessionInterface (:0)
  - app.get (:0)
  - app.test_client.get (:0)
  - request_ctx.match_request (:0)
  - app.test_client (:0)

Methods Actually Called (Dynamic Analysis):
  - MySessionInterface (:0)
    Called by: test_open_session_with_endpoint
  - app.get (:0)
    Called by: test_open_session_with_endpoint
  - app.test_client.get (:0)
    Called by: test_open_session_with_endpoint
  - request_ctx.match_request (:0)
    Called by: test_open_session_with_endpoint
  - app.test_client (:0)
    Called by: test_open_session_with_endpoint

Test Source Code:
  def test_open_session_with_endpoint():
      """If request.endpoint (or other URL matching behavior) is needed
      while loading the session, RequestContext.match_request() can be
      called manually.
      """
  
      class MySessionInterface(SessionInterface):
          def save_session(self, app, session, response):
              pass
  
          def open_session(self, app, request):
              request_ctx.match_request()
              assert request.endpoint is not None
  
      app = flask.Flask(__name__)
      app.session_interface = MySessionInterface()
  
      @app.get("/")
      def index():
          return "Hello, World!"
  
      response = app.test_client().get("/")
      assert response.status_code == 200

Assertions:
  - assert response.status_code == 200
  - assert request.endpoint is not None

Mocks:
================================================================================
Detailed analysis saved to: __internal__/collected_tests_hybrid/v1/flask/test_analysis_test_open_session_with_endpoint.json
